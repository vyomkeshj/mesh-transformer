###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### How many heads of the departments are older than 56?
SELECT count(*) FROM head WHERE age > 56; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### List the name, born state and age of the heads of departments ordered by age.
SELECT name,born_state,age FROM head ORDER BY age; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### List the creation year, name and budget of each department.
SELECT creation,name,budget_in_billions FROM department; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### What are the maximum and minimum budget of the departments?
SELECT max(budget_in_billions),min(budget_in_billions) FROM department; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### What is the average number of employees of the departments whose rank is between 10 and 15?
SELECT avg(num_employees) FROM department WHERE ranking BETWEEN 10 AND 15; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### What are the names of the heads who are born outside the California state?
SELECT name FROM head WHERE born_state != 'California'; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### What are the names of the states where at least 3 heads were born?
SELECT born_state FROM head GROUP BY born_state HAVING count(*) >= 3; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### In which year were most departments established?
SELECT creation FROM department GROUP BY creation ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### How many acting statuses are there?
SELECT count(DISTINCT temporary_acting) FROM management; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### How many departments are led by heads who are not mentioned?
SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);; ###
###Postgre SQL tables, with their properties:
# department: ["department_id", "name", "creation", "ranking", "budget_in_billions", "num_employees"]
# head: ["head_id", "name", "born_state", "age"]
# management: ["department_id", "head_id", "temporary_acting"]
### Which head's name has the substring 'Ha'? List the id and name.
SELECT head_id,name FROM head WHERE name LIKE '%Ha%'; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### How many farms are there?
SELECT count(*) FROM farm; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Count the number of farms.
SELECT count(*) FROM farm; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### List the total number of horses on farms in ascending order.
SELECT Total_Horses FROM farm ORDER BY Total_Horses ASC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What is the total horses record for each farm, sorted ascending?
SELECT Total_Horses FROM farm ORDER BY Total_Horses ASC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the hosts of competitions whose theme is not "Aliens"?
SELECT Hosts FROM farm_competition WHERE Theme != 'Aliens'; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Return the hosts of competitions for which the theme is not Aliens?
SELECT Hosts FROM farm_competition WHERE Theme != 'Aliens'; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the themes of farm competitions sorted by year in ascending order?
SELECT Theme FROM farm_competition ORDER BY YEAR ASC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Return the themes of farm competitions, sorted by year ascending.
SELECT Theme FROM farm_competition ORDER BY YEAR ASC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What is the average number of working horses of farms with more than 5000 total number of horses?
SELECT avg(Working_Horses) FROM farm WHERE Total_Horses > 5000; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Give the average number of working horses on farms with more than 5000 total horses.
SELECT avg(Working_Horses) FROM farm WHERE Total_Horses > 5000; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the maximum and minimum number of cows across all farms.
SELECT max(Cows),min(Cows) FROM farm; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Return the maximum and minimum number of cows across all farms.
SELECT max(Cows),min(Cows) FROM farm; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### How many different statuses do cities have?
SELECT count(DISTINCT Status) FROM city; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Count the number of different statuses.
SELECT count(DISTINCT Status) FROM city; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### List official names of cities in descending order of population.
SELECT Official_Name FROM city ORDER BY Population DESC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the official names of cities, ordered descending by population?
SELECT Official_Name FROM city ORDER BY Population DESC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### List the official name and status of the city with the largest population.
SELECT Official_Name,Status FROM city ORDER BY Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What is the official name and status of the city with the most residents?
SELECT Official_Name,Status FROM city ORDER BY Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Please show the different statuses of cities and the average population of cities with each status.
SELECT Status,avg(Population) FROM city GROUP BY Status; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the statuses and average populations of each city?
SELECT Status,avg(Population) FROM city GROUP BY Status; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Please show the different statuses, ordered by the number of cities that have each.
SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Return the different statuses of cities, ascending by frequency.
SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### List the most common type of Status across cities.
SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What is the most common status across all cities?
SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### List the official names of cities that have not held any competition.
SELECT Official_Name FROM city WHERE City_ID NOT IN (SELECT Host_city_ID FROM farm_competition); ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the official names of cities that have not hosted a farm competition?
SELECT Official_Name FROM city WHERE City_ID NOT IN (SELECT Host_city_ID FROM farm_competition); ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Show the status shared by cities with population bigger than 1500 and smaller than 500.
SELECT Status FROM city WHERE Population > 1500 INTERSECT SELECT Status FROM city WHERE Population < 500; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Which statuses correspond to both cities that have a population over 1500 and cities that have a population lower than 500?
SELECT Status FROM city WHERE Population > 1500 INTERSECT SELECT Status FROM city WHERE Population < 500; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Find the official names of cities with population bigger than 1500 or smaller than 500.
SELECT Official_Name FROM city WHERE Population > 1500 OR Population < 500; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the official names of cities that have population over 1500 or less than 500?
SELECT Official_Name FROM city WHERE Population > 1500 OR Population < 500; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### Show the census ranking of cities whose status are not "Village".
SELECT Census_Ranking FROM city WHERE Status != "Village"; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "official_name", "status", "area_km_2", "population", "census_ranking"]
# farm: ["farm_id", "year", "total_horses", "working_horses", "total_cattle", "oxen", "bulls", "cows", "pigs", "sheep_and_goats"]
# farm_competition: ["competition_id", "year", "theme", "host_city_id", "hosts"]
# competition_record: ["competition_id", "farm_id", "rank"]
### What are the census rankings of cities that do not have the status "Village"?
SELECT Census_Ranking FROM city WHERE Status != "Village"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### what is id of students who registered some courses but the least number of courses in these students?
SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of the students who registered for some courses but had the least number of courses for all students?
SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### List the id of students who never attends courses?
SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of every student who has never attended a course?
SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### List the id of students who attended some courses?
SELECT student_id FROM student_course_attendance; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of all students who have attended at least one course?
SELECT student_id FROM student_course_attendance; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### Find id of the candidate who most recently accessed the course?
SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What is the id of the candidate who most recently accessed the course?
SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### Find id of candidates whose assessment code is "Pass"?
SELECT candidate_id FROM candidate_assessments WHERE asessment_outcome_code = "Pass"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of the candidates that have an outcome code of Pass?
SELECT candidate_id FROM candidate_assessments WHERE asessment_outcome_code = "Pass"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the id of students who registered course 301?
SELECT student_id FROM student_course_attendance WHERE course_id = 301; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of the students who registered for course 301?
SELECT student_id FROM student_course_attendance WHERE course_id = 301; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What is the id of the student who most recently registered course 301?
SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of the students who registered for course 301 most recently?
SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### List the names of courses in alphabetical order?
SELECT course_name FROM courses ORDER BY course_name; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the names of the courses in alphabetical order?
SELECT course_name FROM courses ORDER BY course_name; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### List the first names of people in alphabetical order?
SELECT first_name FROM people ORDER BY first_name; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the first names of the people in alphabetical order?
SELECT first_name FROM people ORDER BY first_name; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the id of students who registered courses or attended courses?
SELECT student_id FROM student_course_registrations UNION SELECT student_id FROM student_course_attendance; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of the students who either registered or attended a course?
SELECT student_id FROM student_course_registrations UNION SELECT student_id FROM student_course_attendance; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### Find the id of courses which are registered or attended by student whose id is 121?
SELECT course_id FROM student_course_registrations WHERE student_id = 121 UNION SELECT course_id FROM student_course_attendance WHERE student_id = 121; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are the ids of the courses that are registered or attended by the student whose id is 121?
SELECT course_id FROM student_course_registrations WHERE student_id = 121 UNION SELECT course_id FROM student_course_attendance WHERE student_id = 121; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are all info of students who registered courses but not attended courses?
SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"]
# people: ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"]
# students: ["student_id", "student_details"]
# courses: ["course_id", "course_name", "course_description", "other_details"]
# people_addresses: ["person_address_id", "person_id", "address_id", "date_from", "date_to"]
# student_course_registrations: ["student_id", "course_id", "registration_date"]
# student_course_attendance: ["student_id", "course_id", "date_of_attendance"]
# candidates: ["candidate_id", "candidate_details"]
# candidate_assessments: ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]
### What are all details of the students who registered but did not attend any course?
SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Give me the dates when the max temperature was higher than 85.
SELECT date FROM weather WHERE max_temperature_f > 85; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the dates with a maximum temperature higher than 85?
SELECT date FROM weather WHERE max_temperature_f > 85; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the names of stations that have latitude lower than 37.5?
SELECT name FROM station WHERE lat < 37.5; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the names of all stations with a latitude smaller than 37.5?
SELECT name FROM station WHERE lat < 37.5; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each city, return the highest latitude among its stations.
SELECT city,max(lat) FROM station GROUP BY city; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each city, what is the highest latitude for its stations?
SELECT city,max(lat) FROM station GROUP BY city; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Give me the start station and end station for the trips with the three oldest id.
SELECT start_station_name,end_station_name FROM trip ORDER BY id LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the station station and end station for the trips with the three smallest ids?
SELECT start_station_name,end_station_name FROM trip ORDER BY id LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the average latitude and longitude of stations located in San Jose city?
SELECT avg(lat),avg(long) FROM station WHERE city = "San_Jose"; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the average latitude and longitude in San Jose?
SELECT avg(lat),avg(long) FROM station WHERE city = "San_Jose"; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the id of the trip that has the shortest duration?
SELECT id FROM trip ORDER BY duration LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the id of the shortest trip?
SELECT id FROM trip ORDER BY duration LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the total and maximum duration of trips with bike id 636?
SELECT sum(duration),max(duration) FROM trip WHERE bike_id = 636; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the total and maximum duration for all trips with the bike id 636?
SELECT sum(duration),max(duration) FROM trip WHERE bike_id = 636; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each zip code, return the average mean temperature of August there.
SELECT zip_code ,avg(mean_temperature_f) FROM weather WHERE date LIKE "8/%" GROUP BY zip_code; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each zip code, what is the average mean temperature for all dates that start with '8'?
SELECT zip_code ,avg(mean_temperature_f) FROM weather WHERE date LIKE "8/%" GROUP BY zip_code; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### From the trip record, find the number of unique bikes.
SELECT count(DISTINCT bike_id) FROM trip; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### How many different bike ids are there?
SELECT count(DISTINCT bike_id) FROM trip; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the number of distinct cities the stations are located at?
SELECT count(DISTINCT city) FROM station; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### How many different cities have these stations?
SELECT count(DISTINCT city) FROM station; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### How many stations does Mountain View city has?
SELECT COUNT(*) FROM station WHERE city = "Mountain_View"; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### How many stations are in Mountain View?
SELECT COUNT(*) FROM station WHERE city = "Mountain_View"; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Which start station had the most trips starting from August? Give me the name and id of the station.
SELECT start_station_name,start_station_id FROM trip WHERE start_date LIKE "8/%" GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the start station's name and id for the one that had the most start trips in August?
SELECT start_station_name,start_station_id FROM trip WHERE start_date LIKE "8/%" GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Which bike traveled the most often in zip code 94002?
SELECT bike_id FROM trip WHERE zip_code = 94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the id of the bike that traveled the most in 94002?
SELECT bike_id FROM trip WHERE zip_code = 94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### How many days had both mean humidity above 50 and mean visibility above 8?
SELECT COUNT(*) FROM weather WHERE mean_humidity > 50 AND mean_visibility_miles > 8; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the number of days that had an average humity above 50 and an average visibility above 8?
SELECT COUNT(*) FROM weather WHERE mean_humidity > 50 AND mean_visibility_miles > 8; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids of stations that are located in San Francisco and have average bike availability above 10.
SELECT id FROM station WHERE city = "San_Francisco" INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available) > 10; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids of the stations in San Francisco that normally have more than 10 bikes available?
SELECT id FROM station WHERE city = "San_Francisco" INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available) > 10; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the 3 most common cloud cover rates in the region of zip code 94107?
SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the 3 most common cloud covers in the zip code of 94107?
SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the zip code in which the average mean sea level pressure is the lowest?
SELECT zip_code FROM weather GROUP BY zip_code ORDER BY avg(mean_sea_level_pressure_inches) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the zip code that has the lowest average mean sea level pressure?
SELECT zip_code FROM weather GROUP BY zip_code ORDER BY avg(mean_sea_level_pressure_inches) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the average bike availability in stations that are not located in Palo Alto?
SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city = "Palo_Alto"); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the average bike availablility for stations not in Palo Alto?
SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city = "Palo_Alto"); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the average longitude of stations that never had bike availability more than 10?
SELECT avg(long) FROM station WHERE id NOT IN (SELECT station_id FROM status GROUP BY station_id HAVING max(bikes_available) > 10); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the mean longitude for all stations that have never had more than 10 bikes available?
SELECT avg(long) FROM station WHERE id NOT IN (SELECT station_id FROM status GROUP BY station_id HAVING max(bikes_available) > 10); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### When and in what zip code did max temperature reach 80?
SELECT date,zip_code FROM weather WHERE max_temperature_f >= 80; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What zip codes have a station with a max temperature greater than or equal to 80 and when did it reach that temperature?
SELECT date,zip_code FROM weather WHERE max_temperature_f >= 80; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each zip code, return how many times max wind speed reached 25?
SELECT zip_code,count(*) FROM weather WHERE max_wind_Speed_mph >= 25 GROUP BY zip_code; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each zip code, how many times has the maximum wind speed reached 25 mph?
SELECT zip_code,count(*) FROM weather WHERE max_wind_Speed_mph >= 25 GROUP BY zip_code; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### On which day and in which zip code was the min dew point lower than any day in zip code 94107?
SELECT date,zip_code FROM weather WHERE min_dew_point_f < (SELECT min(min_dew_point_f) FROM weather WHERE zip_code = 94107); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Which days had a minimum dew point smaller than any day in zip code 94107, and in which zip codes were those measurements taken?
SELECT date,zip_code FROM weather WHERE min_dew_point_f < (SELECT min(min_dew_point_f) FROM weather WHERE zip_code = 94107); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### In zip code 94107, on which day neither Fog nor Rain was not observed?
SELECT date FROM weather WHERE zip_code = 94107 AND EVENTS != "Fog" AND EVENTS != "Rain"; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### On which day has it neither been foggy nor rained in the zip code of 94107?
SELECT date FROM weather WHERE zip_code = 94107 AND EVENTS != "Fog" AND EVENTS != "Rain"; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids of stations that have latitude above 37.4 and never had bike availability below 7?
SELECT id FROM station WHERE lat > 37.4 EXCEPT SELECT station_id FROM status GROUP BY station_id HAVING min(bikes_available) < 7; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids of all stations that have a latitude above 37.4 and have never had less than 7 bikes available?
SELECT id FROM station WHERE lat > 37.4 EXCEPT SELECT station_id FROM status GROUP BY station_id HAVING min(bikes_available) < 7; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the name, latitude, and city of the station with the lowest latitude?
SELECT name,lat,city FROM station ORDER BY lat LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the name, latitude, and city of the station that is located the furthest South?
SELECT name,lat,city FROM station ORDER BY lat LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the date, mean temperature and mean humidity for the top 3 days with the largest max gust speeds?
SELECT date,mean_temperature_f,mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the date, average temperature and mean humidity for the days with the 3 largest maximum gust speeds?
SELECT date,mean_temperature_f,mean_humidity FROM weather ORDER BY max_gust_speed_mph DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### List the name and the number of stations for all the cities that have at least 15 stations.
SELECT city,COUNT(*) FROM station GROUP BY city HAVING COUNT(*) >= 15; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What is the name of every city that has at least 15 stations and how many stations does it have?
SELECT city,COUNT(*) FROM station GROUP BY city HAVING COUNT(*) >= 15; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Find the ids and names of stations from which at least 200 trips started.
SELECT start_station_id,start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*) >= 200; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids and names of all start stations that were the beginning of at least 200 trips?
SELECT start_station_id,start_station_name FROM trip GROUP BY start_station_name HAVING COUNT(*) >= 200; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Find the zip code in which the average mean visibility is lower than 10.
SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_visibility_miles) < 10; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each zip code, select all those that have an average mean visiblity below 10.
SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_visibility_miles) < 10; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### List all the cities in a decreasing order of each city's stations' highest latitude.
SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### For each city, list their names in decreasing order by their highest station latitude.
SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the dates that had the top 5 cloud cover rates? Also tell me the cloud cover rate.
SELECT date,cloud_cover FROM weather ORDER BY cloud_cover DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the dates that have the 5 highest cloud cover rates and what are the rates?
SELECT date,cloud_cover FROM weather ORDER BY cloud_cover DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids and durations of the trips with the top 3 durations?
SELECT id,duration FROM trip ORDER BY duration DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids of the trips that lasted the longest and how long did they last?
SELECT id,duration FROM trip ORDER BY duration DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### List all the distinct stations from which a trip of duration below 100 started.
SELECT DISTINCT start_station_name FROM trip WHERE duration < 100; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are all the different start station names for a trip that lasted less than 100?
SELECT DISTINCT start_station_name FROM trip WHERE duration < 100; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Find all the zip codes in which the max dew point have never reached 70.
SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are all the different zip codes that have a maximum dew point that was always below 70?
SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Find the id for the trips that lasted at least as long as the average duration of trips in zip code 94103.
SELECT id FROM trip WHERE duration >= (SELECT avg(duration) FROM trip WHERE zip_code = 94103); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the ids of all trips that had a duration as long as the average trip duration in the zip code 94103?
SELECT id FROM trip WHERE duration >= (SELECT avg(duration) FROM trip WHERE zip_code = 94103); ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the dates in which the mean sea level pressure was between 30.3 and 31?
SELECT date FROM weather WHERE mean_sea_level_pressure_inches BETWEEN 30.3 AND 31; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the dates that have an average sea level pressure between 30.3 and 31?
SELECT date FROM weather WHERE mean_sea_level_pressure_inches BETWEEN 30.3 AND 31; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Find the day in which the difference between the max temperature and min temperature was the smallest. Also report the difference.
SELECT date,max_temperature_f - min_temperature_f FROM weather ORDER BY max_temperature_f - min_temperature_f LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the days that had the smallest temperature range, and what was that range?
SELECT date,max_temperature_f - min_temperature_f FROM weather ORDER BY max_temperature_f - min_temperature_f LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.
SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity) < 70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*) >= 100; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?
SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity) < 70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*) >= 100; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the names of stations that are located in Palo Alto city but have never been the ending point of trips more than 100 times?
SELECT name FROM station WHERE city = "Palo_Alto" EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*) > 100; ###
###Postgre SQL tables, with their properties:
# station: ["id", "name", "latitude", "longitude", "dock_count", "city", "installation_date"]
# status: ["station_id", "bikes_available", "docks_available", "time"]
# trip: ["id", "duration", "start_date", "start_station_name", "start_station_id", "end_date", "end_station_name", "end_station_id", "bike_id", "subscription_type", "zip_code"]
# weather: ["date", "max_temperature_f", "mean_temperature_f", "min_temperature_f", "max_dew_point_f", "mean_dew_point_f", "min_dew_point_f", "max_humidity", "mean_humidity", "min_humidity", "max_sea_level_pressure_inches", "mean_sea_level_pressure_inches", "min_sea_level_pressure_inches", "max_visibility_miles", "mean_visibility_miles", "min_visibility_miles", "max_wind_speed_mph", "mean_wind_speed_mph", "max_gust_speed_mph", "precipitation_inches", "cloud_cover", "events", "wind_dir_degrees", "zip_code"]
### What are the names of the stations that are located in Palo Alto but have never been the ending point of the trips
SELECT name FROM station WHERE city = "Palo_Alto" EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*) > 100; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### How many books are there?
SELECT count(*) FROM book; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### List the writers of the books in ascending alphabetical order.
SELECT Writer FROM book ORDER BY Writer ASC; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### List the titles of the books in ascending order of issues.
SELECT Title FROM book ORDER BY Issues ASC; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### What are the titles of the books whose writer is not "Elaine_Lee"?
SELECT Title FROM book WHERE Writer != "Elaine_Lee"; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### What are the title and issues of the books?
SELECT Title,Issues FROM book; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### What are the dates of publications in descending order of price?
SELECT Publication_Date FROM publication ORDER BY Price DESC; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### What are the distinct publishers of publications with price higher than 5000000?
SELECT DISTINCT Publisher FROM publication WHERE Price > 5000000; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### List the publisher of the publication with the highest price.
SELECT Publisher FROM publication ORDER BY Price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### List the publication dates of publications with 3 lowest prices.
SELECT Publication_Date FROM publication ORDER BY Price ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### Show publishers that have more than one publication.
SELECT Publisher FROM publication GROUP BY Publisher HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### Show different publishers together with the number of publications they have.
SELECT Publisher,COUNT(*) FROM publication GROUP BY Publisher; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### Please show the most common publication date.
SELECT Publication_Date FROM publication GROUP BY Publication_Date ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### List the writers who have written more than one book.
SELECT Writer FROM book GROUP BY Writer HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### List the titles of books that are not published.
SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication); ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### Show the publishers that have publications with price higher than 10000000 and publications with price lower than 5000000.
SELECT Publisher FROM publication WHERE Price > 10000000 INTERSECT SELECT Publisher FROM publication WHERE Price < 5000000; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### What is the number of distinct publication dates?
SELECT COUNT (DISTINCT Publication_Date) FROM publication; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### How many distinct publication dates are there in our record?
SELECT COUNT (DISTINCT Publication_Date) FROM publication; ###
###Postgre SQL tables, with their properties:
# publication: ["publication_id", "book_id", "publisher", "publication_date", "price"]
# book: ["book_id", "title", "issues", "writer"]
### Show the prices of publications whose publisher is either "Person" or "Wiley"
SELECT Price FROM publication WHERE Publisher = "Person" OR Publisher = "Wiley"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### How many actors are there?
SELECT count(*) FROM actor; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Count the number of actors.
SELECT count(*) FROM actor; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### List the name of actors in ascending alphabetical order.
SELECT Name FROM actor ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What are the names of actors, ordered alphabetically?
SELECT Name FROM actor ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What are the characters and duration of actors?
SELECT Character,Duration FROM actor; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Return the characters and durations for each actor.
SELECT Character,Duration FROM actor; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### List the name of actors whose age is not 20.
SELECT Name FROM actor WHERE Age != 20; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What are the names of actors who are not 20 years old?
SELECT Name FROM actor WHERE Age != 20; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What are the characters of actors in descending order of age?
SELECT Character FROM actor ORDER BY age DESC; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Return the characters for actors, ordered by age descending.
SELECT Character FROM actor ORDER BY age DESC; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What is the duration of the oldest actor?
SELECT Duration FROM actor ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Return the duration of the actor with the greatest age.
SELECT Duration FROM actor ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What are the names of musicals with nominee "Bob_Fosse"?
SELECT Name FROM musical WHERE Nominee = "Bob_Fosse"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Return the names of musicals who have the nominee Bob Fosse.
SELECT Name FROM musical WHERE Nominee = "Bob_Fosse"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What are the distinct nominees of the musicals with the award that is not "Tony_Award"?
SELECT DISTINCT Nominee FROM musical WHERE Award != "Tony_Award"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Return the different nominees of musicals that have an award that is not the Tony Award.
SELECT DISTINCT Nominee FROM musical WHERE Award != "Tony_Award"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Show different nominees and the number of musicals they have been nominated.
SELECT Nominee,COUNT(*) FROM musical GROUP BY Nominee; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### How many musicals has each nominee been nominated for?
SELECT Nominee,COUNT(*) FROM musical GROUP BY Nominee; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Please show the nominee who has been nominated the greatest number of times.
SELECT Nominee FROM musical GROUP BY Nominee ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Who is the nominee who has been nominated for the most musicals?
SELECT Nominee FROM musical GROUP BY Nominee ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### List the most common result of the musicals.
SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Return the most frequent result across all musicals.
SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### List the nominees that have been nominated more than two musicals.
SELECT Nominee FROM musical GROUP BY Nominee HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Who are the nominees who have been nominated more than two times?
SELECT Nominee FROM musical GROUP BY Nominee HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### List the name of musicals that do not have actors.
SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor); ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### What are the names of musicals who have no actors?
SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor); ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Show the nominees that have nominated musicals for both "Tony_Award" and "Drama_Desk_Award".
SELECT Nominee FROM musical WHERE Award = "Tony_Award" INTERSECT SELECT Nominee FROM musical WHERE Award = "Drama_Desk_Award"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Who are the nominees who have been nominated for both a Tony Award and a Drama Desk Award?
SELECT Nominee FROM musical WHERE Award = "Tony_Award" INTERSECT SELECT Nominee FROM musical WHERE Award = "Drama_Desk_Award"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Show the musical nominee with award "Bob_Fosse" or "Cleavant_Derricks".
SELECT Nominee FROM musical WHERE Award = "Tony_Award" OR Award = "Cleavant_Derricks"; ###
###Postgre SQL tables, with their properties:
# musical: ["musical_id", "name", "year", "award", "category", "nominee", "result"]
# actor: ["actor_id", "name", "musical_id", "character", "duration", "age"]
### Who are the nominees who were nominated for either of the Bob Fosse or Cleavant Derricks awards?
SELECT Nominee FROM musical WHERE Award = "Tony_Award" OR Award = "Cleavant_Derricks"; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the emails of the user named "Mary".
SELECT email FROM user_profiles WHERE name = 'Mary'; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### What is the partition id of the user named "Iron_Man".
SELECT partitionid FROM user_profiles WHERE name = 'Iron Man'; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### How many users are there?
SELECT count(*) FROM user_profiles; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### How many followers does each user have?
SELECT count(*) FROM follows; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the number of followers for each user.
SELECT count(*) FROM follows GROUP BY f1; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the number of tweets in record.
SELECT count(*) FROM tweets; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the number of users who posted some tweets.
SELECT count(DISTINCT UID) FROM tweets; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the name and email of the user whose name contains the word ‘Swift’.
SELECT name,email FROM user_profiles WHERE name LIKE '%Swift%'; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the names of users whose emails contain ‘superstar’ or ‘edu’.
SELECT name FROM user_profiles WHERE email LIKE '%superstar%' OR email LIKE '%edu%'; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Return the text of tweets about the topic 'intern'.
SELECT text FROM tweets WHERE text LIKE '%intern%'; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the name and email of the users who have more than 1000 followers.
SELECT name,email FROM user_profiles WHERE followers > 1000; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the name of the user who has the largest number of followers.
SELECT name FROM user_profiles ORDER BY followers DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the name and email of the user followed by the least number of people.
SELECT name,email FROM user_profiles ORDER BY followers LIMIT 1; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### List the name and number of followers for each user, and sort the results by the number of followers in descending order.
SELECT name,followers FROM user_profiles ORDER BY followers DESC; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### List the names of 5 users followed by the largest number of other users.
SELECT name FROM user_profiles ORDER BY followers DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### List the text of all tweets in the order of date.
SELECT text FROM tweets ORDER BY createdate; ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the average number of followers for the users who do not have any tweet.
SELECT avg(followers) FROM user_profiles WHERE UID NOT IN (SELECT UID FROM tweets); ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the average number of followers for the users who had some tweets.
SELECT avg(followers) FROM user_profiles WHERE UID IN (SELECT UID FROM tweets); ###
###Postgre SQL tables, with their properties:
# follows: ["user_id", "follower_id"]
# tweets: ["id", "user_id", "text", "create_date"]
# user_profiles: ["uid", "name", "email", "partition_id", "followers"]
### Find the maximum and total number of followers of all users.
SELECT max(followers),sum(followers) FROM user_profiles; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the names of all the catalog entries.
SELECT distinct(catalog_entry_name) FROM catalog_contents; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What are all the catalog entry names?
SELECT distinct(catalog_entry_name) FROM catalog_contents; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the list of attribute data types possessed by more than 3 attribute definitions.
SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What are the attribute data types with more than 3 attribute definitions?
SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What is the attribute data type of the attribute with name "Green"?
SELECT attribute_data_type FROM Attribute_Definitions WHERE attribute_name = "Green"; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the attribute data type for the attribute named "Green".
SELECT attribute_data_type FROM Attribute_Definitions WHERE attribute_name = "Green"; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the name and level of catalog structure with level between 5 and 10.
SELECT catalog_level_name,catalog_level_number FROM Catalog_Structure WHERE catalog_level_number BETWEEN 5 AND 10; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What are the name and level of catalog structure with level number between 5 and 10
SELECT catalog_level_name,catalog_level_number FROM Catalog_Structure WHERE catalog_level_number BETWEEN 5 AND 10; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find all the catalog publishers whose name contains "Murray"
SELECT distinct(catalog_publisher) FROM catalogs WHERE catalog_publisher LIKE "%Murray%"; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Which catalog publishers have substring "Murray" in their names?
SELECT distinct(catalog_publisher) FROM catalogs WHERE catalog_publisher LIKE "%Murray%"; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Which catalog publisher has published the most catalogs?
SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the catalog publisher that has the most catalogs.
SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What is the entry name of the most expensive catalog (in USD)?
SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the entry name of the catalog with the highest price (in USD).
SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What are the average and minimum price (in Euro) of all products?
SELECT avg(price_in_euros),min(price_in_euros) FROM catalog_contents; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Give me the average and minimum price (in Euro) of the products.
SELECT avg(price_in_euros),min(price_in_euros) FROM catalog_contents; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What is the product with the highest height? Give me the catalog entry name.
SELECT catalog_entry_name FROM catalog_contents ORDER BY height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Which catalog content has the highest height? Give me the catalog entry name.
SELECT catalog_entry_name FROM catalog_contents ORDER BY height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the name of the product that has the smallest capacity.
SELECT catalog_entry_name FROM catalog_contents ORDER BY capacity ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Which catalog content has the smallest capacity? Return the catalog entry name.
SELECT catalog_entry_name FROM catalog_contents ORDER BY capacity ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the names of all the products whose stock number starts with "2".
SELECT catalog_entry_name FROM catalog_contents WHERE product_stock_number LIKE "2%"; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Which catalog contents have a product stock number that starts from "2"? Show the catalog entry names.
SELECT catalog_entry_name FROM catalog_contents WHERE product_stock_number LIKE "2%"; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the names of the products with length smaller than 3 or height greater than 5.
SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH < 3 OR width > 5; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Which catalog contents have length below 3 or above 5? Find the catalog entry names.
SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH < 3 OR width > 5; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the name and capacity of products with price greater than 700 (in USD).
SELECT catalog_entry_name,capacity FROM Catalog_Contents WHERE price_in_dollars > 700; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Which catalog contents has price above 700 dollars? Show their catalog entry names and capacities.
SELECT catalog_entry_name,capacity FROM Catalog_Contents WHERE price_in_dollars > 700; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the dates on which more than one revisions were made.
SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### On which days more than one revisions were made on catalogs.
SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### How many products are there in the records?
SELECT count(*) FROM catalog_contents; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Find the total number of catalog contents.
SELECT count(*) FROM catalog_contents; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### Name all the products with next entry ID greater than 8.
SELECT catalog_entry_name FROM catalog_contents WHERE next_entry_id > 8; ###
###Postgre SQL tables, with their properties:
# attribute_definitions: ["attribute_id", "attribute_name", "attribute_data_type"]
# catalogs: ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"]
# catalog_structure: ["catalog_level_number", "catalog_id", "catalog_level_name"]
# catalog_contents: ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"]
# catalog_contents_additional_attributes: ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]
### What are the catalog entry names of the products with next entry ID above 8?
SELECT catalog_entry_name FROM catalog_contents WHERE next_entry_id > 8; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### How many aircrafts do we have?
SELECT count(*) FROM Aircraft; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### How many aircrafts exist in the database?
SELECT count(*) FROM Aircraft; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show name and distance for all aircrafts.
SELECT name,distance FROM Aircraft; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the names and distances for all airplanes?
SELECT name,distance FROM Aircraft; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show ids for all aircrafts with more than 1000 distance.
SELECT aid FROM Aircraft WHERE distance > 1000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the ids of all aircrafts that can cover a distance of more than 1000?
SELECT aid FROM Aircraft WHERE distance > 1000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### How many aircrafts have distance between 1000 and 5000?
SELECT count(*) FROM Aircraft WHERE distance BETWEEN 1000 AND 5000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the count of aircrafts that have a distance between 1000 and 5000?
SELECT count(*) FROM Aircraft WHERE distance BETWEEN 1000 AND 5000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the name and distance for aircraft with id 12?
SELECT name,distance FROM Aircraft WHERE aid = 12; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the name and distance for the aircraft that has an id of 12?
SELECT name,distance FROM Aircraft WHERE aid = 12; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the minimum, average, and maximum distance of all aircrafts.
SELECT min(distance),avg(distance),max(distance) FROM Aircraft; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Return the minimum, average and maximum distances traveled across all aircrafts.
SELECT min(distance),avg(distance),max(distance) FROM Aircraft; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show the id and name of the aircraft with the maximum distance.
SELECT aid,name FROM Aircraft ORDER BY distance DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the id and name of the aircraft that can cover the maximum distance?
SELECT aid,name FROM Aircraft ORDER BY distance DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show the name of aircrafts with top three lowest distances.
SELECT name FROM Aircraft ORDER BY distance LIMIT 3; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the aircrafts with top 3 shortest lengthes? List their names.
SELECT name FROM Aircraft ORDER BY distance LIMIT 3; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show names for all aircrafts with distances more than the average.
SELECT name FROM Aircraft WHERE distance > (SELECT avg(distance) FROM Aircraft); ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the names of all aircrafts that can cover more distances than average?
SELECT name FROM Aircraft WHERE distance > (SELECT avg(distance) FROM Aircraft); ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### How many employees do we have?
SELECT count(*) FROM Employee; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the number of employees?
SELECT count(*) FROM Employee; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show name and salary for all employees sorted by salary.
SELECT name,salary FROM Employee ORDER BY salary; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the name and salary of all employees in order of salary?
SELECT name,salary FROM Employee ORDER BY salary; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show ids for all employees with at least 100000 salary.
SELECT eid FROM Employee WHERE salary > 100000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the id of every employee who has at least a salary of 100000?
SELECT eid FROM Employee WHERE salary > 100000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### How many employees have salary between 100000 and 200000?
SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the number of employees that have a salary between 100000 and 200000?
SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the name and salary for employee with id 242518965?
SELECT name,salary FROM Employee WHERE eid = 242518965; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the name and salary of the employee with the id 242518965?
SELECT name,salary FROM Employee WHERE eid = 242518965; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is average and maximum salary of all employees.
SELECT avg(salary),max(salary) FROM Employee; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the average and largest salary of all employees?
SELECT avg(salary),max(salary) FROM Employee; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show the id and name of the employee with maximum salary.
SELECT eid,name FROM Employee ORDER BY salary DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the id and name of the employee with the highest salary?
SELECT eid,name FROM Employee ORDER BY salary DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show the name of employees with three lowest salaries.
SELECT name FROM Employee ORDER BY salary ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the name of the 3 employees who get paid the least?
SELECT name FROM Employee ORDER BY salary ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show names for all employees with salary more than the average.
SELECT name FROM Employee WHERE salary > (SELECT avg(salary) FROM Employee); ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the names of all employees who have a salary higher than average?
SELECT name FROM Employee WHERE salary > (SELECT avg(salary) FROM Employee); ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show the id and salary of Mark Young.
SELECT eid,salary FROM Employee WHERE name = 'Mark Young'; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the id and salary of the employee named Mark Young?
SELECT eid,salary FROM Employee WHERE name = 'Mark Young'; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### How many flights do we have?
SELECT count(*) FROM Flight; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the number of flights?
SELECT count(*) FROM Flight; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show flight number, origin, destination of all flights in the alphabetical order of the departure cities.
SELECT flno,origin,destination FROM Flight ORDER BY origin; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the flight number, origin, and destination for all flights in alphabetical order by departure cities?
SELECT flno,origin,destination FROM Flight ORDER BY origin; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show all flight number from Los Angeles.
SELECT flno FROM Flight WHERE origin = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the numbers of all flights coming from Los Angeles?
SELECT flno FROM Flight WHERE origin = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show origins of all flights with destination Honolulu.
SELECT origin FROM Flight WHERE destination = "Honolulu"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the origins of all flights that are headed to Honolulu?
SELECT origin FROM Flight WHERE destination = "Honolulu"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show me the departure date and arrival date for all flights from Los Angeles to Honolulu.
SELECT departure_date,arrival_date FROM Flight WHERE origin = "Los_Angeles" AND destination = "Honolulu"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the departure and arrival dates of all flights from LA to Honolulu?
SELECT departure_date,arrival_date FROM Flight WHERE origin = "Los_Angeles" AND destination = "Honolulu"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show flight number for all flights with more than 2000 distance.
SELECT flno FROM Flight WHERE distance > 2000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the numbers of all flights that can cover a distance of more than 2000?
SELECT flno FROM Flight WHERE distance > 2000; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the average price for flights from Los Angeles to Honolulu.
SELECT avg(price) FROM Flight WHERE origin = "Los_Angeles" AND destination = "Honolulu"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the average price for flights from LA to Honolulu?
SELECT avg(price) FROM Flight WHERE origin = "Los_Angeles" AND destination = "Honolulu"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show origin and destination for flights with price higher than 300.
SELECT origin,destination FROM Flight WHERE price > 300; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the origin and destination for all flights whose price is higher than 300?
SELECT origin,destination FROM Flight WHERE price > 300; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show the flight number and distance of the flight with maximum price.
SELECT flno,distance FROM Flight ORDER BY price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the flight number and its distance for the one with the maximum price?
SELECT flno,distance FROM Flight ORDER BY price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show the flight number of flights with three lowest distances.
SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the numbers of the shortest flights?
SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the average distance and average price for flights from Los Angeles.
SELECT avg(distance),avg(price) FROM Flight WHERE origin = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the average distance and price for all flights from LA?
SELECT avg(distance),avg(price) FROM Flight WHERE origin = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show all origins and the number of flights from each origin.
SELECT origin,count(*) FROM Flight GROUP BY origin; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### For each origin, how many flights came from there?
SELECT origin,count(*) FROM Flight GROUP BY origin; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show all destinations and the number of flights to each destination.
SELECT destination,count(*) FROM Flight GROUP BY destination; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the destinations and number of flights to each one?
SELECT destination,count(*) FROM Flight GROUP BY destination; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Which origin has most number of flights?
SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What place has the most flights coming from there?
SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Which destination has least number of flights?
SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What destination has the fewest number of flights?
SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### How many employees have certificate.
SELECT count(DISTINCT eid) FROM Certificate; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What is the count of distinct employees with certificates?
SELECT count(DISTINCT eid) FROM Certificate; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### Show ids for all employees who don't have a certificate.
SELECT eid FROM Employee EXCEPT SELECT eid FROM Certificate; ###
###Postgre SQL tables, with their properties:
# flight: ["flight_number", "origin", "destination", "distance", "departure_date", "arrival_date", "price", "airline_id"]
# aircraft: ["airline_id", "name", "distance"]
# employee: ["employee_id", "name", "salary"]
# certificate: ["employee_id", "airline_id"]
### What are the ids of all employees that don't have certificates?
SELECT eid FROM Employee EXCEPT SELECT eid FROM Certificate; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many allergies are there?
SELECT count(DISTINCT allergy) FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many allergy entries are there?
SELECT count(DISTINCT allergy) FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many different allergy types exist?
SELECT count(DISTINCT allergytype) FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many distinct allergies are there?
SELECT count(DISTINCT allergytype) FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all allergy types.
SELECT DISTINCT allergytype FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the different allergy types?
SELECT DISTINCT allergytype FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all allergies and their types.
SELECT allergy,allergytype FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the allergies and their types?
SELECT allergy,allergytype FROM Allergy_type; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all allergies with type food.
SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype = "food"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are all the different food allergies?
SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype = "food"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What is the type of allergy Cat?
SELECT allergytype FROM Allergy_type WHERE allergy = "Cat"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What is allergy type of a cat allergy?
SELECT allergytype FROM Allergy_type WHERE allergy = "Cat"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many allergies have type animal?
SELECT count(*) FROM Allergy_type WHERE allergytype = "animal"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many animal type allergies exist?
SELECT count(*) FROM Allergy_type WHERE allergytype = "animal"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all allergy types and the number of allergies in each type.
SELECT allergytype,count(*) FROM Allergy_type GROUP BY allergytype; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the allergy types and how many allergies correspond to each one?
SELECT allergytype,count(*) FROM Allergy_type GROUP BY allergytype; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which allergy type has most number of allergies?
SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which allergy type is most common?
SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which allergy type has least number of allergies?
SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which allergy type is the least common?
SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students are there?
SELECT count(*) FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What is the total number of students?
SELECT count(*) FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show first name and last name for all students.
SELECT Fname,Lname FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the full names of all students
SELECT Fname,Lname FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many different advisors are listed?
SELECT count(DISTINCT advisor) FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many advisors are there?
SELECT count(DISTINCT advisor) FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all majors.
SELECT DISTINCT Major FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the different majors?
SELECT DISTINCT Major FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all cities where students live.
SELECT DISTINCT city_code FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What cities do students live in?
SELECT DISTINCT city_code FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show first name, last name, age for all female students. Their sex is F.
SELECT Fname,Lname,Age FROM Student WHERE Sex = 'F'; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the full names and ages for all female students whose sex is F?
SELECT Fname,Lname,Age FROM Student WHERE Sex = 'F'; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show student ids for all male students.
SELECT StuID FROM Student WHERE Sex = 'M'; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the student ids for all male students?
SELECT StuID FROM Student WHERE Sex = 'M'; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students are age 18?
SELECT count(*) FROM Student WHERE age = 18; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students are 18 years old?
SELECT count(*) FROM Student WHERE age = 18; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all student ids who are older than 20.
SELECT StuID FROM Student WHERE age > 20; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the student ids for students over 20 years old?
SELECT StuID FROM Student WHERE age > 20; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which city does the student whose last name is "Kim" live in?
SELECT city_code FROM Student WHERE LName = "Kim"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Give the city that the student whose family name is Kim lives in.
SELECT city_code FROM Student WHERE LName = "Kim"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Who is the advisor of student with ID 1004?
SELECT Advisor FROM Student WHERE StuID = 1004; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Who advises student 1004?
SELECT Advisor FROM Student WHERE StuID = 1004; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students live in HKG or CHI?
SELECT count(*) FROM Student WHERE city_code = "HKG" OR city_code = "CHI"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Give the number of students living in either HKG or CHI.
SELECT count(*) FROM Student WHERE city_code = "HKG" OR city_code = "CHI"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show the minimum, average, and maximum age of all students.
SELECT min(age),avg(age),max(age) FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What is the minimum, mean, and maximum age across all students?
SELECT min(age),avg(age),max(age) FROM Student; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What is the last name of the youngest student?
SELECT LName FROM Student WHERE age = (SELECT min(age) FROM Student); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Provide the last name of the youngest student.
SELECT LName FROM Student WHERE age = (SELECT min(age) FROM Student); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show the student id of the oldest student.
SELECT StuID FROM Student WHERE age = (SELECT max(age) FROM Student); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What student id corresponds to the oldest student?
SELECT StuID FROM Student WHERE age = (SELECT max(age) FROM Student); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all majors and corresponding number of students.
SELECT major,count(*) FROM Student GROUP BY major; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students are there for each major?
SELECT major,count(*) FROM Student GROUP BY major; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which major has most number of students?
SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What is the largest major?
SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all ages and corresponding number of students.
SELECT age,count(*) FROM Student GROUP BY age; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How old is each student and how many students are each age?
SELECT age,count(*) FROM Student GROUP BY age; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show the average age for male and female students.
SELECT avg(age),sex FROM Student GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the average ages for male and female students?
SELECT avg(age),sex FROM Student GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all cities and corresponding number of students.
SELECT city_code,count(*) FROM Student GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students live in each city?
SELECT city_code,count(*) FROM Student GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all advisors and corresponding number of students.
SELECT advisor,count(*) FROM Student GROUP BY advisor; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students does each advisor have?
SELECT advisor,count(*) FROM Student GROUP BY advisor; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which advisor has most number of students?
SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Give the advisor with the most students.
SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students have cat allergies?
SELECT count(*) FROM Has_allergy WHERE Allergy = "Cat"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students are affected by cat allergies?
SELECT count(*) FROM Has_allergy WHERE Allergy = "Cat"; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all student IDs who have at least two allergies.
SELECT StuID FROM Has_allergy GROUP BY StuID HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the students ids of students who have more than one allergy?
SELECT StuID FROM Has_allergy GROUP BY StuID HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the student ids of students who don't have any allergies?
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which students are unaffected by allergies?
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which allergy has most number of students affected?
SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Which allergy is the most common?
SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Show all allergies with number of students affected.
SELECT Allergy,count(*) FROM Has_allergy GROUP BY Allergy; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### How many students have each different allergy?
SELECT Allergy,count(*) FROM Has_allergy GROUP BY Allergy; ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Find the last name and age of the student who has allergy to both milk and cat.
SELECT lname,age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy = "Milk" INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy = "Cat"); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the last names and ages of the students who are allergic to milk and cat?
SELECT lname,age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy = "Milk" INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy = "Cat"); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Find the first name and gender of the student who has allergy to milk but not cat.
SELECT fname,sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy = "Milk" EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy = "Cat"); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the first name and gender of the students who have allergy to milk but can put up with cats?
SELECT fname,sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy = "Milk" EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy = "Cat"); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### Find the first name and major of the students who are not allegry to soy.
SELECT fname,major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy = "Soy"); ###
###Postgre SQL tables, with their properties:
# allergy_type: ["allergy_name", "allergy_type"]
# has_allergy: ["stuid", "allergy"]
# student: ["stuid", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
### What are the first name and major of the students who are able to consume soy?
SELECT fname,major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy = "Soy"); ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### A list of the top 5 countries by number of invoices. List country name and number of invoices.
SELECT billing_country,COUNT(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the top 5 countries by number of invoices and how many do they have?
SELECT billing_country,COUNT(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### A list of the top 8 countries by gross/total invoice size. List country name and gross invoice size.
SELECT billing_country,SUM(total) FROM invoices GROUP BY billing_country ORDER BY SUM(total) DESC LIMIT 8;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the names of the top 8 countries by total invoice size and what are those sizes?
SELECT billing_country,SUM(total) FROM invoices GROUP BY billing_country ORDER BY SUM(total) DESC LIMIT 8;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### A list of the top 10 countries by average invoice size. List country name and average invoice size.
SELECT billing_country,AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the names of the countries and average invoice size of the top countries by size?
SELECT billing_country,AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List every album's title.
SELECT title FROM albums;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the titles of all the albums?
SELECT title FROM albums;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List every album ordered by album title in ascending order.
SELECT title FROM albums ORDER BY title;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the titles of all the albums alphabetically ascending?
SELECT title FROM albums ORDER BY title;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List every album whose title starts with A in alphabetical order.
SELECT title FROM albums WHERE title LIKE 'A%' ORDER BY title;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the titles of all albums that start with A in alphabetical order?
SELECT title FROM albums WHERE title LIKE 'A%' ORDER BY title;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List total amount of invoice from Chicago, IL.
SELECT sum(total) FROM invoices WHERE billing_city = "Chicago" AND billing_state = "IL";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the total amount of money in the invoices billed from Chicago, Illinois?
SELECT sum(total) FROM invoices WHERE billing_city = "Chicago" AND billing_state = "IL";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List the number of invoices from Chicago, IL.
SELECT COUNT(*) FROM invoices WHERE billing_city = "Chicago" AND billing_state = "IL";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many invoices were billed from Chicago, IL?
SELECT COUNT(*) FROM invoices WHERE billing_city = "Chicago" AND billing_state = "IL";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List the number of invoices from the US, grouped by state.
SELECT billing_state,COUNT(*) FROM invoices WHERE billing_country = "USA" GROUP BY billing_state;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many invoices were billed from each state?
SELECT billing_state,COUNT(*) FROM invoices WHERE billing_country = "USA" GROUP BY billing_state;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List the state in the US with the most invoices.
SELECT billing_state,COUNT(*) FROM invoices WHERE billing_country = "USA" GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the states with the most invoices?
SELECT billing_state,COUNT(*) FROM invoices WHERE billing_country = "USA" GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List the number of invoices and the invoice total from California.
SELECT billing_state,COUNT(*),SUM(total) FROM invoices WHERE billing_state = "CA";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the number of invoices and total money billed in them from CA?
SELECT billing_state,COUNT(*),SUM(total) FROM invoices WHERE billing_state = "CA";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### Eduardo Martins is a customer at which company?
SELECT company FROM customers WHERE first_name = "Eduardo" AND last_name = "Martins";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the company where Eduardo Martins is a customer?
SELECT company FROM customers WHERE first_name = "Eduardo" AND last_name = "Martins";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is Astrid Gruber's email and phone number?
SELECT email,phone FROM customers WHERE first_name = "Astrid" AND last_name = "Gruber";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the email and phone number of Astrid Gruber the customer?
SELECT email,phone FROM customers WHERE first_name = "Astrid" AND last_name = "Gruber";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many customers live in Prague city?
SELECT count(*) FROM customers WHERE city = "Prague";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many customers live in the city of Prague?
SELECT count(*) FROM customers WHERE city = "Prague";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many customers in state of CA?
SELECT count(*) FROM customers WHERE state = "CA";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many customers are from California?
SELECT count(*) FROM customers WHERE state = "CA";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What country does Roberto Almeida live?
SELECT country FROM customers WHERE first_name = "Roberto" AND last_name = "Almeida";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### In which country does Roberto Almeida?
SELECT country FROM customers WHERE first_name = "Roberto" AND last_name = "Almeida";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the title, phone and hire date of Nancy Edwards?
SELECT title,phone,hire_date FROM employees WHERE first_name = "Nancy" AND last_name = "Edwards";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the title, phone number and hire date for the employee named Nancy Edwards?
SELECT title,phone,hire_date FROM employees WHERE first_name = "Nancy" AND last_name = "Edwards";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the address of employee Nancy Edwards?
SELECT address FROM employees WHERE first_name = "Nancy" AND last_name = "Edwards";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is Nancy Edwards's address?
SELECT address FROM employees WHERE first_name = "Nancy" AND last_name = "Edwards";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many employees are living in Canada?
SELECT count(*) FROM employees WHERE country = "Canada";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many employees live in Canada?
SELECT count(*) FROM employees WHERE country = "Canada";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is employee Nancy Edwards's phone number?
SELECT phone FROM employees WHERE first_name = "Nancy" AND last_name = "Edwards";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the the phone number of Nancy Edwards?
SELECT phone FROM employees WHERE first_name = "Nancy" AND last_name = "Edwards";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### Who is the youngest employee in the company? List employee's first and last name.
SELECT first_name,last_name FROM employees ORDER BY birth_date DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What si the youngest employee's first and last name?
SELECT first_name,last_name FROM employees ORDER BY birth_date DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List top 10 employee work longest in the company. List employee's first and last name.
SELECT first_name,last_name FROM employees ORDER BY hire_date ASC LIMIT 10;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the first and last names of the top 10 longest-serving employees?
SELECT first_name,last_name FROM employees ORDER BY hire_date ASC LIMIT 10;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### Find the number of employees whose title is IT Staff from each city?
SELECT count(*),city FROM employees WHERE title = 'IT Staff' GROUP BY city; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many employees who are IT staff are from each city?
SELECT count(*),city FROM employees WHERE title = 'IT Staff' GROUP BY city; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List all media types.
SELECT name FROM media_types;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the names of all the media types?
SELECT name FROM media_types;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List all different genre types.
SELECT DISTINCT name FROM genres;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the different names of the genres?
SELECT DISTINCT name FROM genres;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### List the name of all playlist.
SELECT name FROM playlists;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What are the names of all the playlists?
SELECT name FROM playlists;; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### Who is the composer of track Fast As a Shark?
SELECT composer FROM tracks WHERE name = "Fast_As_a_Shark";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the composer who created the track "Fast_As_a_Shark"?
SELECT composer FROM tracks WHERE name = "Fast_As_a_Shark";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How long does track Fast As a Shark has?
SELECT milliseconds FROM tracks WHERE name = "Fast_As_a_Shark";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How many milliseconds long is Fast As a Shark?
SELECT milliseconds FROM tracks WHERE name = "Fast_As_a_Shark";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### How much is the track Fast As a Shark?
SELECT unit_price FROM tracks WHERE name = "Fast_As_a_Shark";; ###
###Postgre SQL tables, with their properties:
# sqlite_sequence: ["name", "seq"]
# artists: ["id", "name"]
# albums: ["id", "title", "artist_id"]
# employees: ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# customers: ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"]
# genres: ["id", "name"]
# invoices: ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# media_types: ["id", "name"]
# tracks: ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
# invoice_lines: ["id", "invoice_id", "track_id", "unit_price", "quantity"]
# playlists: ["id", "name"]
# playlist_tracks: ["playlist_id", "track_id"]
### What is the unit price of the tune "Fast_As_a_Shark"?
SELECT unit_price FROM tracks WHERE name = "Fast_As_a_Shark";; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### How many editors are there?
SELECT count(*) FROM editor; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### List the names of editors in ascending order of age.
SELECT Name FROM editor ORDER BY Age ASC; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### What are the names and ages of editors?
SELECT Name,Age FROM editor; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### List the names of editors who are older than 25.
SELECT Name FROM editor WHERE Age > 25; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### Show the names of editors of age either 24 or 25.
SELECT Name FROM editor WHERE Age = 24 OR Age = 25; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### What is the name of the youngest editor?
SELECT Name FROM editor ORDER BY Age ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### What are the different ages of editors? Show each age along with the number of editors of that age.
SELECT Age,COUNT(*) FROM editor GROUP BY Age; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### Please show the most common age of editors.
SELECT Age FROM editor GROUP BY Age ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### Show the distinct themes of journals.
SELECT DISTINCT Theme FROM journal; ###
###Postgre SQL tables, with their properties:
# journal: ["journal_id", "date", "theme", "sales"]
# editor: ["editor_id", "name", "age"]
# journal_committee: ["editor_id", "journal_id", "work_type"]
### List the names of editors that are not on any journal committee.
SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee); ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many accounts do we have?
SELECT count(*) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Count the number of accounts.
SELECT count(*) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show ids, customer ids, names for all accounts.
SELECT account_id,customer_id,account_name FROM Accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the account ids, customer ids, and account names for all the accounts?
SELECT account_id,customer_id,account_name FROM Accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show other account details for account with name 338.
SELECT other_account_details FROM Accounts WHERE account_name = "338"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the other account details for the account with the name 338?
SELECT other_account_details FROM Accounts WHERE account_name = "338"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show all customer ids and the number of accounts for each customer.
SELECT customer_id,count(*) FROM Accounts GROUP BY customer_id; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many accounts are there for each customer id?
SELECT customer_id,count(*) FROM Accounts GROUP BY customer_id; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the customer id and number of accounts with most accounts.
SELECT customer_id,count(*) FROM Accounts GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What is the customer id of the customer with the most accounts, and how many accounts does this person have?
SELECT customer_id,count(*) FROM Accounts GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the number of all customers without an account.
SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts); ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many customers do not have an account?
SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts); ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many customers have an account?
SELECT count(DISTINCT customer_id) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Count the number of customers who hold an account.
SELECT count(DISTINCT customer_id) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many customers do we have?
SELECT count(*) FROM Customers; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Count the number of customers.
SELECT count(*) FROM Customers; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show ids, first names, last names, and phones for all customers.
SELECT customer_id,customer_first_name,customer_last_name,customer_phone FROM Customers; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the ids, full names, and phones of each customer?
SELECT customer_id,customer_first_name,customer_last_name,customer_phone FROM Customers; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What is the phone and email for customer with first name Aniyah and last name Feest?
SELECT customer_phone,customer_email FROM Customers WHERE customer_first_name = "Aniyah" AND customer_last_name = "Feest"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Return the phone and email of the customer with the first name Aniyah and last name Feest.
SELECT customer_phone,customer_email FROM Customers WHERE customer_first_name = "Aniyah" AND customer_last_name = "Feest"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the number of customer cards.
SELECT count(*) FROM Customers_cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many customer cards are there?
SELECT count(*) FROM Customers_cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show ids, customer ids, card type codes, card numbers for all cards.
SELECT card_id,customer_id,card_type_code,card_number FROM Customers_cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are card ids, customer ids, card types, and card numbers for each customer card?
SELECT card_id,customer_id,card_type_code,card_number FROM Customers_cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the date valid from and the date valid to for the card with card number '4560596484842'.
SELECT date_valid_from,date_valid_to FROM Customers_cards WHERE card_number = "4560596484842"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the valid from and valid to dates for the card with the number 4560596484842?
SELECT date_valid_from,date_valid_to FROM Customers_cards WHERE card_number = "4560596484842"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many debit cards do we have?
SELECT count(*) FROM Customers_cards WHERE card_type_code = "Debit"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Count the number of customer cards of the type Debit.
SELECT count(*) FROM Customers_cards WHERE card_type_code = "Debit"; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show all customer ids and the number of cards owned by each customer.
SELECT customer_id,count(*) FROM Customers_cards GROUP BY customer_id; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the different customer ids, and how many cards does each one hold?
SELECT customer_id,count(*) FROM Customers_cards GROUP BY customer_id; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What is the customer id with most number of cards, and how many does he have?
SELECT customer_id,count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Return the id of the customer who has the most cards, as well as the number of cards.
SELECT customer_id,count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show all card type codes and the number of cards in each type.
SELECT card_type_code,count(*) FROM Customers_cards GROUP BY card_type_code; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the different card types, and how many cards are there of each?
SELECT card_type_code,count(*) FROM Customers_cards GROUP BY card_type_code; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What is the card type code with most number of cards?
SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Return the code of the card type that is most common.
SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show card type codes with at least 5 cards.
SELECT card_type_code FROM Customers_cards GROUP BY card_type_code HAVING count(*) >= 5; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the codes of card types that have 5 or more cards?
SELECT card_type_code FROM Customers_cards GROUP BY card_type_code HAVING count(*) >= 5; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show all card type codes and the number of customers holding cards in each type.
SELECT card_type_code,count(DISTINCT customer_id) FROM Customers_cards GROUP BY card_type_code; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the different card type codes, and how many different customers hold each type?
SELECT card_type_code,count(DISTINCT customer_id) FROM Customers_cards GROUP BY card_type_code; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show all card type codes.
SELECT DISTINCT card_type_code FROM Customers_Cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the different card type codes?
SELECT DISTINCT card_type_code FROM Customers_Cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the number of card types.
SELECT count(DISTINCT card_type_code) FROM Customers_Cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many different card types are there?
SELECT count(DISTINCT card_type_code) FROM Customers_Cards; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show all transaction types.
SELECT DISTINCT transaction_type FROM Financial_Transactions; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the different types of transactions?
SELECT DISTINCT transaction_type FROM Financial_Transactions; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the number of transaction types.
SELECT count(DISTINCT transaction_type) FROM Financial_Transactions; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### How many different types of transactions are there?
SELECT count(DISTINCT transaction_type) FROM Financial_Transactions; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What is the average and total transaction amount?
SELECT avg(transaction_amount),sum(transaction_amount) FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Return the average transaction amount, as well as the total amount of all transactions.
SELECT avg(transaction_amount),sum(transaction_amount) FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the transaction type and the number of transactions.
SELECT transaction_type,count(*) FROM Financial_transactions GROUP BY transaction_type; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the different transaction types, and how many transactions of each have taken place?
SELECT transaction_type,count(*) FROM Financial_transactions GROUP BY transaction_type; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What is the transaction type that has processed the greatest total amount in transactions?
SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Return the type of transaction with the highest total amount.
SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### Show the account id and the number of transactions for each account
SELECT account_id,count(*) FROM Financial_transactions GROUP BY account_id; ###
###Postgre SQL tables, with their properties:
# accounts: ["account_id", "customer_id", "account_name", "other_account_details"]
# customers: ["customer_id", "customer_first_name", "customer_last_name", "customer_address", "customer_phone", "customer_email", "other_customer_details"]
# customers_cards: ["card_id", "customer_id", "card_type_code", "card_number", "date_valid_from", "date_valid_to", "other_card_details"]
# financial_transactions: ["transaction_id", "previous_transaction_id", "account_id", "card_id", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
### What are the different account ids that have made financial transactions, as well as how many transactions correspond to each?
SELECT account_id,count(*) FROM Financial_transactions GROUP BY account_id; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### How many tracks do we have?
SELECT count(*) FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Count the number of tracks.
SELECT count(*) FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Show the name and location for all tracks.
SELECT name,LOCATION FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the names and locations of all tracks?
SELECT name,LOCATION FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Show names and seatings, ordered by seating for all tracks opened after 2000.
SELECT name,seating FROM track WHERE year_opened > 2000 ORDER BY seating; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the names and seatings for all tracks opened after 2000, ordered by seating?
SELECT name,seating FROM track WHERE year_opened > 2000 ORDER BY seating; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What is the name, location and seating for the most recently opened track?
SELECT name,LOCATION,seating FROM track ORDER BY year_opened DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Return the name, location, and seating of the track that was opened in the most recent year.
SELECT name,LOCATION,seating FROM track ORDER BY year_opened DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What is the minimum, maximum, and average seating for all tracks.
SELECT min(seating),max(seating),avg(seating) FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Return the minimum, maximum, and average seating across all tracks.
SELECT min(seating),max(seating),avg(seating) FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Show the name, location, open year for all tracks with a seating higher than the average.
SELECT name,LOCATION,year_opened FROM track WHERE seating > (SELECT avg(seating) FROM track); ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the names, locations, and years of opening for tracks with seating higher than average?
SELECT name,LOCATION,year_opened FROM track WHERE seating > (SELECT avg(seating) FROM track); ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are distinct locations where tracks are located?
SELECT DISTINCT LOCATION FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Give the different locations of tracks.
SELECT DISTINCT LOCATION FROM track; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### How many races are there?
SELECT count(*) FROM race; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Count the number of races.
SELECT count(*) FROM race; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the distinct classes that races can have?
SELECT DISTINCT CLASS FROM race; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Return the different classes of races.
SELECT DISTINCT CLASS FROM race; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Show name, class, and date for all races.
SELECT name,CLASS,date FROM race; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the names, classes, and dates for all races?
SELECT name,CLASS,date FROM race; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Show the race class and number of races in each class.
SELECT CLASS,count(*) FROM race GROUP BY CLASS; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the different classes of races, and how many races correspond to each?
SELECT CLASS,count(*) FROM race GROUP BY CLASS; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What is the race class with most number of races.
SELECT CLASS FROM race GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Give the class of races that is most common.
SELECT CLASS FROM race GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### List the race class with at least two races.
SELECT CLASS FROM race GROUP BY CLASS HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the classes of races that have two or more corresponding races?
SELECT CLASS FROM race GROUP BY CLASS HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Show all track names that have had no races.
SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race); ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Return the names of tracks that have no had any races.
SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race); ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Show year where a track with a seating at least 5000 opened and a track with seating no more than 4000 opened.
SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the years of opening for tracks with seating between 4000 and 5000?
SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### Find the locations where have both tracks with more than 90000 seats and tracks with less than 70000 seats.
SELECT LOCATION FROM track WHERE seating > 90000 INTERSECT SELECT LOCATION FROM track WHERE seating < 70000; ###
###Postgre SQL tables, with their properties:
# race: ["race_id", "name", "class", "date", "track_id"]
# track: ["track_id", "name", "location", "seating", "year_opened"]
### What are the locations that have both tracks with more than 90000 seats, and tracks with fewer than 70000 seats?
SELECT LOCATION FROM track WHERE seating > 90000 INTERSECT SELECT LOCATION FROM track WHERE seating < 70000; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### How many members have the black membership card?
SELECT count(*) FROM member WHERE Membership_card = 'Black'; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Find the number of members living in each address.
SELECT count(*),address FROM member GROUP BY address; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Give me the names of members whose address is in Harford or Waterbury.
SELECT name FROM member WHERE address = 'Harford' OR address = 'Waterbury'; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Find the ids and names of members who are under age 30 or with black membership card.
SELECT name,member_id FROM member WHERE Membership_card = 'Black' OR age < 30; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Find the purchase time, age and address of each member, and show the results in the order of purchase time.
SELECT Time_of_purchase,age,address FROM member ORDER BY Time_of_purchase; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Which membership card has more than 5 members?
SELECT Membership_card FROM member GROUP BY Membership_card HAVING count(*) > 5; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Which address has both members younger than 30 and members older than 40?
SELECT address FROM member WHERE age < 30 INTERSECT SELECT address FROM member WHERE age > 40; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### What is the membership card held by both members living in Hartford and ones living in Waterbury address?
SELECT membership_card FROM member WHERE address = 'Hartford' INTERSECT SELECT membership_card FROM member WHERE address = 'Waterbury'; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### How many members are not living in Hartford?
SELECT count(*) FROM member WHERE address != 'Hartford'; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Which address do not have any member with the black membership card?
SELECT address FROM member EXCEPT SELECT address FROM member WHERE Membership_card = 'Black'; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Show the shop addresses ordered by their opening year.
SELECT address FROM shop ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### What are the average score and average staff number of all shops?
SELECT avg(num_of_staff),avg(score) FROM shop; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Find the id and address of the shops whose score is below the average score.
SELECT shop_id,address FROM shop WHERE score < (SELECT avg(score) FROM shop); ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Find the address and staff number of the shops that do not have any happy hour.
SELECT address,num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour); ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### which shop has happy hour most frequently? List its id and number of happy hours.
SELECT shop_id,count(*) FROM happy_hour GROUP BY shop_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Which month has the most happy hours?
SELECT MONTH FROM happy_hour GROUP BY MONTH ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# shop: ["shop_id", "address", "num_of_staff", "score", "open_year"]
# member: ["member_id", "name", "membership_card", "age", "time_of_purchase", "level_of_membership", "address"]
# happy_hour: ["hh_id", "shop_id", "month", "num_of_shaff_in_charge"]
# happy_hour_member: ["hh_id", "member_id", "total_amount"]
### Which months have more than 2 happy hours?
SELECT MONTH FROM happy_hour GROUP BY MONTH HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### How many albums are there?
SELECT count(*) FROM ALBUM; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the number of albums.
SELECT count(*) FROM ALBUM; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### List the names of all music genres.
SELECT Name FROM GENRE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the names of different music genres?
SELECT Name FROM GENRE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find all the customer information in state NY.
SELECT * FROM CUSTOMER WHERE State = "NY"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What is all the customer information for customers in NY state?
SELECT * FROM CUSTOMER WHERE State = "NY"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the first names and last names of the employees who live in Calgary city.
SELECT FirstName,LastName FROM EMPLOYEE WHERE City = "Calgary"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the full names of employees living in the city of Calgary.
SELECT FirstName,LastName FROM EMPLOYEE WHERE City = "Calgary"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the distinct billing countries of the invoices?
SELECT distinct(BillingCountry) FROM INVOICE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the different billing countries for all invoices.
SELECT distinct(BillingCountry) FROM INVOICE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the names of all artists that have "a" in their names.
SELECT Name FROM ARTIST WHERE Name LIKE "%a%"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the names of artist who have the letter 'a' in their names?
SELECT Name FROM ARTIST WHERE Name LIKE "%a%"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the names of all the tracks that contain the word "you".
SELECT Name FROM TRACK WHERE Name LIKE '%you%'; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the names of tracks that contain the the word you in them?
SELECT Name FROM TRACK WHERE Name LIKE '%you%'; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What is the average unit price of all the tracks?
SELECT AVG(UnitPrice) FROM TRACK; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the average unit price for a track.
SELECT AVG(UnitPrice) FROM TRACK; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the durations of the longest and the shortest tracks in milliseconds?
SELECT max(Milliseconds),min(Milliseconds) FROM TRACK; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the maximum and minimum durations of tracks in milliseconds.
SELECT max(Milliseconds),min(Milliseconds) FROM TRACK; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What is the first name and last name of the customer that has email "luisg@embraer.com.br"?
SELECT FirstName,LastName FROM CUSTOMER WHERE Email = "luisg@embraer.com.br"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the full name of the customer with the email "luisg@embraer.com.br".
SELECT FirstName,LastName FROM CUSTOMER WHERE Email = "luisg@embraer.com.br"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### How many customers have email that contains "gmail.com"?
SELECT COUNT(*) FROM CUSTOMER WHERE Email LIKE "%gmail.com%"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Count the number of customers that have an email containing "gmail.com".
SELECT COUNT(*) FROM CUSTOMER WHERE Email LIKE "%gmail.com%"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### How many distinct cities does the employees live in?
SELECT COUNT(DISTINCT city) FROM EMPLOYEE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the number of different cities that employees live in.
SELECT COUNT(DISTINCT city) FROM EMPLOYEE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### List the phone numbers of all employees.
SELECT Phone FROM EMPLOYEE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the phone numbers for each employee?
SELECT Phone FROM EMPLOYEE; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Please list all album titles in alphabetical order.
SELECT Title FROM ALBUM ORDER BY Title; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are all the album titles, in alphabetical order?
SELECT Title FROM ALBUM ORDER BY Title; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the birth dates of employees living in Edmonton?
SELECT BirthDate FROM EMPLOYEE WHERE City = "Edmonton"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the birth dates corresponding to employees who live in the city of Edmonton.
SELECT BirthDate FROM EMPLOYEE WHERE City = "Edmonton"; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### What are the distinct unit prices of all tracks?
SELECT distinct(UnitPrice) FROM TRACK; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Find the distinct unit prices for tracks.
SELECT distinct(UnitPrice) FROM TRACK; ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### How many artists do not have any album?
SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM); ###
###Postgre SQL tables, with their properties:
# album: ["album_id", "title", "artist_id"]
# artist: ["artist_id", "name"]
# customer: ["customer_id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_representative_id"]
# employee: ["employee_id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"]
# genre: ["genre_id", "name"]
# invoice: ["invoice_id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"]
# invoice_line: ["invoice_line_id", "invoice_id", "track_id", "unit_price", "quantity"]
# media_type: ["media_type_id", "name"]
# playlist: ["play_list_id", "name"]
# playlist_track: ["play_list_id", "track_id"]
# track: ["track_id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"]
### Cound the number of artists who have not released an album.
SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Find all the phone numbers.
SELECT customer_phone FROM available_policies; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### What are all the phone numbers?
SELECT customer_phone FROM available_policies; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### What are the customer phone numbers under the policy "Life_Insurance"?
SELECT customer_phone FROM available_policies WHERE policy_type_code = "Life_Insurance"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### What are the phone numbers of customers using the policy with the code "Life_Insurance"?
SELECT customer_phone FROM available_policies WHERE policy_type_code = "Life_Insurance"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Which policy type has the most records in the database?
SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Which policy type appears most frequently in the available policies?
SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### What are all the customer phone numbers under the most popular policy type?
SELECT customer_phone FROM available_policies WHERE policy_type_code = (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Find the phone numbers of customers using the most common policy type among the available policies.
SELECT customer_phone FROM available_policies WHERE policy_type_code = (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Find the policy type used by more than 4 customers.
SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*) > 4; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Find the policy types more than 4 customers use. Show their type code.
SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*) > 4; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Find the total and average amount of settlements.
SELECT sum(settlement_amount),avg(settlement_amount) FROM settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Return the sum and average of all settlement amounts.
SELECT sum(settlement_amount),avg(settlement_amount) FROM settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### List all the services in the alphabetical order.
SELECT service_name FROM services ORDER BY service_name; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Give me a list of all the service names sorted alphabetically.
SELECT service_name FROM services ORDER BY service_name; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### How many services are there?
SELECT count(*) FROM services; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Count the total number of available services.
SELECT count(*) FROM services; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Find the IDs of customers whose name contains "Diana".
SELECT customer_id FROM customers WHERE customer_name LIKE "%Diana%"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### What are the IDs of customers who have "Diana" in part of their names?
SELECT customer_id FROM customers WHERE customer_name LIKE "%Diana%"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### What are the maximum and minimum settlement amount on record?
SELECT max(settlement_amount),min(settlement_amount) FROM settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### Find the maximum and minimum settlement amount.
SELECT max(settlement_amount),min(settlement_amount) FROM settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### List all the customers in increasing order of IDs.
SELECT customer_id,customer_name FROM customers ORDER BY customer_id ASC; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name"]
# services: ["service_id", "service_name"]
# available_policies: ["policy_id", "policy_type_code", "customer_phone"]
# customers_policies: ["customer_id", "policy_id", "date_opened", "date_closed"]
# first_notification_of_loss: ["fnol_id", "customer_id", "policy_id", "service_id"]
# claims: ["claim_id", "fnol_id", "effective_date"]
# settlements: ["settlement_id", "claim_id", "effective_date", "settlement_amount"]
### What is the ordered list of customer ids?
SELECT customer_id,customer_name FROM customers ORDER BY customer_id ASC; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### How many kinds of enzymes are there?
SELECT count(*) FROM enzyme; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What is the total count of enzymes?
SELECT count(*) FROM enzyme; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### List the name of enzymes in descending lexicographical order.
SELECT name FROM enzyme ORDER BY name DESC; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the names of enzymes in descending order?
SELECT name FROM enzyme ORDER BY name DESC; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### List the names and the locations that the enzymes can make an effect.
SELECT name,LOCATION FROM enzyme; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the names and locations of all enzymes listed?
SELECT name,LOCATION FROM enzyme; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What is the maximum Online Mendelian Inheritance in Man (OMIM) value of the enzymes?
SELECT max(OMIM) FROM enzyme; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What is the maximum OMIM value in the database?
SELECT max(OMIM) FROM enzyme; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What is the product, chromosome and porphyria related to the enzymes which take effect at the location 'Cytosol'?
SELECT product,chromosome,porphyria FROM enzyme WHERE LOCATION = 'Cytosol'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What is the product, chromosome, and porphyria of the enzymes located at 'Cytosol'?
SELECT product,chromosome,porphyria FROM enzyme WHERE LOCATION = 'Cytosol'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the names of enzymes who does not produce 'Heme'?
SELECT name FROM enzyme WHERE product != 'Heme'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the names of enzymes whose product is not 'Heme'?
SELECT name FROM enzyme WHERE product != 'Heme'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the names and trade names of the medicines which has 'Yes' value in the FDA record?
SELECT name,trade_name FROM medicine WHERE FDA_approved = 'Yes'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the names and trade names of the medcines that are FDA approved?
SELECT name,trade_name FROM medicine WHERE FDA_approved = 'Yes'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What is the most common interaction type between enzymes and medicine? And how many are there?
SELECT interaction_type,count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the most common types of interactions between enzymes and medicine, and how many types are there?
SELECT interaction_type,count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### How many medicines have the FDA approval status 'No'?
SELECT count(*) FROM medicine WHERE FDA_approved = 'No'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### How many medicines were not approved by the FDA?
SELECT count(*) FROM medicine WHERE FDA_approved = 'No'; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### How many enzymes do not have any interactions?
SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What is the count of enzymes without any interactions?
SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### How many distinct FDA approval statuses are there for the medicines?
SELECT count(DISTINCT FDA_approved) FROM medicine; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### How many different FDA approval statuses exist for medicines?
SELECT count(DISTINCT FDA_approved) FROM medicine; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### Which enzyme names have the substring "ALA"?
SELECT name FROM enzyme WHERE name LIKE "%ALA%"; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### What are the names of enzymes that include the string 'ALA'?
SELECT name FROM enzyme WHERE name LIKE "%ALA%"; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### find the number of medicines offered by each trade.
SELECT trade_name,count(*) FROM medicine GROUP BY trade_name; ###
###Postgre SQL tables, with their properties:
# medicine: ["id", "name", "trade_name", "fda_approved"]
# enzyme: ["id", "name", "location", "product", "chromosome", "omim", "porphyria"]
# medicine_enzyme_interaction: ["enzyme_id", "medicine_id", "interaction_type"]
### How many medicines are offered by each trade name?
SELECT trade_name,count(*) FROM medicine GROUP BY trade_name; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### List all schools and their nicknames in the order of founded year.
SELECT school,nickname FROM university ORDER BY founded; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the different schools and their nicknames, ordered by their founding years?
SELECT school,nickname FROM university ORDER BY founded; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### List all public schools and their locations.
SELECT school,LOCATION FROM university WHERE affiliation = 'Public'; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the public schools and what are their locations?
SELECT school,LOCATION FROM university WHERE affiliation = 'Public'; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### When was the school with the largest enrollment founded?
SELECT founded FROM university ORDER BY enrollment DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Return the founded year for the school with the largest enrollment.
SELECT founded FROM university ORDER BY enrollment DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Find the founded year of the newest non public school.
SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What is the founded year of the non public school that was founded most recently?
SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### How many schools are in the basketball match?
SELECT count(DISTINCT school_id) FROM basketball_match; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Count the number of schools that have had basketball matches.
SELECT count(DISTINCT school_id) FROM basketball_match; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What is the highest acc percent score in the competition?
SELECT acc_percent FROM basketball_match ORDER BY acc_percent DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Return the highest acc percent across all basketball matches.
SELECT acc_percent FROM basketball_match ORDER BY acc_percent DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the average enrollment size of the universities that are founded before 1850?
SELECT avg(enrollment) FROM university WHERE founded < 1850; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Return the average enrollment of universities founded before 1850.
SELECT avg(enrollment) FROM university WHERE founded < 1850; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Show the enrollment and primary_conference of the oldest college.
SELECT enrollment,primary_conference FROM university ORDER BY founded LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the enrollment and primary conference for the university which was founded the earliest?
SELECT enrollment,primary_conference FROM university ORDER BY founded LIMIT 1; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What is the total and minimum enrollment of all schools?
SELECT sum(enrollment),min(enrollment) FROM university; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Return the total and minimum enrollments across all schools.
SELECT sum(enrollment),min(enrollment) FROM university; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Find the total student enrollment for different affiliation type schools.
SELECT sum(enrollment),affiliation FROM university GROUP BY affiliation; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the total enrollments of universities of each affiliation type?
SELECT sum(enrollment),affiliation FROM university GROUP BY affiliation; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### How many schools do not participate in the basketball match?
SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match); ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Count the number of universities that do not participate in the baketball match.
SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match); ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Find the schools that were either founded after 1850 or public.
SELECT school FROM university WHERE founded > 1850 OR affiliation = 'Public'; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the schools that were either founded before 1850 or are public?
SELECT school FROM university WHERE founded > 1850 OR affiliation = 'Public'; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Find how many different affiliation types there are.
SELECT count(DISTINCT affiliation) FROM university; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Count the number of different affiliation types.
SELECT count(DISTINCT affiliation) FROM university; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Find how many school locations have the word 'NY'.
SELECT count(*) FROM university WHERE LOCATION LIKE "%NY%"; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### How many universities have a location that contains NY?
SELECT count(*) FROM university WHERE LOCATION LIKE "%NY%"; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Find the number of universities that have over a 20000 enrollment size for each affiliation type.
SELECT count(*),affiliation FROM university WHERE enrollment > 20000 GROUP BY affiliation; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the different affiliations, and how many schools with each have an enrollment size of above 20000?
SELECT count(*),affiliation FROM university WHERE enrollment > 20000 GROUP BY affiliation; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Find the total number of students enrolled in the colleges that were founded after the year of 1850 for each affiliation type.
SELECT sum(Enrollment),affiliation FROM university WHERE founded > 1850 GROUP BY affiliation; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the different affiliations, and what is the total enrollment of schools founded after 1850 for each enrollment type?
SELECT sum(Enrollment),affiliation FROM university WHERE founded > 1850 GROUP BY affiliation; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What is the maximum enrollment across all schools?
SELECT max(Enrollment) FROM university; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### Return the maximum enrollment across all schools.
SELECT max(Enrollment) FROM university; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### List all information regarding the basketball match.
SELECT * FROM basketball_match; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What is all the information about the basketball match?
SELECT * FROM basketball_match; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### List names of all teams in the basketball competition, ordered by all home scores in descending order.
SELECT team_name FROM basketball_match ORDER BY All_Home DESC; ###
###Postgre SQL tables, with their properties:
# basketball_match: ["team_id", "school_id", "team_name", "acc_regular_season", "acc_percent", "acc_home", "acc_road", "all_games", "all_games_percent", "all_home", "all_road", "all_neutral"]
# university: ["school_id", "school", "location", "founded", "affiliation", "enrollment", "nickname", "primary_conference"]
### What are the names of all the teams in the basketball competition, sorted by all home scores in descending order?
SELECT team_name FROM basketball_match ORDER BY All_Home DESC; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### the names of models that launched between 2002 and 2004.
SELECT Model_name FROM chip_model WHERE Launch_year BETWEEN 2002 AND 2004;; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Which model has the least amount of RAM? List the model name and the amount of RAM.
SELECT Model_name,RAM_MiB FROM chip_model ORDER BY RAM_MiB ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### What are the chip model and screen mode of the phone with hardware model name "LG-P760"?
SELECT chip_model,screen_mode FROM phone WHERE Hardware_Model_name = "LG-P760";; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### How many phone hardware models are produced by the company named "Nokia_Corporation"?
SELECT count(*) FROM phone WHERE Company_name = "Nokia_Corporation";; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Find all phones that have word 'Full' in their accreditation types. List the Hardware Model name and Company name.
SELECT Hardware_Model_name,Company_name FROM phone WHERE Accreditation_type LIKE 'Full';; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Find the name of the company that has the least number of phone models. List the company name and the number of phone model produced by that company.
SELECT Company_name,count(*) FROM phone GROUP BY Company_name ORDER BY count(*) ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### List the name of the company that produced more than one phone model.
SELECT Company_name FROM phone GROUP BY Company_name HAVING count(*) > 1;; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### List the maximum, minimum and average number of used kb in screen mode.
SELECT max(used_kb),min(used_kb),avg(used_kb) FROM screen_mode;; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Find the number of phones for each accreditation type.
SELECT Accreditation_type,count(*) FROM phone GROUP BY Accreditation_type; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### How many phones belongs to each accreditation type?
SELECT Accreditation_type,count(*) FROM phone GROUP BY Accreditation_type; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Find the accreditation level that more than 3 phones use.
SELECT Accreditation_level FROM phone GROUP BY Accreditation_level HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Find the details for all chip models.
SELECT * FROM chip_model; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### How many models do not have the wifi function?
SELECT count(*) FROM chip_model WHERE wifi = 'No'; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Count the number of chip model that do not have wifi.
SELECT count(*) FROM chip_model WHERE wifi = 'No'; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### List all the model names sorted by their launch year.
SELECT model_name FROM chip_model ORDER BY launch_year; ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Find the average ram mib size of the chip models that are never used by any phone.
SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone); ###
###Postgre SQL tables, with their properties:
# chip_model: ["model_name", "launch_year", "ram_mib", "rom_mib", "slots", "wifi", "bluetooth"]
# screen_mode: ["graphics_mode", "char_cells", "pixels", "hardware_colours", "used_kb", "map", "type"]
# phone: ["company_name", "hardware_model_name", "accreditation_type", "accreditation_level", "date", "chip_model", "screen_mode"]
### Find the names of the chip models that are not used by any phone with full accreditation type.
SELECT model_name FROM chip_model EXCEPT SELECT chip_model FROM phone WHERE Accreditation_type = 'Full'; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### How many countries are there in total?
SELECT count(*) FROM country; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Count the number of countries.
SELECT count(*) FROM country; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the country name and capital of all countries.
SELECT Country_name,Capital FROM country; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the names and capitals of each country?
SELECT Country_name,Capital FROM country; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show all official native languages that contain the word "English".
SELECT Official_native_language FROM country WHERE Official_native_language LIKE "%English%"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the official native languages that contain the string "English".
SELECT Official_native_language FROM country WHERE Official_native_language LIKE "%English%"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show all distinct positions of matches.
SELECT DISTINCT POSITION FROM match_season; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the different positions for match season?
SELECT DISTINCT POSITION FROM match_season; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the players from college UCLA.
SELECT Player FROM match_season WHERE College = "UCLA"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Who are the players from UCLA?
SELECT Player FROM match_season WHERE College = "UCLA"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the distinct position of players from college UCLA or Duke.
SELECT DISTINCT POSITION FROM match_season WHERE College = "UCLA" OR College = "Duke"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the different positions of players from UCLA or Duke colleges?
SELECT DISTINCT POSITION FROM match_season WHERE College = "UCLA" OR College = "Duke"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the draft pick numbers and draft classes of players whose positions are defenders.
SELECT Draft_Pick_Number,Draft_Class FROM match_season WHERE POSITION = "Defender"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the draft pick numbers and draft classes for players who play the Defender position?
SELECT Draft_Pick_Number,Draft_Class FROM match_season WHERE POSITION = "Defender"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### How many distinct teams are involved in match seasons?
SELECT count(DISTINCT Team) FROM match_season; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Count the number of different teams involved in match season.
SELECT count(DISTINCT Team) FROM match_season; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the players and the years played.
SELECT Player,Years_Played FROM player; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Who are the different players and how many years has each played?
SELECT Player,Years_Played FROM player; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show all team names.
SELECT Name FROM Team; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the names of all teams?
SELECT Name FROM Team; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the position of players and the corresponding number of players.
SELECT POSITION,COUNT(*) FROM match_season GROUP BY POSITION; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### How many players played each position?
SELECT POSITION,COUNT(*) FROM match_season GROUP BY POSITION; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Return all players sorted by college in ascending alphabetical order.
SELECT player FROM match_season ORDER BY College ASC; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are all the players who played in match season, sorted by college in ascending alphabetical order?
SELECT player FROM match_season ORDER BY College ASC; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the most common position of players in match seasons.
SELECT POSITION FROM match_season GROUP BY POSITION ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What is the position that is most common among players in match seasons?
SELECT POSITION FROM match_season GROUP BY POSITION ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the top 3 most common colleges of players in match seasons.
SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the three colleges from which the most players are from?
SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the name of colleges that have at least two players.
SELECT College FROM match_season GROUP BY College HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the names of all colleges that have two or more players?
SELECT College FROM match_season GROUP BY College HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Show the name of colleges that have at least two players in descending alphabetical order.
SELECT College FROM match_season GROUP BY College HAVING count(*) >= 2 ORDER BY College DESC; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the names of colleges that have two or more players, listed in descending alphabetical order?
SELECT College FROM match_season GROUP BY College HAVING count(*) >= 2 ORDER BY College DESC; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### What are the names of teams that do no have match season record?
SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season); ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Return the names of teams that have no match season record.
SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season); ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Which college have both players with position midfielder and players with position defender?
SELECT College FROM match_season WHERE POSITION = "Midfielder" INTERSECT SELECT College FROM match_season WHERE POSITION = "Defender"; ###
###Postgre SQL tables, with their properties:
# country: ["country_id", "country_name", "capital", "official_native_language"]
# team: ["team_id", "name"]
# match_season: ["season", "player", "position", "country", "team", "draft_pick_number", "draft_class", "college"]
# player: ["player_id", "player", "years_played", "total_wl", "singles_wl", "doubles_wl", "team"]
### Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.
SELECT College FROM match_season WHERE POSITION = "Midfielder" INTERSECT SELECT College FROM match_season WHERE POSITION = "Defender"; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### How many climbers are there?
SELECT count(*) FROM climber; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Count the number of climbers.
SELECT count(*) FROM climber; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### List the names of climbers in descending order of points.
SELECT Name FROM climber ORDER BY Points DESC; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the names of the climbers, ordered by points descending?
SELECT Name FROM climber ORDER BY Points DESC; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### List the names of climbers whose country is not Switzerland.
SELECT Name FROM climber WHERE Country != "Switzerland"; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the names of climbers who are not from the country of Switzerland?
SELECT Name FROM climber WHERE Country != "Switzerland"; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What is the maximum point for climbers whose country is United Kingdom?
SELECT max(Points) FROM climber WHERE Country = "United_Kingdom"; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Return the maximum number of points for climbers from the United Kingdom.
SELECT max(Points) FROM climber WHERE Country = "United_Kingdom"; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### How many distinct countries are the climbers from?
SELECT COUNT(DISTINCT Country) FROM climber; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Count the number of different countries that climbers are from.
SELECT COUNT(DISTINCT Country) FROM climber; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the names of mountains in ascending alphabetical order?
SELECT Name FROM mountain ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Give the names of mountains in alphabetical order.
SELECT Name FROM mountain ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the countries of mountains with height bigger than 5000?
SELECT Country FROM mountain WHERE Height > 5000; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Return the countries of the mountains that have a height larger than 5000.
SELECT Country FROM mountain WHERE Height > 5000; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What is the name of the highest mountain?
SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Return the name of the mountain with the greatest height.
SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### List the distinct ranges of the mountains with the top 3 prominence.
SELECT DISTINCT Range FROM mountain ORDER BY Prominence DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the different ranges of the 3 mountains with the highest prominence?
SELECT DISTINCT Range FROM mountain ORDER BY Prominence DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Please show the countries and the number of climbers from each country.
SELECT Country,COUNT(*) FROM climber GROUP BY Country; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### How many climbers are from each country?
SELECT Country,COUNT(*) FROM climber GROUP BY Country; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### List the countries that have more than one mountain.
SELECT Country FROM mountain GROUP BY Country HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Which countries have more than one mountain?
SELECT Country FROM mountain GROUP BY Country HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### List the names of mountains that do not have any climber.
SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber); ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the names of countains that no climber has climbed?
SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber); ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Show the countries that have mountains with height more than 5600 stories and mountains with height less than 5200.
SELECT Country FROM mountain WHERE Height > 5600 INTERSECT SELECT Country FROM mountain WHERE Height < 5200; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the countries that have both mountains that are higher than 5600 and lower than 5200?
SELECT Country FROM mountain WHERE Height > 5600 INTERSECT SELECT Country FROM mountain WHERE Height < 5200; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Show the range that has the most number of mountains.
SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Which range contains the most mountains?
SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### Show the names of mountains with height more than 5000 or prominence more than 1000.
SELECT Name FROM mountain WHERE Height > 5000 OR Prominence > 1000; ###
###Postgre SQL tables, with their properties:
# mountain: ["mountain_id", "name", "height", "prominence", "range", "country"]
# climber: ["climber_id", "name", "country", "time", "points", "mountain_id"]
### What are the names of mountains that have a height of over 5000 or a prominence of over 1000?
SELECT Name FROM mountain WHERE Height > 5000 OR Prominence > 1000; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### How many body builders are there?
SELECT count(*) FROM body_builder; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### List the total scores of body builders in ascending order.
SELECT Total FROM body_builder ORDER BY Total ASC; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### List the snatch score and clean jerk score of body builders in ascending order of snatch score.
SELECT Snatch,Clean_Jerk FROM body_builder ORDER BY Snatch ASC; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### What is the average snatch score of body builders?
SELECT avg(Snatch) FROM body_builder; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### What are the clean and jerk score of the body builder with the highest total score?
SELECT Clean_Jerk FROM body_builder ORDER BY Total DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### What are the birthdays of people in ascending order of height?
SELECT Birth_Date FROM People ORDER BY Height ASC; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### List each birth place along with the number of people from there.
SELECT Birth_Place,COUNT(*) FROM people GROUP BY Birth_Place; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### What is the most common birth place of people?
SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### What are the birth places that are shared by at least two people?
SELECT Birth_Place FROM people GROUP BY Birth_Place HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### List the height and weight of people in descending order of height.
SELECT Height,Weight FROM people ORDER BY Height DESC; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### Show all information about each body builder.
SELECT * FROM body_builder; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### How many distinct birth places are there?
SELECT count(DISTINCT Birth_Place) FROM people; ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### How many persons are not body builders?
SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder); ###
###Postgre SQL tables, with their properties:
# body_builder: ["body_builder_id", "people_id", "snatch", "clean_jerk", "total"]
# people: ["people_id", "name", "height", "weight", "birth_date", "birth_place"]
### What is the minimum snatch score?
SELECT min(snatch) FROM body_builder; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### How many elections are there?
SELECT count(*) FROM election; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### List the votes of elections in descending order.
SELECT Votes FROM election ORDER BY Votes DESC; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### List the dates and vote percents of elections.
SELECT Date,Vote_Percent FROM election; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What are the minimum and maximum vote percents of elections?
SELECT min(Vote_Percent),max(Vote_Percent) FROM election; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What are the names and parties of representatives?
SELECT Name,Party FROM representative; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What are the names of representatives whose party is not "Republican"?
SELECT Name FROM Representative WHERE Party != "Republican"; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What are the life spans of representatives from New York state or Indiana state?
SELECT Lifespan FROM representative WHERE State = "New_York" OR State = "Indiana"; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What are the different parties of representative? Show the party name and the number of representatives in each party.
SELECT Party,COUNT(*) FROM representative GROUP BY Party; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What is the party that has the largest number of representatives?
SELECT Party,COUNT(*) FROM representative GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What parties have at least three representatives?
SELECT Party FROM representative GROUP BY Party HAVING COUNT(*) >= 3; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### What states have at least two representatives?
SELECT State FROM representative GROUP BY State HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### List the names of representatives that have not participated in elections listed here.
SELECT Name FROM representative WHERE Representative_ID NOT IN (SELECT Representative_ID FROM election); ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### Show the parties that have both representatives in New York state and representatives in Pennsylvania state.
SELECT Party FROM representative WHERE State = "New_York" INTERSECT SELECT Party FROM representative WHERE State = "Pennsylvania"; ###
###Postgre SQL tables, with their properties:
# election: ["election_id", "representative_id", "date", "votes", "vote_percent", "seats", "place"]
# representative: ["representative_id", "name", "state", "party", "lifespan"]
### How many distinct parties are there for representatives?
SELECT count(DISTINCT Party) FROM representative; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### How many apartment bookings are there in total?
SELECT count(*) FROM Apartment_Bookings; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Count the total number of apartment bookings.
SELECT count(*) FROM Apartment_Bookings; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the start dates and end dates of all the apartment bookings.
SELECT booking_start_date,booking_end_date FROM Apartment_Bookings; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What are the start date and end date of each apartment booking?
SELECT booking_start_date,booking_end_date FROM Apartment_Bookings; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show all distinct building descriptions.
SELECT DISTINCT building_description FROM Apartment_Buildings; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Give me a list of all the distinct building descriptions.
SELECT DISTINCT building_description FROM Apartment_Buildings; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the short names of the buildings managed by "Emma".
SELECT building_short_name FROM Apartment_Buildings WHERE building_manager	 = "Emma"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Which buildings does "Emma" manage? Give me the short names of the buildings.
SELECT building_short_name FROM Apartment_Buildings WHERE building_manager	 = "Emma"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the addresses and phones of all the buildings managed by "Brenden".
SELECT building_address,building_phone FROM Apartment_Buildings WHERE building_manager	 = "Brenden"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What are the address and phone number of the buildings managed by "Brenden"?
SELECT building_address,building_phone FROM Apartment_Buildings WHERE building_manager	 = "Brenden"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What are the building full names that contain the word "court"?
SELECT building_full_name FROM Apartment_Buildings WHERE building_full_name LIKE "%court%"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Find all the building full names containing the word "court".
SELECT building_full_name FROM Apartment_Buildings WHERE building_full_name LIKE "%court%"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What is the minimum and maximum number of bathrooms of all the apartments?
SELECT min(bathroom_count),max(bathroom_count) FROM Apartments; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Give me the minimum and maximum bathroom count among all the apartments.
SELECT min(bathroom_count),max(bathroom_count) FROM Apartments; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What is the average number of bedrooms of all apartments?
SELECT avg(bedroom_count) FROM Apartments; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Find the average number of bedrooms of all the apartments.
SELECT avg(bedroom_count) FROM Apartments; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return the apartment number and the number of rooms for each apartment.
SELECT apt_number,room_count FROM Apartments; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What are the apartment number and the room count of each apartment?
SELECT apt_number,room_count FROM Apartments; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What is the average number of rooms of apartments with type code "Studio"?
SELECT avg(room_count) FROM Apartments WHERE apt_type_code = "Studio"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Find the average room count of the apartments that have the "Studio" type code.
SELECT avg(room_count) FROM Apartments WHERE apt_type_code = "Studio"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return the apartment numbers of the apartments with type code "Flat".
SELECT apt_number FROM Apartments WHERE apt_type_code = "Flat"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Which apartments have type code "Flat"? Give me their apartment numbers.
SELECT apt_number FROM Apartments WHERE apt_type_code = "Flat"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return the first names and last names of all guests
SELECT guest_first_name,guest_last_name FROM Guests; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What are the first names and last names of all the guests?
SELECT guest_first_name,guest_last_name FROM Guests; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return the date of birth for all the guests with gender code "Male".
SELECT date_of_birth FROM Guests WHERE gender_code = "Male"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What are dates of birth of all the guests whose gender is "Male"?
SELECT date_of_birth FROM Guests WHERE gender_code = "Male"; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the booking status code and the corresponding number of bookings.
SELECT 	booking_status_code,COUNT(*) FROM Apartment_Bookings GROUP BY booking_status_code; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### How many bookings does each booking status have? List the booking status code and the number of corresponding bookings.
SELECT 	booking_status_code,COUNT(*) FROM Apartment_Bookings GROUP BY booking_status_code; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return all the apartment numbers sorted by the room count in ascending order.
SELECT apt_number FROM Apartments ORDER BY room_count ASC; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Sort the apartment numbers in ascending order of room count.
SELECT apt_number FROM Apartments ORDER BY room_count ASC; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return the apartment number with the largest number of bedrooms.
SELECT apt_number FROM Apartments ORDER BY bedroom_count DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What is the apartment number of the apartment with the most beds?
SELECT apt_number FROM Apartments ORDER BY bedroom_count DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the apartment type codes and the corresponding number of apartments sorted by the number of apartments in ascending order.
SELECT apt_type_code,COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return each apartment type code with the number of apartments having that apartment type, in ascending order of the number of apartments.
SELECT apt_type_code,COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the top 3 apartment type codes sorted by the average number of rooms in descending order.
SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### What are the top three apartment types in terms of the average room count? Give me the
SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.
SELECT apt_type_code,bathroom_count,bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Which apartment type has the largest number of total rooms? Return the apartment type code, its number of bathrooms and number of bedrooms.
SELECT apt_type_code,bathroom_count,bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the most common apartment type code.
SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Which apartment type code appears the most often?
SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show the most common apartment type code among apartments with more than 1 bathroom.
SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Which apartment type code is the most common among apartments with more than one bathroom?
SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show each apartment type code, and the maximum and minimum number of rooms for each type.
SELECT apt_type_code,max(room_count),min(room_count) FROM Apartments GROUP BY apt_type_code; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Return each apartment type code along with the maximum and minimum number of rooms among each type.
SELECT apt_type_code,max(room_count),min(room_count) FROM Apartments GROUP BY apt_type_code; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Show each gender code and the corresponding count of guests sorted by the count in descending order.
SELECT gender_code,COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Sort the gender codes in descending order of their corresponding number of guests. Return both the gender codes and counts.
SELECT gender_code,COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### How many apartments do not have any facility?
SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities); ###
###Postgre SQL tables, with their properties:
# apartment_buildings: ["building_id", "building_short_name", "building_full_name", "building_description", "building_address", "building_manager", "building_phone"]
# apartments: ["apartment_id", "building_id", "apartment_type_code", "apartment_number", "bathroom_count", "bedroom_count", "room_count"]
# apartment_facilities: ["apartment_id", "facility_code"]
# guests: ["guest_id", "gender_code", "guest_first_name", "guest_last_name", "date_of_birth"]
# apartment_bookings: ["apartment_booking_id", "apartment_id", "guest_id", "booking_status_code", "booking_start_date", "booking_end_date"]
# view_unit_status: ["apartment_id", "apartment_booking_id", "status_date", "available_yes_or_no"]
### Find the number of apartments that have no facility.
SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities); ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### How many games are held after season 2007?
SELECT count(*) FROM game WHERE season > 2007; ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### List the dates of games by the home team name in descending order.
SELECT Date FROM game ORDER BY home_team DESC; ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### List the season, home team, away team of all the games.
SELECT season,home_team,away_team FROM game; ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### What are the maximum, minimum and average home games each stadium held?
SELECT max(home_games),min(home_games),avg(home_games) FROM stadium; ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### What is the average attendance of stadiums with capacity percentage higher than 100%?
SELECT average_attendance FROM stadium WHERE capacity_percentage > 100; ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### What are the player name, number of matches, and information source for players who do not suffer from injury of 'Knee problem'?
SELECT player,number_of_matches,SOURCE FROM injury_accident WHERE injury != 'Knee problem'; ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### How many different kinds of information sources are there for injury accidents?
SELECT count(DISTINCT SOURCE) FROM injury_accident; ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### How many games are free of injury accidents?
SELECT count(*) FROM game WHERE id NOT IN ( SELECT game_id FROM injury_accident ); ###
###Postgre SQL tables, with their properties:
# stadium: ["id", "name", "home_games", "average_attendance", "total_attendance", "capacity_percentage"]
# game: ["stadium_id", "id", "season", "date", "home_team", "away_team", "score", "competition"]
# injury_accident: ["game_id", "id", "player", "injury", "number_of_matches", "source"]
### Which stadium name contains the substring "Bank"?
SELECT name FROM stadium WHERE name LIKE "%Bank%"; ###
###Postgre SQL tables, with their properties:
# player_attributes: ["id", "player_fifa_api_id", "player_api_id", "date", "overall_rating", "potential", "preferred_foot", "attacking_work_rate", "defensive_work_rate", "crossing", "finishing", "heading_accuracy", "short_passing", "volleys", "dribbling", "curve", "free_kick_accuracy", "long_passing", "ball_control", "acceleration", "sprint_speed", "agility", "reactions", "balance", "shot_power", "jumping", "stamina", "strength", "long_shots", "aggression", "interceptions", "positioning", "vision", "penalties", "marking", "standing_tackle", "sliding_tackle", "gk_diving", "gk_handling", "gk_kicking", "gk_positioning", "gk_reflexes"]
# sqlite_sequence: ["name", "seq"]
# player: ["id", "player_api_id", "player_name", "player_fifa_api_id", "birthday", "height", "weight"]
# league: ["id", "country_id", "name"]
# country: ["id", "name"]
# team: ["id", "team_api_id", "team_fifa_api_id", "team_long_name", "team_short_name"]
# team_attributes: ["id", "team_fifa_api_id", "team_api_id", "date", "buildup_play_speed", "buildup_play_speed_class", "buildup_play_dribbling", "buildup_play_dribbling_class", "buildup_play_passing", "buildup_play_passing_class", "buildup_play_positioning_class", "chance_creation_passing", "chance_creation_passing_class", "chance_creation_crossing", "chance_creation_crossing_class", "chance_creation_shooting", "chance_creation_shooting_class", "chance_creation_positioning_class", "defence_pressure", "defence_pressure_class", "defence_aggression", "defence_aggression_class", "defence_team_width", "defence_team_width_class", "defence_defender_line_class"]
### What is the average weight of all players?
SELECT avg(weight) FROM Player; ###
###Postgre SQL tables, with their properties:
# player_attributes: ["id", "player_fifa_api_id", "player_api_id", "date", "overall_rating", "potential", "preferred_foot", "attacking_work_rate", "defensive_work_rate", "crossing", "finishing", "heading_accuracy", "short_passing", "volleys", "dribbling", "curve", "free_kick_accuracy", "long_passing", "ball_control", "acceleration", "sprint_speed", "agility", "reactions", "balance", "shot_power", "jumping", "stamina", "strength", "long_shots", "aggression", "interceptions", "positioning", "vision", "penalties", "marking", "standing_tackle", "sliding_tackle", "gk_diving", "gk_handling", "gk_kicking", "gk_positioning", "gk_reflexes"]
# sqlite_sequence: ["name", "seq"]
# player: ["id", "player_api_id", "player_name", "player_fifa_api_id", "birthday", "height", "weight"]
# league: ["id", "country_id", "name"]
# country: ["id", "name"]
# team: ["id", "team_api_id", "team_fifa_api_id", "team_long_name", "team_short_name"]
# team_attributes: ["id", "team_fifa_api_id", "team_api_id", "date", "buildup_play_speed", "buildup_play_speed_class", "buildup_play_dribbling", "buildup_play_dribbling_class", "buildup_play_passing", "buildup_play_passing_class", "buildup_play_positioning_class", "chance_creation_passing", "chance_creation_passing_class", "chance_creation_crossing", "chance_creation_crossing_class", "chance_creation_shooting", "chance_creation_shooting_class", "chance_creation_positioning_class", "defence_pressure", "defence_pressure_class", "defence_aggression", "defence_aggression_class", "defence_team_width", "defence_team_width_class", "defence_defender_line_class"]
### What is the maximum and minimum height of all players?
SELECT max(weight),min(weight) FROM Player; ###
###Postgre SQL tables, with their properties:
# player_attributes: ["id", "player_fifa_api_id", "player_api_id", "date", "overall_rating", "potential", "preferred_foot", "attacking_work_rate", "defensive_work_rate", "crossing", "finishing", "heading_accuracy", "short_passing", "volleys", "dribbling", "curve", "free_kick_accuracy", "long_passing", "ball_control", "acceleration", "sprint_speed", "agility", "reactions", "balance", "shot_power", "jumping", "stamina", "strength", "long_shots", "aggression", "interceptions", "positioning", "vision", "penalties", "marking", "standing_tackle", "sliding_tackle", "gk_diving", "gk_handling", "gk_kicking", "gk_positioning", "gk_reflexes"]
# sqlite_sequence: ["name", "seq"]
# player: ["id", "player_api_id", "player_name", "player_fifa_api_id", "birthday", "height", "weight"]
# league: ["id", "country_id", "name"]
# country: ["id", "name"]
# team: ["id", "team_api_id", "team_fifa_api_id", "team_long_name", "team_short_name"]
# team_attributes: ["id", "team_fifa_api_id", "team_api_id", "date", "buildup_play_speed", "buildup_play_speed_class", "buildup_play_dribbling", "buildup_play_dribbling_class", "buildup_play_passing", "buildup_play_passing_class", "buildup_play_positioning_class", "chance_creation_passing", "chance_creation_passing_class", "chance_creation_crossing", "chance_creation_crossing_class", "chance_creation_shooting", "chance_creation_shooting_class", "chance_creation_positioning_class", "defence_pressure", "defence_pressure_class", "defence_aggression", "defence_aggression_class", "defence_team_width", "defence_team_width_class", "defence_defender_line_class"]
### What is the average rating for right-footed players and left-footed players?
SELECT preferred_foot,avg(overall_rating) FROM Player_Attributes GROUP BY preferred_foot; ###
###Postgre SQL tables, with their properties:
# player_attributes: ["id", "player_fifa_api_id", "player_api_id", "date", "overall_rating", "potential", "preferred_foot", "attacking_work_rate", "defensive_work_rate", "crossing", "finishing", "heading_accuracy", "short_passing", "volleys", "dribbling", "curve", "free_kick_accuracy", "long_passing", "ball_control", "acceleration", "sprint_speed", "agility", "reactions", "balance", "shot_power", "jumping", "stamina", "strength", "long_shots", "aggression", "interceptions", "positioning", "vision", "penalties", "marking", "standing_tackle", "sliding_tackle", "gk_diving", "gk_handling", "gk_kicking", "gk_positioning", "gk_reflexes"]
# sqlite_sequence: ["name", "seq"]
# player: ["id", "player_api_id", "player_name", "player_fifa_api_id", "birthday", "height", "weight"]
# league: ["id", "country_id", "name"]
# country: ["id", "name"]
# team: ["id", "team_api_id", "team_fifa_api_id", "team_long_name", "team_short_name"]
# team_attributes: ["id", "team_fifa_api_id", "team_api_id", "date", "buildup_play_speed", "buildup_play_speed_class", "buildup_play_dribbling", "buildup_play_dribbling_class", "buildup_play_passing", "buildup_play_passing_class", "buildup_play_positioning_class", "chance_creation_passing", "chance_creation_passing_class", "chance_creation_crossing", "chance_creation_crossing_class", "chance_creation_shooting", "chance_creation_shooting_class", "chance_creation_positioning_class", "defence_pressure", "defence_pressure_class", "defence_aggression", "defence_aggression_class", "defence_team_width", "defence_team_width_class", "defence_defender_line_class"]
### Of all players with an overall rating greater than 80, how many are right-footed and left-footed?
SELECT preferred_foot,count(*) FROM Player_Attributes WHERE overall_rating > 80 GROUP BY preferred_foot; ###
###Postgre SQL tables, with their properties:
# player_attributes: ["id", "player_fifa_api_id", "player_api_id", "date", "overall_rating", "potential", "preferred_foot", "attacking_work_rate", "defensive_work_rate", "crossing", "finishing", "heading_accuracy", "short_passing", "volleys", "dribbling", "curve", "free_kick_accuracy", "long_passing", "ball_control", "acceleration", "sprint_speed", "agility", "reactions", "balance", "shot_power", "jumping", "stamina", "strength", "long_shots", "aggression", "interceptions", "positioning", "vision", "penalties", "marking", "standing_tackle", "sliding_tackle", "gk_diving", "gk_handling", "gk_kicking", "gk_positioning", "gk_reflexes"]
# sqlite_sequence: ["name", "seq"]
# player: ["id", "player_api_id", "player_name", "player_fifa_api_id", "birthday", "height", "weight"]
# league: ["id", "country_id", "name"]
# country: ["id", "name"]
# team: ["id", "team_api_id", "team_fifa_api_id", "team_long_name", "team_short_name"]
# team_attributes: ["id", "team_fifa_api_id", "team_api_id", "date", "buildup_play_speed", "buildup_play_speed_class", "buildup_play_dribbling", "buildup_play_dribbling_class", "buildup_play_passing", "buildup_play_passing_class", "buildup_play_positioning_class", "chance_creation_passing", "chance_creation_passing_class", "chance_creation_crossing", "chance_creation_crossing_class", "chance_creation_shooting", "chance_creation_shooting_class", "chance_creation_positioning_class", "defence_pressure", "defence_pressure_class", "defence_aggression", "defence_aggression_class", "defence_team_width", "defence_team_width_class", "defence_defender_line_class"]
### List all of the player ids with a height of at least 180cm and an overall rating higher than 85.
SELECT player_api_id FROM Player WHERE height >= 180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating > 85; ###
###Postgre SQL tables, with their properties:
# player_attributes: ["id", "player_fifa_api_id", "player_api_id", "date", "overall_rating", "potential", "preferred_foot", "attacking_work_rate", "defensive_work_rate", "crossing", "finishing", "heading_accuracy", "short_passing", "volleys", "dribbling", "curve", "free_kick_accuracy", "long_passing", "ball_control", "acceleration", "sprint_speed", "agility", "reactions", "balance", "shot_power", "jumping", "stamina", "strength", "long_shots", "aggression", "interceptions", "positioning", "vision", "penalties", "marking", "standing_tackle", "sliding_tackle", "gk_diving", "gk_handling", "gk_kicking", "gk_positioning", "gk_reflexes"]
# sqlite_sequence: ["name", "seq"]
# player: ["id", "player_api_id", "player_name", "player_fifa_api_id", "birthday", "height", "weight"]
# league: ["id", "country_id", "name"]
# country: ["id", "name"]
# team: ["id", "team_api_id", "team_fifa_api_id", "team_long_name", "team_short_name"]
# team_attributes: ["id", "team_fifa_api_id", "team_api_id", "date", "buildup_play_speed", "buildup_play_speed_class", "buildup_play_dribbling", "buildup_play_dribbling_class", "buildup_play_passing", "buildup_play_passing_class", "buildup_play_positioning_class", "chance_creation_passing", "chance_creation_passing_class", "chance_creation_crossing", "chance_creation_crossing_class", "chance_creation_shooting", "chance_creation_shooting_class", "chance_creation_positioning_class", "defence_pressure", "defence_pressure_class", "defence_aggression", "defence_aggression_class", "defence_team_width", "defence_team_width_class", "defence_defender_line_class"]
### List all of the ids for left-footed players with a height between 180cm and 190cm.
SELECT player_api_id FROM Player WHERE height >= 180 AND height <= 190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot = "left"; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### How many performances are there?
SELECT count(*) FROM performance; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### List the hosts of performances in ascending order of attendance.
SELECT HOST FROM performance ORDER BY Attendance ASC; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### What are the dates and locations of performances?
SELECT Date,LOCATION FROM performance; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### Show the attendances of the performances at location "TD_Garden" or "Bell_Centre"
SELECT Attendance FROM performance WHERE LOCATION = "TD_Garden" OR LOCATION = "Bell_Centre"; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### What is the average number of attendees for performances?
SELECT avg(Attendance) FROM performance; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### What is the date of the performance with the highest number of attendees?
SELECT Date FROM performance ORDER BY Attendance DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### Show different locations and the number of performances at each location.
SELECT LOCATION,COUNT(*) FROM performance GROUP BY LOCATION; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### Show the most common location of performances.
SELECT LOCATION FROM performance GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### Show the locations that have at least two performances.
SELECT LOCATION FROM performance GROUP BY LOCATION HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### Show the locations that have both performances with more than 2000 attendees and performances with less than 1000 attendees.
SELECT LOCATION FROM performance WHERE Attendance > 2000 INTERSECT SELECT LOCATION FROM performance WHERE Attendance < 1000; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "name", "nationality", "role"]
# performance: ["performance_id", "date", "host", "location", "attendance"]
# member_attendance: ["member_id", "performance_id", "num_of_pieces"]
### List the names of members who did not attend any performance.
SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the buildings which have rooms with capacity more than 50.
SELECT DISTINCT building FROM classroom WHERE capacity > 50; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the distinct buildings with capacities of greater than 50?
SELECT DISTINCT building FROM classroom WHERE capacity > 50; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of rooms that are not in the Lamberton building.
SELECT count(*) FROM classroom WHERE building != 'Lamberton'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many classrooms are not in Lamberton?
SELECT count(*) FROM classroom WHERE building != 'Lamberton'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the name and building of the departments whose budget is more than the average budget?
SELECT dept_name,building FROM department WHERE budget > (SELECT avg(budget) FROM department); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Give the name and building of the departments with greater than average budget.
SELECT dept_name,building FROM department WHERE budget > (SELECT avg(budget) FROM department); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the room number of the rooms which can sit 50 to 100 students and their buildings.
SELECT building,room_number FROM classroom WHERE capacity BETWEEN 50 AND 100; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the room numbers and corresponding buildings for classrooms which can seat between 50 to 100 students?
SELECT building,room_number FROM classroom WHERE capacity BETWEEN 50 AND 100; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name and building of the department with the highest budget.
SELECT dept_name,building FROM department ORDER BY budget DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the department name and corresponding building for the department with the greatest budget?
SELECT dept_name,building FROM department ORDER BY budget DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the name of the student who has the highest total credits in the History department.
SELECT name FROM student WHERE dept_name = 'History' ORDER BY tot_cred DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Give the name of the student in the History department with the most credits.
SELECT name FROM student WHERE dept_name = 'History' ORDER BY tot_cred DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many rooms does the Lamberton building have?
SELECT count(*) FROM classroom WHERE building = 'Lamberton'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of classrooms in Lamberton.
SELECT count(*) FROM classroom WHERE building = 'Lamberton'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many students have advisors?
SELECT count(DISTINCT s_id) FROM advisor; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of students who have advisors.
SELECT count(DISTINCT s_id) FROM advisor; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many departments offer courses?
SELECT count(DISTINCT dept_name) FROM course; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of departments which offer courses.
SELECT count(DISTINCT dept_name) FROM course; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many different courses offered by Physics department?
SELECT count(DISTINCT course_id) FROM course WHERE dept_name = 'Physics'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of courses in the Physics department.
SELECT count(DISTINCT course_id) FROM course WHERE dept_name = 'Physics'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many courses that do not have prerequisite?
SELECT count(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of courses without prerequisites.
SELECT count(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name of the courses that do not have any prerequisite?
SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the titles of courses without prerequisites?
SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many different instructors have taught some course?
SELECT COUNT (DISTINCT id) FROM teaches; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of distinct instructors who have taught a course.
SELECT COUNT (DISTINCT id) FROM teaches; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the total budgets of the Marketing or Finance department.
SELECT sum(budget) FROM department WHERE dept_name = 'Marketing' OR dept_name = 'Finance'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the sum of budgets of the Marketing and Finance departments?
SELECT sum(budget) FROM department WHERE dept_name = 'Marketing' OR dept_name = 'Finance'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the department name of the instructor whose name contains 'Soisalon'.
SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the name of the department with an instructure who has a name like 'Soisalon'?
SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many rooms whose capacity is less than 50 does the Lamberton building have?
SELECT count(*) FROM classroom WHERE building = 'Lamberton' AND capacity < 50; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Count the number of rooms in Lamberton with capacity lower than 50.
SELECT count(*) FROM classroom WHERE building = 'Lamberton' AND capacity < 50; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name and budget of departments whose budgets are more than the average budget.
SELECT dept_name,budget FROM department WHERE budget > (SELECT avg(budget) FROM department); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names and budgets of departments with budgets greater than the average?
SELECT dept_name,budget FROM department WHERE budget > (SELECT avg(budget) FROM department); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### what is the name of the instructor who is in Statistics department and earns the lowest salary?
SELECT name FROM instructor WHERE dept_name = 'Statistics' ORDER BY salary LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Give the name of the lowest earning instructor in the Statistics department.
SELECT name FROM instructor WHERE dept_name = 'Statistics' ORDER BY salary LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the title of course that is provided by both Statistics and Psychology departments.
SELECT title FROM course WHERE dept_name = 'Statistics' INTERSECT SELECT title FROM course WHERE dept_name = 'Psychology'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the title of a course that is listed in both the Statistics and Psychology departments?
SELECT title FROM course WHERE dept_name = 'Statistics' INTERSECT SELECT title FROM course WHERE dept_name = 'Psychology'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the title of course that is provided by Statistics but not Psychology departments.
SELECT title FROM course WHERE dept_name = 'Statistics' EXCEPT SELECT title FROM course WHERE dept_name = 'Psychology'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the titles of courses that are in the Statistics department but not the Psychology department?
SELECT title FROM course WHERE dept_name = 'Statistics' EXCEPT SELECT title FROM course WHERE dept_name = 'Psychology'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the id of instructors who taught a class in Fall 2009 but not in Spring 2010.
SELECT id FROM teaches WHERE semester = 'Fall' AND YEAR = 2009 EXCEPT SELECT id FROM teaches WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the ids of instructors who taught in the Fall of 2009 but not in the Spring of 2010?
SELECT id FROM teaches WHERE semester = 'Fall' AND YEAR = 2009 EXCEPT SELECT id FROM teaches WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names of the top 3 departments that provide the largest amount of courses?
SELECT dept_name FROM course GROUP BY dept_name ORDER BY count(*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of the 3 departments with the most courses?
SELECT dept_name FROM course GROUP BY dept_name ORDER BY count(*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name of the department that offers the highest total credits?
SELECT dept_name FROM course GROUP BY dept_name ORDER BY sum(credits) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the name of the department with the most credits?
SELECT dept_name FROM course GROUP BY dept_name ORDER BY sum(credits) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### List the names of all courses ordered by their titles and credits.
SELECT title FROM course ORDER BY title,credits; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Given the titles of all courses, in order of titles and credits.
SELECT title FROM course ORDER BY title,credits; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Which department has the lowest budget?
SELECT dept_name FROM department ORDER BY budget LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Give the name of the department with the lowest budget.
SELECT dept_name FROM department ORDER BY budget LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### List the names and buildings of all departments sorted by the budget from large to small.
SELECT dept_name,building FROM department ORDER BY budget DESC; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names and buildings of the deparments, sorted by budget descending?
SELECT dept_name,building FROM department ORDER BY budget DESC; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Who is the instructor with the highest salary?
SELECT name FROM instructor ORDER BY salary DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Give the name of the highest paid instructor.
SELECT name FROM instructor ORDER BY salary DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### List the information of all instructors ordered by their salary in ascending order.
SELECT * FROM instructor ORDER BY salary; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Give all information regarding instructors, in order of salary from least to greatest.
SELECT * FROM instructor ORDER BY salary; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name of the students and their department names sorted by their total credits in ascending order.
SELECT name,dept_name FROM student ORDER BY tot_cred; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of students and their respective departments, ordered by number of credits from least to greatest?
SELECT name,dept_name FROM student ORDER BY tot_cred; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the number of rooms with more than 50 capacity for each building.
SELECT count(*),building FROM classroom WHERE capacity > 50 GROUP BY building; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many rooms in each building have a capacity of over 50?
SELECT count(*),building FROM classroom WHERE capacity > 50 GROUP BY building; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the maximum and average capacity among rooms in each building.
SELECT max(capacity),avg(capacity),building FROM classroom GROUP BY building; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the greatest and average capacity for rooms in each building?
SELECT max(capacity),avg(capacity),building FROM classroom GROUP BY building; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the title of the course that is offered by more than one department.
SELECT title FROM course GROUP BY title HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the titles of courses that are offered in more than one department?
SELECT title FROM course GROUP BY title HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the total credits of courses provided by different department.
SELECT sum(credits),dept_name FROM course GROUP BY dept_name; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many total credits are offered by each department?
SELECT sum(credits),dept_name FROM course GROUP BY dept_name; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the minimum salary for the departments whose average salary is above the average payment of all instructors.
SELECT min(salary),dept_name FROM instructor GROUP BY dept_name HAVING avg(salary) > (SELECT avg(salary) FROM instructor); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the lowest salary in departments with average salary greater than the overall average.
SELECT min(salary),dept_name FROM instructor GROUP BY dept_name HAVING avg(salary) > (SELECT avg(salary) FROM instructor); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the number of courses provided in each semester and year.
SELECT count(*),semester,YEAR FROM SECTION GROUP BY semester,YEAR; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many courses are provided in each semester and year?
SELECT count(*),semester,YEAR FROM SECTION GROUP BY semester,YEAR; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the year which offers the largest number of courses.
SELECT YEAR FROM SECTION GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Which year had the greatest number of courses?
SELECT YEAR FROM SECTION GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the year and semester when offers the largest number of courses.
SELECT semester,YEAR FROM SECTION GROUP BY semester,YEAR ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the year and semester with the most courses?
SELECT semester,YEAR FROM SECTION GROUP BY semester,YEAR ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name of department has the highest amount of students?
SELECT dept_name FROM student GROUP BY dept_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What is the name of the deparment with the highest enrollment?
SELECT dept_name FROM student GROUP BY dept_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the total number of students in each department.
SELECT count(*),dept_name FROM student GROUP BY dept_name; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many students are in each department?
SELECT count(*),dept_name FROM student GROUP BY dept_name; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the semester and year which has the least number of student taking any class.
SELECT semester,YEAR FROM takes GROUP BY semester,YEAR ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Which semeseter and year had the fewest students?
SELECT semester,YEAR FROM takes GROUP BY semester,YEAR ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the id of the courses that do not have any prerequisite?
SELECT course_id FROM course EXCEPT SELECT course_id FROM prereq; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the ids of courses without prerequisites?
SELECT course_id FROM course EXCEPT SELECT course_id FROM prereq; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name of the courses that do not have any prerequisite?
SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of courses without prerequisites?
SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names of students who have taken any course in the fall semester of year 2003.
SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester = 'Fall' AND YEAR = 2003); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of students who took a course in the Fall of 2003?
SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester = 'Fall' AND YEAR = 2003); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name of instructors who didn't teach any courses?
SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of instructors who didn't teach?
SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the id of instructors who didn't teach any courses?
SELECT id FROM instructor EXCEPT SELECT id FROM teaches; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the ids of instructors who didnt' teach?
SELECT id FROM instructor EXCEPT SELECT id FROM teaches; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names of instructors who didn't each any courses in any Spring semester.
SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester = 'Spring'); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of instructors who didn't teach courses in the Spring?
SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester = 'Spring'); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name of the department which has the highest average salary of professors.
SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY avg(salary) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Which department has the highest average instructor salary?
SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY avg(salary) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.
SELECT name,salary FROM instructor WHERE salary < (SELECT avg(salary) FROM instructor WHERE dept_name = 'Physics'); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names and salaries for instructors who earn less than the average salary of instructors in the Physics department?
SELECT name,salary FROM instructor WHERE salary < (SELECT avg(salary) FROM instructor WHERE dept_name = 'Physics'); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names of all instructors in computer science department
SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of all instructors in the Comp. Sci. department?
SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names of all instructors in Comp. Sci. department with salary > 80000.
SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 80000; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of the instructors in the Comp. Sci. department who earn more than 80000?
SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 80000; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names of all instructors whose name includes the substring “dar”.
SELECT name FROM instructor WHERE name LIKE '%dar%'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of all instructors with names that include "dar"?
SELECT name FROM instructor WHERE name LIKE '%dar%'; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### List in alphabetic order the names of all distinct instructors.
SELECT DISTINCT name FROM instructor ORDER BY name; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### List the distinct names of the instructors, ordered by name.
SELECT DISTINCT name FROM instructor ORDER BY name; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find courses that ran in Fall 2009 or in Spring 2010.
SELECT course_id FROM SECTION WHERE semester = 'Fall' AND YEAR = 2009 UNION SELECT course_id FROM SECTION WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the ids for courses in the Fall of 2009 or the Spring of 2010?
SELECT course_id FROM SECTION WHERE semester = 'Fall' AND YEAR = 2009 UNION SELECT course_id FROM SECTION WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find courses that ran in Fall 2009 and in Spring 2010.
SELECT course_id FROM SECTION WHERE semester = 'Fall' AND YEAR = 2009 INTERSECT SELECT course_id FROM SECTION WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the ids for courses that were offered in both Fall of 2009 and Spring of 2010?
SELECT course_id FROM SECTION WHERE semester = 'Fall' AND YEAR = 2009 INTERSECT SELECT course_id FROM SECTION WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find courses that ran in Fall 2009 but not in Spring 2010.
SELECT course_id FROM SECTION WHERE semester = 'Fall' AND YEAR = 2009 EXCEPT SELECT course_id FROM SECTION WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the ids of courses offered in Fall of 2009 but not in Spring of 2010?
SELECT course_id FROM SECTION WHERE semester = 'Fall' AND YEAR = 2009 EXCEPT SELECT course_id FROM SECTION WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the salaries of all distinct instructors that are less than the largest salary.
SELECT DISTINCT salary FROM instructor WHERE salary < (SELECT max(salary) FROM instructor); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the distinct salaries of all instructors who earned less than the maximum salary?
SELECT DISTINCT salary FROM instructor WHERE salary < (SELECT max(salary) FROM instructor); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the total number of instructors who teach a course in the Spring 2010 semester.
SELECT COUNT (DISTINCT ID) FROM teaches WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### How many instructors teach a course in the Spring of 2010?
SELECT COUNT (DISTINCT ID) FROM teaches WHERE semester = 'Spring' AND YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names and average salaries of all departments whose average salary is greater than 42000.
SELECT dept_name,AVG (salary) FROM instructor GROUP BY dept_name HAVING AVG (salary) > 42000; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names and average salaries for departments with average salary higher than 42000?
SELECT dept_name,AVG (salary) FROM instructor GROUP BY dept_name HAVING AVG (salary) > 42000; ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find names of instructors with salary greater than that of some (at least one) instructor in the Biology department.
SELECT name FROM instructor WHERE salary > (SELECT min(salary) FROM instructor WHERE dept_name = 'Biology'); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of instructors who earn more than at least one instructor from the Biology department?
SELECT name FROM instructor WHERE salary > (SELECT min(salary) FROM instructor WHERE dept_name = 'Biology'); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### Find the names of all instructors whose salary is greater than the salary of all instructors in the Biology department.
SELECT name FROM instructor WHERE salary > (SELECT max(salary) FROM instructor WHERE dept_name = 'Biology'); ###
###Postgre SQL tables, with their properties:
# classroom: ["building", "room_number", "capacity"]
# department: ["department_name", "building", "budget"]
# course: ["course_id", "title", "department_name", "credits"]
# instructor: ["id", "name", "department_name", "salary"]
# section: ["course_id", "section_id", "semester", "year", "building", "room_number", "time_slot_id"]
# teaches: ["id", "course_id", "section_id", "semester", "year"]
# student: ["id", "name", "department_name", "total_credits"]
# takes_classes: ["id", "course_id", "section_id", "semester", "year", "grade"]
# advisor: ["student_id", "instructor_id"]
# time_slot: ["time_slot_id", "day", "start_hour", "start_minute", "end_hour", "end_minute"]
# prerequisite: ["course_id", "prerequisite_id"]
### What are the names of all instructors with a higher salary than any of the instructors in the Biology department?
SELECT name FROM instructor WHERE salary > (SELECT max(salary) FROM instructor WHERE dept_name = 'Biology'); ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### How many debates are there?
SELECT count(*) FROM debate; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### List the venues of debates in ascending order of the number of audience.
SELECT Venue FROM debate ORDER BY Num_of_Audience ASC; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### What are the date and venue of each debate?
SELECT Date,Venue FROM debate; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### List the dates of debates with number of audience bigger than 150
SELECT Date FROM debate WHERE Num_of_Audience > 150; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### Show the names of people aged either 35 or 36.
SELECT Name FROM people WHERE Age = 35 OR Age = 36; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### What is the party of the youngest people?
SELECT Party FROM people ORDER BY Age ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### Show different parties of people along with the number of people in each party.
SELECT Party,COUNT(*) FROM people GROUP BY Party; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### Show the party that has the most people.
SELECT Party FROM people GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### Show the distinct venues of debates
SELECT DISTINCT Venue FROM debate; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "district", "name", "party", "age"]
# debate: ["debate_id", "date", "venue", "num_of_audience"]
# debate_people: ["debate_id", "affirmative", "negative", "if_affirmative_win"]
### List the names of people that have not been on the affirmative side of debates.
SELECT Name FROM people WHERE People_id NOT IN (SELECT Affirmative FROM debate_people); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### List the names of all the customers in alphabetical order.
SELECT customer_details FROM customers ORDER BY customer_details; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Sort the customer names in alphabetical order.
SELECT customer_details FROM customers ORDER BY customer_details; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Which type of policy is most frequently used? Give me the policy type code.
SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find the type code of the most frequently used policy.
SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find all the policy types that are used by more than 2 customers.
SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Which types of policy are chosen by more than 2 customers? Give me the policy type codes.
SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find the total and average amount paid in claim headers.
SELECT sum(amount_piad),avg(amount_piad) FROM claim_headers; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### What are the total amount and average amount paid in claim headers?
SELECT sum(amount_piad),avg(amount_piad) FROM claim_headers; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### How many claim processing stages are there in total?
SELECT count(*) FROM claims_processing_stages; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find the number of distinct stages in claim processing.
SELECT count(*) FROM claims_processing_stages; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find the names of customers whose name contains "Diana".
SELECT customer_details FROM customers WHERE customer_details LIKE "%Diana%"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Which customers have the substring "Diana" in their names? Return the customer details.
SELECT customer_details FROM customers WHERE customer_details LIKE "%Diana%"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find the names of all the customers and staff members.
SELECT customer_details FROM customers UNION SELECT staff_details FROM staff; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### What are the names of the customers and staff members?
SELECT customer_details FROM customers UNION SELECT staff_details FROM staff; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find the number of records of each policy type and its type code.
SELECT policy_type_code,count(*) FROM policies GROUP BY policy_type_code; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### For each policy type, return its type code and its count in the record.
SELECT policy_type_code,count(*) FROM policies GROUP BY policy_type_code; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### What is the description of the claim status "Open"?
SELECT claim_status_description FROM claims_processing_stages WHERE claim_status_name = "Open"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Find the description of the claim status "Open".
SELECT claim_status_description FROM claims_processing_stages WHERE claim_status_name = "Open"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### How many distinct claim outcome codes are there?
SELECT count(DISTINCT claim_outcome_code) FROM claims_processing; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# staff: ["staff_id", "staff_details"]
# policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claim_headers: ["claim_header_id", "claim_status_code", "claim_type_code", "policy_id", "date_of_claim", "date_of_settlement", "amount_claimed", "amount_piad"]
# claims_documents: ["claim_id", "document_type_code", "created_by_staff_id", "created_date"]
# claims_processing_stages: ["claim_stage_id", "next_claim_stage_id", "claim_status_name", "claim_status_description"]
# claims_processing: ["claim_processing_id", "claim_id", "claim_outcome_code", "claim_stage_id", "staff_id"]
### Count the number of distinct claim outcome codes.
SELECT count(DISTINCT claim_outcome_code) FROM claims_processing; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the number of accounts.
SELECT count(*) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many accounts are there?
SELECT count(*) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many customers have opened an account?
SELECT count(DISTINCT customer_id) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of customers who have an account.
SELECT count(DISTINCT customer_id) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the id, the date of account opened, the account name, and other account detail for all accounts.
SELECT account_id,date_account_opened,account_name,other_account_details FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What are the ids, date opened, name, and other details for all accounts?
SELECT account_id,date_account_opened,account_name,other_account_details FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many customers don't have an account?
SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of customers who do not have an account.
SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show customer ids who don't have an account.
SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What are the customer ids for customers who do not have an account?
SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Accounts; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many accounts does each customer have? List the number and customer id.
SELECT count(*),customer_id FROM Accounts GROUP BY customer_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of accounts corresponding to each customer id.
SELECT count(*),customer_id FROM Accounts GROUP BY customer_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the number of customers.
SELECT count(*) FROM Customers; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of customers.
SELECT count(*) FROM Customers; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the number of customers for each gender.
SELECT gender,count(*) FROM Customers GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many customers are there of each gender?
SELECT gender,count(*) FROM Customers GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many transactions do we have?
SELECT count(*) FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of transactions.
SELECT count(*) FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many transaction does each account have? Show the number and account id.
SELECT count(*),account_id FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of financial transactions that correspond to each account id.
SELECT count(*),account_id FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What is the average, minimum, maximum, and total transaction amount?
SELECT avg(transaction_amount),min(transaction_amount),max(transaction_amount), sum(transaction_amount) FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Return the average, minimum, maximum, and total transaction amounts.
SELECT avg(transaction_amount),min(transaction_amount),max(transaction_amount), sum(transaction_amount) FROM Financial_transactions; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show ids for all transactions whose amounts are greater than the average.
SELECT transaction_id FROM Financial_transactions WHERE transaction_amount > (SELECT avg(transaction_amount) FROM Financial_transactions); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What are the ids for transactions that have an amount greater than the average amount of a transaction?
SELECT transaction_id FROM Financial_transactions WHERE transaction_amount > (SELECT avg(transaction_amount) FROM Financial_transactions); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the transaction types and the total amount of transactions.
SELECT transaction_type,sum(transaction_amount) FROM Financial_transactions GROUP BY transaction_type; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What are total transaction amounts for each transaction type?
SELECT transaction_type,sum(transaction_amount) FROM Financial_transactions GROUP BY transaction_type; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the account id with most number of transactions.
SELECT account_id FROM Financial_transactions GROUP BY account_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What is the id of the account with the most transactions?
SELECT account_id FROM Financial_transactions GROUP BY account_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show all product sizes.
SELECT DISTINCT product_size FROM Products; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What are the different product sizes?
SELECT DISTINCT product_size FROM Products; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show all product colors.
SELECT DISTINCT product_color FROM Products; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### What are the different product colors?
SELECT DISTINCT product_color FROM Products; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the invoice number and the number of transactions for each invoice.
SELECT invoice_number,count(*) FROM Financial_transactions GROUP BY invoice_number; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many transactions correspond to each invoice number?
SELECT invoice_number,count(*) FROM Financial_transactions GROUP BY invoice_number; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many invoices do we have?
SELECT count(*) FROM Invoices; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of invoices.
SELECT count(*) FROM Invoices; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the order ids and the number of invoices for each order.
SELECT order_id,count(*) FROM Invoices GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many invoices correspond to each order id?
SELECT order_id,count(*) FROM Invoices GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the order ids and the number of items in each order.
SELECT order_id,count(*) FROM Order_items GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many order items correspond to each order id?
SELECT order_id,count(*) FROM Order_items GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show the product ids and the number of unique orders containing each product.
SELECT product_id,count(DISTINCT order_id) FROM Order_items GROUP BY product_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many distinct order ids correspond to each product?
SELECT product_id,count(DISTINCT order_id) FROM Order_items GROUP BY product_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show order ids and the number of products in each order.
SELECT order_id,count(DISTINCT product_id) FROM Order_items GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many different products correspond to each order id?
SELECT order_id,count(DISTINCT product_id) FROM Order_items GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Show order ids and the total quantity in each order.
SELECT order_id,sum(product_quantity) FROM Order_items GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Give the order ids for all orders, as well as the total product quantity in each.
SELECT order_id,sum(product_quantity) FROM Order_items GROUP BY order_id; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### How many products were not included in any order?
SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items ); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_first_name", "customer_middle_initial", "customer_last_name", "gender", "email_address", "login_name", "login_password", "phone_number", "town_city", "state_county_province", "country"]
# orders: ["order_id", "customer_id", "date_order_placed", "order_details"]
# invoices: ["invoice_number", "order_id", "invoice_date"]
# accounts: ["account_id", "customer_id", "date_account_opened", "account_name", "other_account_details"]
# product_categories: ["production_type_code", "product_type_description", "vat_rating"]
# products: ["product_id", "parent_product_id", "production_type_code", "unit_price", "product_name", "product_color", "product_size"]
# financial_transactions: ["transaction_id", "account_id", "invoice_number", "transaction_type", "transaction_date", "transaction_amount", "transaction_comment", "other_transaction_details"]
# order_items: ["order_item_id", "order_id", "product_id", "product_quantity", "other_order_item_details"]
# invoice_line_items: ["order_item_id", "invoice_number", "product_id", "product_title", "product_quantity", "product_price", "derived_product_cost", "derived_vat_payable", "derived_total_cost"]
### Count the number of products that were never ordered.
SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items ); ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### How many churches opened before 1850 are there?
SELECT count(*) FROM Church WHERE Open_Date < 1850; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the name, open date, and organizer for all churches.
SELECT name,open_date,organized_by FROM Church; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### List all church names in descending order of opening date.
SELECT name FROM church ORDER BY open_date DESC; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the opening year in whcih at least two churches opened.
SELECT open_date FROM church GROUP BY open_date HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the organizer and name for churches that opened between 1830 and 1840.
SELECT organized_by,name FROM church WHERE open_date BETWEEN 1830 AND 1840; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show all opening years and the number of churches that opened in that year.
SELECT open_date,count(*) FROM church GROUP BY open_date; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the name and opening year for three churches that opened most recently.
SELECT name,open_date FROM church ORDER BY open_date DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### How many female people are older than 30 in our record?
SELECT count(*) FROM people WHERE is_male = 'F' AND age > 30; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the country where people older than 30 and younger than 25 are from.
SELECT country FROM people WHERE age < 25 INTERSECT SELECT country FROM people WHERE age > 30; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the minimum, maximum, and average age for all people.
SELECT min(age),max(age),avg(age) FROM people; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the name and country for all people whose age is smaller than the average.
SELECT name,country FROM people WHERE age < (SELECT avg(age) FROM people); ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show the name and age for all male people who don't have a wedding.
SELECT name,age FROM people WHERE is_male = 'T' AND people_id NOT IN (SELECT male_id FROM wedding); ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### How many weddings are there in year 2016?
SELECT count(*) FROM wedding WHERE YEAR = 2016; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### Show all countries and the number of people from each country.
SELECT country,count(*) FROM people GROUP BY country; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "name", "country", "is_male", "age"]
# church: ["church_id", "name", "organized_by", "open_date", "continuation_of"]
# wedding: ["church_id", "male_id", "female_id", "year"]
### How many churches have a wedding in year 2016?
SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR = 2016; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### How many artists do we have?
SELECT count(*) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Count the number of artists.
SELECT count(*) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Show all artist name, age, and country ordered by the yeared they joined.
SELECT name,age,country FROM artist ORDER BY Year_Join; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What are the names, ages, and countries of artists, sorted by the year they joined?
SELECT name,age,country FROM artist ORDER BY Year_Join; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What are all distinct country for artists?
SELECT DISTINCT country FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Return the different countries for artists.
SELECT DISTINCT country FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Show all artist names and the year joined who are not from United States.
SELECT name,year_join FROM artist WHERE country != 'United States'; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What are the names and year of joining for artists that do not have the country "United_States"?
SELECT name,year_join FROM artist WHERE country != 'United States'; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### How many artists are above age 46 and joined after 1990?
SELECT count(*) FROM artist WHERE age > 46 AND year_join > 1990; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Count the number of artists who are older than 46 and joined after 1990.
SELECT count(*) FROM artist WHERE age > 46 AND year_join > 1990; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What is the average and minimum age of all artists from United States.
SELECT avg(age),min(age) FROM artist WHERE country = 'United States'; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Return the average and minimum ages across artists from the United States.
SELECT avg(age),min(age) FROM artist WHERE country = 'United States'; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What is the name of the artist who joined latest?
SELECT name FROM artist ORDER BY year_join DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Return the name of the artist who has the latest join year.
SELECT name FROM artist ORDER BY year_join DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### How many exhibition are there in year 2005 or after?
SELECT count(*) FROM exhibition WHERE YEAR >= 2005; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Count the number of exhibitions that happened in or after 2005.
SELECT count(*) FROM exhibition WHERE YEAR >= 2005; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Show theme and year for all exhibitions with ticket prices lower than 15.
SELECT theme,YEAR FROM exhibition WHERE ticket_price < 15; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What are the theme and year for all exhibitions that have a ticket price under 15?
SELECT theme,YEAR FROM exhibition WHERE ticket_price < 15; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Show names for artists without any exhibition.
SELECT name FROM artist WHERE artist_id NOT IN (SELECT artist_id FROM exhibition); ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What are the names of artists that have not had any exhibitions?
SELECT name FROM artist WHERE artist_id NOT IN (SELECT artist_id FROM exhibition); ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Show the average, minimum, and maximum ticket prices for exhibitions for all years before 2009.
SELECT avg(ticket_price),min(ticket_price),max(ticket_price) FROM exhibition WHERE YEAR < 2009; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What are the average, minimum, and maximum ticket prices for exhibitions that happened prior to 2009?
SELECT avg(ticket_price),min(ticket_price),max(ticket_price) FROM exhibition WHERE YEAR < 2009; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### Show theme and year for all exhibitions in an descending order of ticket price.
SELECT theme,YEAR FROM exhibition ORDER BY ticket_price DESC; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "name", "country", "year_join", "age"]
# exhibition: ["exhibition_id", "year", "theme", "artist_id", "ticket_price"]
# exhibition_record: ["exhibition_id", "date", "attendance"]
### What are the themes and years for exhibitions, sorted by ticket price descending?
SELECT theme,YEAR FROM exhibition ORDER BY ticket_price DESC; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the id of the item whose title is "orange".
SELECT i_id FROM item WHERE title = "orange"; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### List all information in the item table.
SELECT * FROM item; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the number of reviews.
SELECT count(*) FROM review; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### How many users are there?
SELECT count(*) FROM useracct; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the average and maximum rating of all reviews.
SELECT avg(rating),max(rating) FROM review; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the highest rank of all reviews.
SELECT min(rank) FROM review; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### How many different users wrote some reviews?
SELECT count(DISTINCT u_id) FROM review; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### How many different items were reviewed by some users?
SELECT count(DISTINCT i_id) FROM review; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the number of items that did not receive any review.
SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review); ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the names of users who did not leave any review.
SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review); ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### List the titles of all items in alphabetic order .
SELECT title FROM item ORDER BY title; ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the names of the items that did not receive any review.
SELECT title FROM item WHERE i_id NOT IN (SELECT i_id FROM review); ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the names of users who did not leave any review.
SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review); ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the number of users who did not write any review.
SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review); ###
###Postgre SQL tables, with their properties:
# item: ["item_id", "title"]
# review: ["a_id", "user_id", "item_id", "rating", "rank"]
# useracct: ["user_id", "name"]
# trust: ["source_user_id", "target_user_id", "trust"]
### Find the number of items without any review.
SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review); ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### How many players are there?
SELECT count(*) FROM player; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### List the names of players in ascending order of votes.
SELECT Player_name FROM player ORDER BY Votes ASC; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### What are the gender and occupation of players?
SELECT Gender,Occupation FROM player; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### List the name and residence for players whose occupation is not "Researcher".
SELECT Player_name,residence FROM player WHERE Occupation != "Researcher"; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### Show the names of sponsors of players whose residence is either "Brandon" or "Birtle".
SELECT Sponsor_name FROM player WHERE Residence = "Brandon" OR Residence = "Birtle"; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### What is the name of the player with the largest number of votes?
SELECT Player_name FROM player ORDER BY Votes DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### Show different occupations along with the number of players in each occupation.
SELECT Occupation,COUNT(*) FROM player GROUP BY Occupation; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### Please show the most common occupation of players.
SELECT Occupation FROM player GROUP BY Occupation ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### Show the residences that have at least two players.
SELECT Residence FROM player GROUP BY Residence HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### List the names of players that do not have coaches.
SELECT Player_name FROM player WHERE Player_ID NOT IN (SELECT Player_ID FROM player_coach); ###
###Postgre SQL tables, with their properties:
# player: ["player_id", "sponsor_name", "player_name", "gender", "residence", "occupation", "votes", "rank"]
# club: ["club_id", "club_name", "region", "start_year"]
# coach: ["coach_id", "player_name", "gender", "club_id", "rank"]
# player_coach: ["player_id", "coach_id", "starting_year"]
# match_result: ["rank", "club_id", "gold", "big_silver", "small_silver", "bronze", "points"]
### Show the residences that have both a player of gender "M" and a player of gender "F".
SELECT Residence FROM player WHERE gender = "M" INTERSECT SELECT Residence FROM player WHERE gender = "F"; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### How many gymnasts are there?
SELECT count(*) FROM gymnast; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### Count the number of gymnasts.
SELECT count(*) FROM gymnast; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### List the total points of gymnasts in descending order.
SELECT Total_Points FROM gymnast ORDER BY Total_Points DESC; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### What are the total points for all gymnasts, ordered by total points descending?
SELECT Total_Points FROM gymnast ORDER BY Total_Points DESC; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### List the total points of gymnasts in descending order of floor exercise points.
SELECT Total_Points FROM gymnast ORDER BY Floor_Exercise_Points DESC; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### What are the total points of gymnasts, ordered by their floor exercise points descending?
SELECT Total_Points FROM gymnast ORDER BY Floor_Exercise_Points DESC; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### What is the average horizontal bar points for all gymnasts?
SELECT avg(Horizontal_Bar_Points) FROM gymnast; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### Return the average horizontal bar points across all gymnasts.
SELECT avg(Horizontal_Bar_Points) FROM gymnast; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### What are the names of people in ascending alphabetical order?
SELECT Name FROM People ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### Return the names of people, ordered alphabetically.
SELECT Name FROM People ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### What is the age of the tallest person?
SELECT Age FROM people ORDER BY Height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### Return the age of the person with the greatest height.
SELECT Age FROM people ORDER BY Height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### List the names of the top 5 oldest people.
SELECT Name FROM People ORDER BY Age DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### What are the names of the five oldest people?
SELECT Name FROM People ORDER BY Age DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### Show the hometowns shared by people older than 23 and younger than 20.
SELECT Hometown FROM people WHERE Age > 23 INTERSECT SELECT Hometown FROM people WHERE Age < 20; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### From which hometowns did both people older than 23 and younger than 20 come from?
SELECT Hometown FROM people WHERE Age > 23 INTERSECT SELECT Hometown FROM people WHERE Age < 20; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### How many distinct hometowns did these people have?
SELECT count(DISTINCT Hometown) FROM people; ###
###Postgre SQL tables, with their properties:
# gymnast: ["gymnast_id", "floor_exercise_points", "pommel_horse_points", "rings_points", "vault_points", "parallel_bars_points", "horizontal_bar_points", "total_points"]
# people: ["people_id", "name", "age", "height", "hometown"]
### Count the number of different hometowns of these people.
SELECT count(DISTINCT Hometown) FROM people; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### How many accounts are there in total?
SELECT count(*) FROM accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### Count the number of accounts.
SELECT count(*) FROM accounts; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### What is the total checking balance in all accounts?
SELECT sum(balance) FROM checking; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### Find the total balance across checking accounts.
SELECT sum(balance) FROM checking; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### Find the average checking balance.
SELECT avg(balance) FROM checking; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### What is the average balance in checking accounts?
SELECT avg(balance) FROM checking; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### How many accounts have a savings balance above the average savings balance?
SELECT count(*) FROM savings WHERE balance > (SELECT avg(balance) FROM savings); ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### Find the number of accounts with a savings balance that is higher than the average savings balance.
SELECT count(*) FROM savings WHERE balance > (SELECT avg(balance) FROM savings); ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### List all customers’ names in the alphabetical order.
SELECT name FROM accounts ORDER BY name; ###
###Postgre SQL tables, with their properties:
# accounts: ["customer_id", "name"]
# savings: ["customer_id", "balance"]
# checking: ["customer_id", "balance"]
### What are the names of all the customers in alphabetical order?
SELECT name FROM accounts ORDER BY name; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### How many main stream browsers whose market share is at least 5 exist?
SELECT count(*) FROM browser WHERE market_share >= 5; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### List the name of browsers in descending order by market share.
SELECT name FROM browser ORDER BY market_share DESC; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### List the ids, names and market shares of all browsers.
SELECT id,name,market_share FROM browser; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### What is the maximum, minimum and average market share of the listed browsers?
SELECT max(market_share),min(market_share),avg(market_share) FROM browser; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### What is the id and market share of the browser Safari?
SELECT id,market_share FROM browser WHERE name = 'Safari'; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### What are the name and os of web client accelerators that do not work with only a 'Broadband' type connection?
SELECT name,operating_system FROM web_client_accelerator WHERE CONNECTION != 'Broadband'; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### How many different kinds of clients are supported by the web clients accelerators?
SELECT count(DISTINCT client) FROM web_client_accelerator; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### How many accelerators are not compatible with the browsers listed?
SELECT count(*) FROM web_client_accelerator WHERE id NOT IN ( SELECT accelerator_id FROM accelerator_compatible_browser );; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### Which accelerator name contains substring "Opera"?
SELECT name FROM web_client_accelerator WHERE name LIKE "%Opera%"; ###
###Postgre SQL tables, with their properties:
# web_client_accelerator: ["id", "name", "operating_system", "client", "connection"]
# browser: ["id", "name", "market_share"]
# accelerator_compatible_browser: ["accelerator_id", "browser_id", "compatible_since_year"]
### Find the number of web accelerators used for each Operating system.
SELECT Operating_system,count(*) FROM web_client_accelerator GROUP BY Operating_system; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### How many wrestlers are there?
SELECT count(*) FROM wrestler; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Count the number of wrestlers.
SELECT count(*) FROM wrestler; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### List the names of wrestlers in descending order of days held.
SELECT Name FROM wrestler ORDER BY Days_held DESC; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the names of the wrestlers, ordered descending by days held?
SELECT Name FROM wrestler ORDER BY Days_held DESC; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What is the name of the wrestler with the fewest days held?
SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Return the name of the wrestler who had the lowest number of days held.
SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the distinct reigns of wrestlers whose location is not "Tokyo,Japan"?
SELECT DISTINCT Reign FROM wrestler WHERE LOCATION != "Tokyo,Japan"; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Give the different reigns of wrestlers who are not located in Tokyo, Japan.
SELECT DISTINCT Reign FROM wrestler WHERE LOCATION != "Tokyo,Japan"; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the names and location of the wrestlers?
SELECT Name,LOCATION FROM wrestler; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Give the names and locations of all wrestlers.
SELECT Name,LOCATION FROM wrestler; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the elimination moves of wrestlers whose team is "Team_Orton"?
SELECT Elimination_Move FROM Elimination WHERE Team = "Team_Orton"; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Return the elimination movies of wrestlers on Team Orton.
SELECT Elimination_Move FROM Elimination WHERE Team = "Team_Orton"; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Show different teams in eliminations and the number of eliminations from each team.
SELECT Team,COUNT(*) FROM elimination GROUP BY Team; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### How many eliminations did each team have?
SELECT Team,COUNT(*) FROM elimination GROUP BY Team; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Show teams that have suffered more than three eliminations.
SELECT Team FROM elimination GROUP BY Team HAVING COUNT(*) > 3; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Which teams had more than 3 eliminations?
SELECT Team FROM elimination GROUP BY Team HAVING COUNT(*) > 3; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Show the reign and days held of wrestlers.
SELECT Reign,Days_held FROM wrestler; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the reigns and days held of all wrestlers?
SELECT Reign,Days_held FROM wrestler; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the names of wrestlers days held less than 100?
SELECT Name FROM wrestler WHERE Days_held < 100; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Return the names of wrestlers with fewer than 100 days held.
SELECT Name FROM wrestler WHERE Days_held < 100; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Please show the most common reigns of wrestlers.
SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Which reign is the most common among wrestlers?
SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### List the locations that are shared by more than two wrestlers.
SELECT LOCATION FROM wrestler GROUP BY LOCATION HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Which locations are shared by more than two wrestlers?
SELECT LOCATION FROM wrestler GROUP BY LOCATION HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### List the names of wrestlers that have not been eliminated.
SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM elimination); ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the names of wrestlers who have never been eliminated?
SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM elimination); ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Show the teams that have both wrestlers eliminated by "Orton" and wrestlers eliminated by "Benjamin".
SELECT Team FROM Elimination WHERE Eliminated_By = "Orton" INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By = "Benjamin"; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the teams that have both wrestlers eliminated by Orton and wrestlers eliminated by Benjamin?
SELECT Team FROM Elimination WHERE Eliminated_By = "Orton" INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By = "Benjamin"; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What is the number of distinct teams that suffer elimination?
SELECT COUNT (DISTINCT team) FROM elimination; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### How many different teams have had eliminated wrestlers?
SELECT COUNT (DISTINCT team) FROM elimination; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### Show the times of elimination by "Punk" or "Orton".
SELECT TIME FROM elimination WHERE Eliminated_By = "Punk" OR Eliminated_By = "Orton"; ###
###Postgre SQL tables, with their properties:
# wrestler: ["wrestler_id", "name", "reign", "days_held", "location", "event"]
# elimination: ["elimination_id", "wrestler_id", "team", "eliminated_by", "elimination_move", "time"]
### What are the times of elimination for any instances in which the elimination was done by Punk or Orton?
SELECT TIME FROM elimination WHERE Eliminated_By = "Punk" OR Eliminated_By = "Orton"; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### How many schools are there?
SELECT count(*) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Count the number of schools.
SELECT count(*) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Show all school names in alphabetical order.
SELECT school_name FROM school ORDER BY school_name; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### List the name, location, mascot for all schools.
SELECT school_name,LOCATION,mascot FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### What are the total and average enrollment of all schools?
SELECT sum(enrollment),avg(enrollment) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### What are the mascots for schools with enrollments above the average?
SELECT mascot FROM school WHERE enrollment > (SELECT avg(enrollment) FROM school); ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### List the name of the school with the smallest enrollment.
SELECT school_name FROM school ORDER BY enrollment LIMIT 1; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Show the average, maximum, minimum enrollment of all schools.
SELECT avg(enrollment),max(enrollment),min(enrollment) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Show each county along with the number of schools and total enrollment in each county.
SELECT county,count(*),sum(enrollment) FROM school GROUP BY county; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### List each donator name and the amount of endowment in descending order of the amount of endowment.
SELECT donator_name,sum(amount) FROM endowment GROUP BY donator_name ORDER BY sum(amount) DESC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### List the names of the schools without any endowment.
SELECT school_name FROM school WHERE school_id NOT IN (SELECT school_id FROM endowment); ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Show the names of all the donors except those whose donation amount less than 9.
SELECT donator_name FROM endowment EXCEPT SELECT donator_name FROM endowment WHERE amount < 9; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### List the amount and donor name for the largest amount of donation.
SELECT amount,donator_name FROM endowment ORDER BY amount DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### How many budgets are above 3000 in year 2001 or before?
SELECT count(*) FROM budget WHERE budgeted > 3000 AND YEAR <= 2001; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Count the number of budgets in year 2001 or before whose budgeted amount is greater than 3000
SELECT count(*) FROM budget WHERE budgeted > 3000 AND YEAR <= 2001; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Show all donor names.
SELECT DISTINCT donator_name FROM endowment; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### How many budget record has a budget amount smaller than the invested amount?
SELECT count(*) FROM budget WHERE budgeted < invested; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school_name", "location", "mascot", "enrollment", "ihsaa_class", "ihsaa_football_class", "county"]
# budget: ["school_id", "year", "budgeted", "total_budget_percent_budgeted", "invested", "total_budget_percent_invested", "budget_invested_percent"]
# endowment: ["endowment_id", "school_id", "donator_name", "amount"]
### Find the number of schools that have more than one donator whose donation amount is less than 8.5.
SELECT count(*) FROM (SELECT * FROM endowment WHERE amount > 8.5 GROUP BY school_id HAVING count(*) > 1); ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### How many buildings are there?
SELECT count(*) FROM building; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show the name, street address, and number of floors for all buildings ordered by the number of floors.
SELECT name,street_address,floors FROM building ORDER BY floors; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### What is the name of the tallest building?
SELECT name FROM building ORDER BY height_feet DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### What are the average, maximum, and minimum number of floors for all buildings?
SELECT avg(floors),max(floors),min(floors) FROM building; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show the number of buildings with a height above the average or a number of floors above the average.
SELECT count(*) FROM building WHERE height_feet > (SELECT avg(height_feet) FROM building) OR floors > (SELECT avg(floors) FROM building); ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### List the names of buildings with at least 200 feet of height and with at least 20 floors.
SELECT name FROM building WHERE height_feet >= 200 AND floors >= 20; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show the names and locations of institutions that are founded after 1990 and have the type "Private".
SELECT institution,LOCATION FROM institution WHERE founded > 1990 AND TYPE = 'Private'; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show institution types, along with the number of institutions and total enrollment for each type.
SELECT TYPE,count(*),sum(enrollment) FROM institution GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show the institution type with the largest number of institutions.
SELECT TYPE FROM institution GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show the institution type with an institution founded after 1990 and an institution with at least 1000 enrollment.
SELECT TYPE FROM institution WHERE founded > 1990 AND enrollment >= 1000; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show the name of buildings that do not have any institution.
SELECT name FROM building WHERE building_id NOT IN (SELECT building_id FROM institution); ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### Show all the distinct institution types.
SELECT DISTINCT TYPE FROM institution; ###
###Postgre SQL tables, with their properties:
# building: ["building_id", "name", "street_address", "years_as_tallest", "height_feet", "floors"]
# institution: ["institution_id", "institution", "location", "founded", "type", "enrollment", "team", "primary_conference", "building_id"]
# protein: ["common_name", "protein_name", "divergence_from_human_lineage", "accession_number", "sequence_length", "sequence_identity_to_human_protein", "institution_id"]
### How many institutions do not have an associated protein in our record?
SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein); ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show all the locations where no cinema has capacity over 800.
SELECT LOCATION FROM cinema EXCEPT SELECT LOCATION FROM cinema WHERE capacity > 800; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show all the locations where some cinemas were opened in both year 2010 and year 2011.
SELECT LOCATION FROM cinema WHERE openning_year = 2010 INTERSECT SELECT LOCATION FROM cinema WHERE openning_year = 2011; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### How many cinema do we have?
SELECT count(*) FROM cinema; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Count the number of cinemas.
SELECT count(*) FROM cinema; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show name, opening year, and capacity for each cinema.
SELECT name,openning_year,capacity FROM cinema; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show the cinema name and location for cinemas with capacity above average.
SELECT name,LOCATION FROM cinema WHERE capacity > (SELECT avg(capacity) FROM cinema); ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### What are all the locations with a cinema?
SELECT DISTINCT LOCATION FROM cinema; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Find the distinct locations that has a cinema.
SELECT DISTINCT LOCATION FROM cinema; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show all the cinema names and opening years in descending order of opening year.
SELECT name,openning_year FROM cinema ORDER BY openning_year DESC; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### What are the name and location of the cinema with the largest capacity?
SELECT name,LOCATION FROM cinema ORDER BY capacity DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show the average, minimum, and maximum capacity for all the cinemas opened in year 2011 or later.
SELECT avg(capacity),min(capacity),max(capacity) FROM cinema WHERE openning_year >= 2011; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show each location and the number of cinemas there.
SELECT LOCATION,count(*) FROM cinema GROUP BY LOCATION; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### What is the location with the most cinemas opened in year 2010 or later?
SELECT LOCATION FROM cinema WHERE openning_year >= 2010 GROUP BY LOCATION ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show all the locations with at least two cinemas with capacity above 300.
SELECT LOCATION FROM cinema WHERE capacity > 300 GROUP BY LOCATION HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Which locations have 2 or more cinemas with capacity over 300?
SELECT LOCATION FROM cinema WHERE capacity > 300 GROUP BY LOCATION HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show the title and director for all films.
SELECT title,directed_by FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### What are the title and director of each film?
SELECT title,directed_by FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Show all directors.
SELECT DISTINCT directed_by FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Who are all the directors?
SELECT DISTINCT directed_by FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### List all directors along with the number of films directed by each director.
SELECT directed_by,count(*) FROM film GROUP BY directed_by; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### What are the title and director of the films without any schedule?
SELECT title,directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule); ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Find the locations that have more than one movie theater with capacity above 300.
SELECT LOCATION FROM cinema WHERE capacity > 300 GROUP BY LOCATION HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### In which locations are there more than one movie theater with capacity above 300?
SELECT LOCATION FROM cinema WHERE capacity > 300 GROUP BY LOCATION HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### How many films have the word 'Dummy' in their titles?
SELECT count(*) FROM film WHERE title LIKE "%Dummy%"; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "rank_in_series", "number_in_season", "title", "directed_by", "original_air_date", "production_code"]
# cinema: ["cinema_id", "name", "openning_year", "capacity", "location"]
# schedule: ["cinema_id", "film_id", "date", "show_times_per_day", "price"]
### Count the number of films whose title contains the word 'Dummy'.
SELECT count(*) FROM film WHERE title LIKE "%Dummy%"; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What is the maximum total amount paid by a customer? List the customer id and amount.
SELECT customer_id,sum(amount_paid) FROM Payments GROUP BY customer_id ORDER BY sum(amount_paid) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What is the id of the product that is booked for 3 times?
SELECT product_id FROM products_booked GROUP BY product_id HAVING count(*) = 3; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### How many different product types are there?
SELECT count(DISTINCT product_type_code) FROM products_for_hire; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What are the first name, last name, and gender of all the good customers? Order by their last name.
SELECT first_name,last_name,gender_mf FROM customers WHERE good_or_bad_customer = 'good' ORDER BY last_name; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What is the average amount due for all the payments?
SELECT avg(amount_due) FROM payments; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What are the maximum, minimum, and average booked count for the products booked?
SELECT max(booked_count),min(booked_count),avg(booked_count) FROM products_booked; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What are all the distinct payment types?
SELECT DISTINCT payment_type_code FROM payments; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What are the daily hire costs for the products with substring 'Book' in its name?
SELECT daily_hire_cost FROM Products_for_hire WHERE product_name LIKE '%Book%'; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### How many products are never booked with amount higher than 200?
SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount > 200 ); ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What are the payment date of the payment with amount paid higher than 300 or with payment type is 'Check'
SELECT payment_date FROM payments WHERE amount_paid > 300 OR payment_type_code = 'Check'; ###
###Postgre SQL tables, with their properties:
# discount_coupons: ["coupon_id", "date_issued", "coupon_amount"]
# customers: ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender", "date_became_customer", "date_last_hire"]
# bookings: ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yes_or_no", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"]
# products_for_hire: ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"]
# payments: ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"]
# products_booked: ["booking_id", "product_id", "returned_yes_or_no", "returned_late_yes_or_no", "booked_count", "booked_amount"]
# view_product_availability: ["product_id", "booking_id", "status_date", "available_yes_or_no"]
### What are the names and descriptions of the products that are of 'Cutlery' type and have daily hire cost lower than 20?
SELECT product_name,product_description FROM products_for_hire WHERE product_type_code = 'Cutlery' AND daily_hire_cost < 20; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### How many phones are there?
SELECT count(*) FROM phone; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### List the names of phones in ascending order of price.
SELECT Name FROM phone ORDER BY Price ASC; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### What are the memories and carriers of phones?
SELECT Memory_in_G,Carrier FROM phone; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### List the distinct carriers of phones with memories bigger than 32.
SELECT DISTINCT Carrier FROM phone WHERE Memory_in_G > 32; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### Show the names of phones with carrier either "Sprint" or "TMobile".
SELECT Name FROM phone WHERE Carrier = "Sprint" OR Carrier = "TMobile"; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### What is the carrier of the most expensive phone?
SELECT Carrier FROM phone ORDER BY Price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### Show different carriers of phones together with the number of phones with each carrier.
SELECT Carrier,COUNT(*) FROM phone GROUP BY Carrier; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### Show the most frequently used carrier of the phones.
SELECT Carrier FROM phone GROUP BY Carrier ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### Show the carriers that have both phones with memory smaller than 32 and phones with memory bigger than 64.
SELECT Carrier FROM phone WHERE Memory_in_G < 32 INTERSECT SELECT Carrier FROM phone WHERE Memory_in_G > 64; ###
###Postgre SQL tables, with their properties:
# phone: ["name", "phone_id", "memory_in_g", "carrier", "price"]
# market: ["market_id", "district", "num_of_employees", "num_of_shops", "ranking"]
# phone_market: ["market_id", "phone_id", "num_of_stock"]
### List the names of phones that are not on any market.
SELECT Name FROM phone WHERE Phone_id NOT IN (SELECT Phone_ID FROM phone_market); ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### How many gas companies are there?
SELECT count(*) FROM company; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What is the total number of companies?
SELECT count(*) FROM company; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### List the company name and rank for all companies in the decreasing order of their sales.
SELECT company,rank FROM company ORDER BY Sales_billion DESC; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What is the name and rank of every company ordered by descending number of sales?
SELECT company,rank FROM company ORDER BY Sales_billion DESC; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show the company name and the main industry for all companies whose headquarters are not from USA.
SELECT company,main_industry FROM company WHERE headquarters != 'USA'; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the companies and main industries of all companies that are not headquartered in the United States?
SELECT company,main_industry FROM company WHERE headquarters != 'USA'; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show all company names and headquarters in the descending order of market value.
SELECT company,headquarters FROM company ORDER BY market_value DESC; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the names and headquarters of all companies ordered by descending market value?
SELECT company,headquarters FROM company ORDER BY market_value DESC; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show minimum, maximum, and average market value for all companies.
SELECT min(market_value),max(market_value),avg(market_value) FROM company; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What is the minimum, maximum, and average market value for every company?
SELECT min(market_value),max(market_value),avg(market_value) FROM company; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show all main industry for all companies.
SELECT DISTINCT main_industry FROM company; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the different main industries for all companies?
SELECT DISTINCT main_industry FROM company; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### List all headquarters and the number of companies in each headquarter.
SELECT headquarters,count(*) FROM company GROUP BY headquarters; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### For each headquarter, what are the headquarter and how many companies are centered there?
SELECT headquarters,count(*) FROM company GROUP BY headquarters; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show all main industry and total market value in each industry.
SELECT main_industry,sum(market_value) FROM company GROUP BY main_industry; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the main indstries and total market value for each industry?
SELECT main_industry,sum(market_value) FROM company GROUP BY main_industry; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### List the main industry with highest total market value and its number of companies.
SELECT main_industry,count(*) FROM company GROUP BY main_industry ORDER BY sum(market_value) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### For each main industry, what is the total number of companies for the industry with the highest total market value?
SELECT main_industry,count(*) FROM company GROUP BY main_industry ORDER BY sum(market_value) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show headquarters with at least two companies in the banking industry.
SELECT headquarters FROM company WHERE main_industry = 'Banking' GROUP BY headquarters HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the headquarters with at least two companies in the banking industry?
SELECT headquarters FROM company WHERE main_industry = 'Banking' GROUP BY headquarters HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show gas station id, location, and manager_name for all gas stations ordered by open year.
SELECT station_id,LOCATION,manager_name FROM gas_station ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the gas station ids, locations, and manager names for the gas stations ordered by opening year?
SELECT station_id,LOCATION,manager_name FROM gas_station ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### How many gas station are opened between 2000 and 2005?
SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What is the total number of gas stations that opened between 2000 and 2005?
SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show all locations and the number of gas stations in each location ordered by the count.
SELECT LOCATION,count(*) FROM gas_station GROUP BY LOCATION ORDER BY count(*); ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### For each location, how many gas stations are there in order?
SELECT LOCATION,count(*) FROM gas_station GROUP BY LOCATION ORDER BY count(*); ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show all headquarters with both a company in banking industry and a company in Oil and gas.
SELECT headquarters FROM company WHERE main_industry = 'Banking' INTERSECT SELECT headquarters FROM company WHERE main_industry = 'Oil and gas'; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the headquarters that have both a company in the banking and 'oil and gas' industries?
SELECT headquarters FROM company WHERE main_industry = 'Banking' INTERSECT SELECT headquarters FROM company WHERE main_industry = 'Oil and gas'; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show all headquarters without a company in banking industry.
SELECT headquarters FROM company EXCEPT SELECT headquarters FROM company WHERE main_industry = 'Banking'; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the headquarters without companies that are in the banking industry?
SELECT headquarters FROM company EXCEPT SELECT headquarters FROM company WHERE main_industry = 'Banking'; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show company name and main industry without a gas station.
SELECT company,main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company); ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the main industries of the companies without gas stations and what are the companies?
SELECT company,main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company); ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### Show the manager name with most number of gas stations opened after 2000.
SELECT manager_name FROM gas_station WHERE open_year > 2000 GROUP BY manager_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What is the name of the manager with the most gas stations that opened after 2000?
SELECT manager_name FROM gas_station WHERE open_year > 2000 GROUP BY manager_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### order all gas station locations by the opening year.
SELECT LOCATION FROM gas_station ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What are the locations of all the gas stations ordered by opening year?
SELECT LOCATION FROM gas_station ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### find the rank, company names, market values of the companies in the banking industry order by their sales and profits in billion.
SELECT rank,company,market_value FROM company WHERE main_industry = 'Banking' ORDER BY sales_billion,profits_billion; ###
###Postgre SQL tables, with their properties:
# company: ["company_id", "rank", "company", "headquarters", "main_industry", "sales_billion", "profits_billion", "assets_billion", "market_value"]
# gas_station: ["station_id", "open_year", "location", "manager_name", "vice_manager_name", "representative_name"]
# station_company: ["station_id", "company_id", "rank_of_the_year"]
### What is the rank, company, and market value of every comapny in the banking industry ordered by sales and profits?
SELECT rank,company,market_value FROM company WHERE main_industry = 'Banking' ORDER BY sales_billion,profits_billion; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### How many regions do we have?
SELECT count(*) FROM region; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Count the number of regions.
SELECT count(*) FROM region; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Show all distinct region names ordered by their labels.
SELECT DISTINCT region_name FROM region ORDER BY Label; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### What are the different region names, ordered by labels?
SELECT DISTINCT region_name FROM region ORDER BY Label; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### How many parties do we have?
SELECT count(DISTINCT party_name) FROM party; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Count the number of different parties.
SELECT count(DISTINCT party_name) FROM party; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Show the ministers and the time they took and left office, listed by the time they left office.
SELECT minister,took_office,left_office FROM party ORDER BY left_office; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Who are the ministers, when did they take office, and when did they leave office, ordered by when they left office?
SELECT minister,took_office,left_office FROM party ORDER BY left_office; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Show the minister who took office after 1961 or before 1959.
SELECT minister FROM party WHERE took_office > 1961 OR took_office < 1959; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Who are the ministers who took office after 1961 or before 1959?
SELECT minister FROM party WHERE took_office > 1961 OR took_office < 1959; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Show all ministers who do not belong to Progress Party.
SELECT minister FROM party WHERE party_name != 'Progress Party'; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Which ministers are not a part of the Progress Party?
SELECT minister FROM party WHERE party_name != 'Progress Party'; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Show all ministers and parties they belong to in descending order of the time they took office.
SELECT minister,party_name FROM party ORDER BY took_office DESC; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Who are the ministers and what parties do they belong to, listed descending by the times they took office?
SELECT minister,party_name FROM party ORDER BY took_office DESC; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Return the minister who left office at the latest time.
SELECT minister FROM party ORDER BY left_office DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Which minister left office the latest?
SELECT minister FROM party ORDER BY left_office DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Show names of parties that does not have any members.
SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member); ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### What are the names of parties that have no members?
SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member); ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Show the member names which are in both the party with id 3 and the party with id 1.
SELECT member_name FROM member WHERE party_id = 3 INTERSECT SELECT member_name FROM member WHERE party_id = 1; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Which member names are shared among members in the party with the id 3 and the party with the id 1?
SELECT member_name FROM member WHERE party_id = 3 INTERSECT SELECT member_name FROM member WHERE party_id = 1; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### How many party events do we have?
SELECT count(*) FROM party_events; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Count the number of party events.
SELECT count(*) FROM party_events; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### find the event names that have more than 2 records.
SELECT event_name FROM party_events GROUP BY event_name HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# region: ["region_id", "region_name", "date", "label", "format", "catalogue"]
# party: ["party_id", "minister", "took_office", "left_office", "region_id", "party_name"]
# member: ["member_id", "member_name", "party_id", "in_office"]
# party_events: ["event_id", "event_name", "party_id", "member_in_charge_id"]
### Which event names were used more than twice for party events?
SELECT event_name FROM party_events GROUP BY event_name HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### How many pilots are there?
SELECT count(*) FROM pilot; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### List the names of pilots in ascending order of rank.
SELECT Pilot_name FROM pilot ORDER BY Rank ASC; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### What are the positions and teams of pilots?
SELECT POSITION,Team FROM pilot; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### List the distinct positions of pilots older than 30.
SELECT DISTINCT POSITION FROM pilot WHERE Age > 30; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### Show the names of pilots from team "Bradley" or "Fordham".
SELECT Pilot_name FROM pilot WHERE Team = "Bradley" OR Team = "Fordham"; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### What is the joined year of the pilot of the highest rank?
SELECT Join_Year FROM pilot ORDER BY Rank ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### What are the different nationalities of pilots? Show each nationality and the number of pilots of each nationality.
SELECT Nationality,COUNT(*) FROM pilot GROUP BY Nationality; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### Show the most common nationality of pilots.
SELECT Nationality FROM pilot GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### Show the pilot positions that have both pilots joining after year 2005 and pilots joining before 2000.
SELECT POSITION FROM pilot WHERE Join_Year	 < 2000 INTERSECT SELECT POSITION FROM pilot WHERE Join_Year	 > 2005; ###
###Postgre SQL tables, with their properties:
# aircraft: ["aircraft_id", "order_year", "manufacturer", "model", "fleet_series", "powertrain", "fuel_propulsion"]
# pilot: ["pilot_id", "pilot_name", "rank", "age", "nationality", "position", "join_year", "team"]
# pilot_record: ["record_id", "pilot_id", "aircraft_id", "date"]
### List the names of pilots that do not have any record.
SELECT Pilot_name FROM pilot WHERE Pilot_ID NOT IN (SELECT Pilot_ID FROM pilot_record); ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What document status codes do we have?
SELECT document_status_code FROM Ref_Document_Status;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What is the description of document status code 'working'?
SELECT document_status_description FROM Ref_Document_Status WHERE document_status_code = "working";; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What document type codes do we have?
SELECT document_type_code FROM Ref_Document_Types;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What is the description of document type 'Paper'?
SELECT document_type_description FROM Ref_Document_Types WHERE document_type_code = "Paper";; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What are the shipping agent names?
SELECT shipping_agent_name FROM Ref_Shipping_Agents;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What is the shipping agent code of shipping agent UPS?
SELECT shipping_agent_code FROM Ref_Shipping_Agents WHERE shipping_agent_name = "UPS";; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What are all role codes?
SELECT role_code FROM ROLES;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What is the description of role code ED?
SELECT role_description FROM ROLES WHERE role_code = "ED";; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### How many employees do we have?
SELECT count(*) FROM Employees;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### List all document ids and receipt dates of documents.
SELECT document_id,receipt_date FROM Documents;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### How many documents have the status code done?
SELECT count(*) FROM Documents WHERE document_status_code = "done";; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### List the document type code for the document with the id 2.
SELECT document_type_code FROM Documents WHERE document_id = 2;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### List the document ids for any documents with the status code done and the type code paper.
SELECT document_id FROM Documents WHERE document_status_code = "done" AND document_type_code = "Paper";; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What is the receipt date of the document with id 3?
SELECT receipt_date FROM Documents WHERE document_id = 3;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What is the mail date of the document with id 7?
SELECT mailing_date FROM Documents_Mailed WHERE document_id = 7;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### What is draft detail of the document with id 7?
SELECT draft_details FROM Document_Drafts WHERE document_id = 7;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### How many draft copies does the document with id 2 have?
SELECT count(*) FROM Draft_Copies WHERE document_id = 2;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### Which document has the most draft copies? List its document id and number of draft copies.
SELECT document_id,count(copy_number) FROM Draft_Copies GROUP BY document_id ORDER BY count(copy_number) DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### Which documents have more than 1 draft copies? List document id and number of draft copies.
SELECT document_id,count(*) FROM Draft_Copies GROUP BY document_id HAVING count(*) > 1;; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_description"]
# roles: ["role_code", "role_description"]
# addresses: ["address_id", "address_details"]
# reference_document_status: ["document_status_code", "document_status_description"]
# reference_shipping_agents: ["shipping_agent_code", "shipping_agent_name", "shipping_agent_description"]
# documents: ["document_id", "document_status_code", "document_type_code", "shipping_agent_code", "receipt_date", "receipt_number", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "other_details"]
# document_drafts: ["document_id", "draft_number", "draft_details"]
# draft_copies: ["document_id", "draft_number", "copy_number"]
# circulation_history: ["document_id", "draft_number", "copy_number", "employee_id"]
# documents_mailed: ["document_id", "mailed_to_address_id", "mailing_date"]
### For each document, list the number of employees who have showed up in the circulation history of that document. List the document ids and number of employees.
SELECT document_id,count(DISTINCT employee_id) FROM Circulation_History GROUP BY document_id;; ###
###Postgre SQL tables, with their properties:
# works_on: ["employee_ssn", "project_number", "hours"]
# employee: ["first_name", "minit", "last_name", "ssn", "birth_date", "address", "sex", "salary", "super_ssn", "department_no"]
# department: ["department_name", "department_number", "manager_ssn", "manager_start_date"]
# project: ["dependent_name", "dependent_number", "dependent_location", "department_number"]
# dependent: ["employee_ssn", "dependent_name", "sex", "birth_date", "relationship"]
# department_locations: ["department_number", "department_location"]
### List all department names ordered by their starting date.
SELECT dname FROM department ORDER BY mgr_start_date; ###
###Postgre SQL tables, with their properties:
# works_on: ["employee_ssn", "project_number", "hours"]
# employee: ["first_name", "minit", "last_name", "ssn", "birth_date", "address", "sex", "salary", "super_ssn", "department_no"]
# department: ["department_name", "department_number", "manager_ssn", "manager_start_date"]
# project: ["dependent_name", "dependent_number", "dependent_location", "department_number"]
# dependent: ["employee_ssn", "dependent_name", "sex", "birth_date", "relationship"]
# department_locations: ["department_number", "department_location"]
### find all dependent names who have a spouse relation with some employee.
SELECT Dependent_name FROM dependent WHERE relationship = 'Spouse'; ###
###Postgre SQL tables, with their properties:
# works_on: ["employee_ssn", "project_number", "hours"]
# employee: ["first_name", "minit", "last_name", "ssn", "birth_date", "address", "sex", "salary", "super_ssn", "department_no"]
# department: ["department_name", "department_number", "manager_ssn", "manager_start_date"]
# project: ["dependent_name", "dependent_number", "dependent_location", "department_number"]
# dependent: ["employee_ssn", "dependent_name", "sex", "birth_date", "relationship"]
# department_locations: ["department_number", "department_location"]
### how many female dependents are there?
SELECT count(*) FROM dependent WHERE sex = 'F'; ###
###Postgre SQL tables, with their properties:
# works_on: ["employee_ssn", "project_number", "hours"]
# employee: ["first_name", "minit", "last_name", "ssn", "birth_date", "address", "sex", "salary", "super_ssn", "department_no"]
# department: ["department_name", "department_number", "manager_ssn", "manager_start_date"]
# project: ["dependent_name", "dependent_number", "dependent_location", "department_number"]
# dependent: ["employee_ssn", "dependent_name", "sex", "birth_date", "relationship"]
# department_locations: ["department_number", "department_location"]
### Return the first names and last names of employees who earn more than 30000 in salary.
SELECT fname,lname FROM employee WHERE salary > 30000; ###
###Postgre SQL tables, with their properties:
# works_on: ["employee_ssn", "project_number", "hours"]
# employee: ["first_name", "minit", "last_name", "ssn", "birth_date", "address", "sex", "salary", "super_ssn", "department_no"]
# department: ["department_name", "department_number", "manager_ssn", "manager_start_date"]
# project: ["dependent_name", "dependent_number", "dependent_location", "department_number"]
# dependent: ["employee_ssn", "dependent_name", "sex", "birth_date", "relationship"]
# department_locations: ["department_number", "department_location"]
### Find the number of employees of each gender whose salary is lower than 50000.
SELECT count(*),sex FROM employee WHERE salary < 50000 GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# works_on: ["employee_ssn", "project_number", "hours"]
# employee: ["first_name", "minit", "last_name", "ssn", "birth_date", "address", "sex", "salary", "super_ssn", "department_no"]
# department: ["department_name", "department_number", "manager_ssn", "manager_start_date"]
# project: ["dependent_name", "dependent_number", "dependent_location", "department_number"]
# dependent: ["employee_ssn", "dependent_name", "sex", "birth_date", "relationship"]
# department_locations: ["department_number", "department_location"]
### list the first and last names, and the addresses of all employees in the ascending order of their birth date.
SELECT fname,lname,address FROM employee ORDER BY Bdate; ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### What are all the the participant ids, type code and details?
SELECT Participant_ID,Participant_Type_Code,Participant_Details FROM Participants; ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### How many participants belong to the type 'Organizer'?
SELECT count(*) FROM participants WHERE participant_type_code = 'Organizer'; ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### List the type of the services in alphabetical order.
SELECT service_type_code FROM services ORDER BY service_type_code; ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### List the service id and details for the events.
SELECT service_id,event_details FROM EVENTS; ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### What is the most common participant type?
SELECT participant_type_code FROM participants GROUP BY participant_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### What is the id of the event with the most participants?
SELECT Event_ID FROM Participants_in_Events GROUP BY Event_ID ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### How many events did not have any participants?
SELECT count(*) FROM EVENTS WHERE event_id NOT IN (SELECT event_id FROM Participants_in_Events); ###
###Postgre SQL tables, with their properties:
# services: ["service_id", "service_type_code"]
# participants: ["participant_id", "participant_type_code", "participant_details"]
# events: ["event_id", "service_id", "event_details"]
# participants_in_events: ["event_id", "participant_id"]
### What are all the distinct participant ids who attended any events?
SELECT count(DISTINCT participant_id) FROM participants_in_Events; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What is the name of the race held most recently?
SELECT name FROM races ORDER BY date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What is the name of the race that occurred most recently?
SELECT name FROM races ORDER BY date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What is the name and date of the most recent race?
SELECT name,date FROM races ORDER BY date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What is the name and date of the race that occurred most recently?
SELECT name,date FROM races ORDER BY date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### Find the names of all races held in 2017.
SELECT name FROM races WHERE YEAR = 2017; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the names of all the races that occurred in the year 2017?
SELECT name FROM races WHERE YEAR = 2017; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### Find the distinct names of all races held between 2014 and 2017?
SELECT DISTINCT name FROM races WHERE YEAR BETWEEN 2014 AND 2017; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the unique names of all race held between 2014 and 2017?
SELECT DISTINCT name FROM races WHERE YEAR BETWEEN 2014 AND 2017; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### How many drivers did not participate in the races held in 2009?
SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 ); ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### How many drivers did not race in 2009?
SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 ); ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### Find the forename and surname of drivers whose nationality is German?
SELECT forename,surname FROM drivers WHERE nationality = "German"; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What is the first and last name of all the German drivers?
SELECT forename,surname FROM drivers WHERE nationality = "German"; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the numbers of constructors for different nationalities?
SELECT count(*),nationality FROM constructors GROUP BY nationality; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### For each nationality, how many different constructors are there?
SELECT count(*),nationality FROM constructors GROUP BY nationality; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the numbers of races for each constructor id?
SELECT count(*),constructorid FROM constructorStandings GROUP BY constructorid; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### For each constructor id, how many races are there?
SELECT count(*),constructorid FROM constructorStandings GROUP BY constructorid; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### Find the distinct driver id and the stop number of all drivers that have a shorter pit stop duration than some drivers in the race with id 841.
SELECT DISTINCT driverid,STOP FROM pitstops WHERE duration < (SELECT max(duration) FROM pitstops WHERE raceid = 841); ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What is the id and stop number for each driver that has a shorter pit stop than the driver in the race with id 841?
SELECT DISTINCT driverid,STOP FROM pitstops WHERE duration < (SELECT max(duration) FROM pitstops WHERE raceid = 841); ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### Find the distinct driver id of all drivers that have a longer stop duration than some drivers in the race whose id is 841?
SELECT DISTINCT driverid,STOP FROM pitstops WHERE duration > (SELECT min(duration) FROM pitstops WHERE raceid = 841); ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the different ids and stop durations of all the drivers whose stop lasted longer than the driver in the race with the id 841?
SELECT DISTINCT driverid,STOP FROM pitstops WHERE duration > (SELECT min(duration) FROM pitstops WHERE raceid = 841); ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### List the forenames of all distinct drivers in alphabetical order?
SELECT DISTINCT forename FROM drivers ORDER BY forename ASC; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the first names of all the different drivers in alphabetical order?
SELECT DISTINCT forename FROM drivers ORDER BY forename ASC; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### List the names of all distinct races in reversed lexicographic order?
SELECT DISTINCT name FROM races ORDER BY name DESC; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the different names of all the races in reverse alphabetical order?
SELECT DISTINCT name FROM races ORDER BY name DESC; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the names of races held between 2009 and 2011?
SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the names of all races held between 2009 and 2011?
SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the names of races held after 12:00:00 or before 09:00:00?
SELECT name FROM races WHERE TIME > "12:00:00" OR TIME < "09:00:00"; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the names of all races that occurred after 12:00:00 or before 09:00:00?
SELECT name FROM races WHERE TIME > "12:00:00" OR TIME < "09:00:00"; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the names of circuits that belong to UK or Malaysia?
SELECT name FROM circuits WHERE country = "UK" OR country = "Malaysia"; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the names of all the circuits that are in the UK or Malaysia?
SELECT name FROM circuits WHERE country = "UK" OR country = "Malaysia"; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### Find the id and location of circuits that belong to France or Belgium?
SELECT circuitid,LOCATION FROM circuits WHERE country = "France" OR country = "Belgium"; ###
###Postgre SQL tables, with their properties:
# circuits: ["circuit_id", "circuit_reference", "name", "location", "country", "latitude", "longitude", "altitude", "url"]
# races: ["race_id", "year", "round", "circuit_id", "name", "date", "time", "url"]
# drivers: ["driver_id", "driver_reference", "number", "code", "forename", "surname", "dob", "nationality", "url"]
# status: ["status_id", "status"]
# seasons: ["year", "url"]
# constructors: ["constructor_id", "constructor_reference", "name", "nationality", "url"]
# constructor_standings: ["constructor_standings_id", "race_id", "constructor_id", "points", "position", "position_text", "wins"]
# results: ["result_id", "race_id", "driver_id", "constructor_id", "number", "grid", "position", "position_text", "position_order", "points", "laps", "time", "milliseconds", "fastest_lap", "rank", "fastest_lap_time", "fastest_lap_speed", "status_id"]
# driver_standings: ["driver_standings_id", "race_id", "driver_id", "points", "position", "position_text", "wins"]
# constructor_results: ["constructor_results_id", "race_id", "constructor_id", "points", "status"]
# qualifying: ["qualify_id", "race_id", "driver_id", "constructor_id", "number", "position", "q1", "q2", "q3"]
# pit_stops: ["race_id", "driver_id", "stop", "lap", "time", "duration", "milliseconds"]
# lap_times: ["race_id", "driver_id", "lap", "position", "time", "milliseconds"]
### What are the ids and locations of all circuits in France or Belgium?
SELECT circuitid,LOCATION FROM circuits WHERE country = "France" OR country = "Belgium"; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### How many technicians are there?
SELECT count(*) FROM technician; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What is the number of technicians?
SELECT count(*) FROM technician; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### List the names of technicians in ascending order of age.
SELECT Name FROM technician ORDER BY Age ASC; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What are the names of the technicians by ascending order of age?
SELECT Name FROM technician ORDER BY Age ASC; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What are the team and starting year of technicians?
SELECT Team,Starting_Year FROM technician; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What is the team and starting year for each technician?
SELECT Team,Starting_Year FROM technician; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### List the name of technicians whose team is not "NYY".
SELECT Name FROM technician WHERE Team != "NYY"; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What is the name of the technician whose team is not 'NYY'?
SELECT Name FROM technician WHERE Team != "NYY"; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### Show the name of technicians aged either 36 or 37
SELECT Name FROM technician WHERE Age = 36 OR Age = 37; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What are the names of the technicians aged either 36 or 37?
SELECT Name FROM technician WHERE Age = 36 OR Age = 37; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What is the starting year of the oldest technicians?
SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What is the starting year for the oldest technician?
SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### Show different teams of technicians and the number of technicians in each team.
SELECT Team,COUNT(*) FROM technician GROUP BY Team; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### For each team, how many technicians are there?
SELECT Team,COUNT(*) FROM technician GROUP BY Team; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### Please show the team that has the most number of technicians.
SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What are the teams with the most technicians?
SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### Show the team that have at least two technicians.
SELECT Team FROM technician GROUP BY Team HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What is the team with at least 2 technicians?
SELECT Team FROM technician GROUP BY Team HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### List the names of technicians who have not been assigned to repair machines.
SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment); ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What are the names of the technicians that have not been assigned to repair machines?
SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment); ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### Show the starting years shared by technicians from team "CLE" and "CWS".
SELECT Starting_Year FROM technician WHERE Team = "CLE" INTERSECT SELECT Starting_Year FROM technician WHERE Team = "CWS"; ###
###Postgre SQL tables, with their properties:
# repair: ["repair_id", "name", "launch_date", "notes"]
# machine: ["machine_id", "making_year", "class", "team", "machine_series", "value_points", "quality_rank"]
# technician: ["technician_id", "name", "team", "starting_year", "age"]
# repair_assignment: ["technician_id", "repair_id", "machine_id"]
### What are the starting years shared by the technicians from the team "CLE" or "CWS"?
SELECT Starting_Year FROM technician WHERE Team = "CLE" INTERSECT SELECT Starting_Year FROM technician WHERE Team = "CWS"; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### How many entrepreneurs are there?
SELECT count(*) FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Count the number of entrepreneurs.
SELECT count(*) FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### List the companies of entrepreneurs in descending order of money requested.
SELECT Company FROM entrepreneur ORDER BY Money_Requested DESC; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What are the companies of entrepreneurs, ordered descending by amount of money requested?
SELECT Company FROM entrepreneur ORDER BY Money_Requested DESC; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### List the companies and the investors of entrepreneurs.
SELECT Company,Investor FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What are the companies and investors that correspond to each entrepreneur?
SELECT Company,Investor FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What is the average money requested by all entrepreneurs?
SELECT avg(Money_Requested) FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Return the average money requested across all entrepreneurs.
SELECT avg(Money_Requested) FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What are the names of people in ascending order of weight?
SELECT Name FROM People ORDER BY Weight ASC; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Return the names of people, ordered by weight ascending.
SELECT Name FROM People ORDER BY Weight ASC; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What is the weight of the shortest person?
SELECT Weight FROM people ORDER BY Height ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Return the weight of the shortest person.
SELECT Weight FROM people ORDER BY Height ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What are the investors of entrepreneurs and the corresponding number of entrepreneurs invested by each investor?
SELECT Investor,COUNT(*) FROM entrepreneur GROUP BY Investor; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### How many entrepreneurs correspond to each investor?
SELECT Investor,COUNT(*) FROM entrepreneur GROUP BY Investor; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What is the investor that has invested in the most number of entrepreneurs?
SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Return the investor who have invested in the greatest number of entrepreneurs.
SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What are the investors that have invested in at least two entrepreneurs?
SELECT Investor FROM entrepreneur GROUP BY Investor HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Return the investors who have invested in two or more entrepreneurs.
SELECT Investor FROM entrepreneur GROUP BY Investor HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### List the names of people that are not entrepreneurs.
SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur); ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What are the names of people who are not entrepreneurs?
SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur); ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Show the investors shared by entrepreneurs that requested more than 140000 and entrepreneurs that requested less than 120000.
SELECT Investor FROM entrepreneur WHERE Money_Requested > 140000 INTERSECT SELECT Investor FROM entrepreneur WHERE Money_Requested < 120000; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### What are the investors who have invested in both entrepreneurs who requested more than 140000 and entrepreneurs who requested less than 120000?
SELECT Investor FROM entrepreneur WHERE Money_Requested > 140000 INTERSECT SELECT Investor FROM entrepreneur WHERE Money_Requested < 120000; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### How many distinct companies are there?
SELECT count(DISTINCT Company) FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# entrepreneur: ["entrepreneur_id", "people_id", "company", "money_requested", "investor"]
# people: ["people_id", "name", "height", "weight", "date_of_birth"]
### Count the number of different companies.
SELECT count(DISTINCT Company) FROM entrepreneur; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### How many perpetrators are there?
SELECT count(*) FROM perpetrator; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### List the date of perpetrators in descending order of the number of people killed.
SELECT Date FROM perpetrator ORDER BY Killed DESC; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### List the number of people injured by perpetrators in ascending order.
SELECT Injured FROM perpetrator ORDER BY Injured ASC; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### What is the average number of people injured by all perpetrators?
SELECT avg(Injured) FROM perpetrator; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### What is the location of the perpetrator with the largest kills.
SELECT LOCATION FROM perpetrator ORDER BY Killed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### What are the names of people in ascending order of height?
SELECT Name FROM People ORDER BY Height ASC; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### What are the countries of perpetrators? Show each country and the corresponding number of perpetrators there.
SELECT Country,COUNT(*) FROM perpetrator GROUP BY Country; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### What is the country that has the most perpetrators?
SELECT Country,COUNT(*) FROM perpetrator GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### What are the countries that have at least two perpetrators?
SELECT Country,COUNT(*) FROM perpetrator GROUP BY Country HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### List the names of people that are not perpetrators.
SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator); ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### Show the countries that have both perpetrators with injures more than 50 and perpetrators with injures smaller than 20.
SELECT Country FROM perpetrator WHERE Injured > 50 INTERSECT SELECT Country FROM perpetrator WHERE Injured < 20; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### How many distinct locations of perpetrators are there?
SELECT count(DISTINCT LOCATION) FROM perpetrator; ###
###Postgre SQL tables, with their properties:
# perpetrator: ["perpetrator_id", "people_id", "date", "year", "location", "country", "killed", "injured"]
# people: ["people_id", "name", "height", "weight", "home_town"]
### In which year did the most recent crime happen?
SELECT max(YEAR) FROM perpetrator;; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Report the name of all campuses in Los Angeles county.
SELECT campus FROM campuses WHERE county = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campuses are located in the county of Los Angeles?
SELECT campus FROM campuses WHERE county = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What are the names of all campuses located at Chico?
SELECT campus FROM campuses WHERE LOCATION = "Chico"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campuses are located in Chico?
SELECT campus FROM campuses WHERE LOCATION = "Chico"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Find all the campuses opened in 1958.
SELECT campus FROM campuses WHERE YEAR = 1958; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What are the campuses that opened in 1958?
SELECT campus FROM campuses WHERE YEAR = 1958; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Find the name of the campuses opened before 1800.
SELECT campus FROM campuses WHERE YEAR < 1800; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campuses opened before 1800?
SELECT campus FROM campuses WHERE YEAR < 1800; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Which campus was opened between 1935 and 1939?
SELECT campus FROM campuses WHERE YEAR >= 1935 AND YEAR <= 1939; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campuses opened between 1935 and 1939?
SELECT campus FROM campuses WHERE YEAR >= 1935 AND YEAR <= 1939; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.
SELECT campus FROM campuses WHERE LOCATION = "Northridge" AND county = "Los_Angeles" UNION SELECT campus FROM campuses WHERE LOCATION = "San_Francisco" AND county = "San_Francisco"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campuses are located in Northridge, Los Angeles or in San Francisco, San Francisco?
SELECT campus FROM campuses WHERE LOCATION = "Northridge" AND county = "Los_Angeles" UNION SELECT campus FROM campuses WHERE LOCATION = "San_Francisco" AND county = "San_Francisco"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Find the count of universities whose campus fee is greater than the average campus fee.
SELECT count(*) FROM csu_fees WHERE campusfee > (SELECT avg(campusfee) FROM csu_fees); ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### How many universities have a campus fee higher than average?
SELECT count(*) FROM csu_fees WHERE campusfee > (SELECT avg(campusfee) FROM csu_fees); ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Find the count of universities whose campus fee is greater than the average campus fee.
SELECT count(*) FROM csu_fees WHERE campusfee > (SELECT avg(campusfee) FROM csu_fees); ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### How many universities have a campus fee greater than the average?
SELECT count(*) FROM csu_fees WHERE campusfee > (SELECT avg(campusfee) FROM csu_fees); ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Which university is in Los Angeles county and opened after 1950?
SELECT campus FROM campuses WHERE county = "Los_Angeles" AND YEAR > 1950; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campuses are located in Los Angeles county and opened after 1950?
SELECT campus FROM campuses WHERE county = "Los_Angeles" AND YEAR > 1950; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Which year has the most degrees conferred?
SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### In what year was the most degrees conferred?
SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Which campus has the most degrees conferred in all times?
SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campus has the most degrees conferrred over its entire existence?
SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### Find the average fee on a CSU campus in 1996
SELECT avg(campusfee) FROM csu_fees WHERE YEAR = 1996; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What is the average fee for a CSU campus in the year of 1996?
SELECT avg(campusfee) FROM csu_fees WHERE YEAR = 1996; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What is the average fee on a CSU campus in 2005?
SELECT avg(campusfee) FROM csu_fees WHERE YEAR = 2005; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What is the average fee for a CSU campus in the year of 2005?
SELECT avg(campusfee) FROM csu_fees WHERE YEAR = 2005; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### How many campuses are there in Los Angeles county?
SELECT count(*) FROM campuses WHERE county = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### How many campuses exist are in the county of LA?
SELECT count(*) FROM campuses WHERE county = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### List the campuses in Los Angeles county.
SELECT campus FROM campuses WHERE county = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What campuses are in Los Angeles county?
SELECT campus FROM campuses WHERE county = "Los_Angeles"; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### How many faculty is there in total in the year of 2002?
SELECT sum(faculty) FROM faculty WHERE YEAR = 2002; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### How many faculty, in total, are there in the year 2002?
SELECT sum(faculty) FROM faculty WHERE YEAR = 2002; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### How many CSU campuses are there?
SELECT count(*) FROM campuses; ###
###Postgre SQL tables, with their properties:
# campuses: ["id", "campus", "location", "county", "year"]
# csu_fees: ["campus", "year", "campus_fee"]
# degrees: ["year", "campus", "degrees"]
# discipline_enrollments: ["campus", "discipline", "year", "undergraduate", "graduate"]
# enrollments: ["campus", "year", "totalenrollment_ay", "fte_ay"]
# faculty: ["campus", "year", "faculty"]
### What is the total number of campuses?
SELECT count(*) FROM campuses; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### How many candidates are there?
SELECT count(*) FROM candidate; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Count the number of candidates.
SELECT count(*) FROM candidate; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Which poll resource provided the most number of candidate information?
SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Return the poll resource associated with the most candidates.
SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### what are the top 3 highest support rates?
SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Return the top 3 greatest support rates.
SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Find the id of the candidate who got the lowest oppose rate.
SELECT Candidate_ID FROM candidate ORDER BY oppose_rate LIMIT 1; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What is the id of the candidate with the lowest oppose rate?
SELECT Candidate_ID FROM candidate ORDER BY oppose_rate LIMIT 1; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Please list support, consider, and oppose rates for each candidate in ascending order by unsure rate.
SELECT Support_rate,Consider_rate,Oppose_rate FROM candidate ORDER BY unsure_rate; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What are the support, consider, and oppose rates of each candidate, ordered ascending by their unsure rate?
SELECT Support_rate,Consider_rate,Oppose_rate FROM candidate ORDER BY unsure_rate; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### which poll source does the highest oppose rate come from?
SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Return the poll source corresponding to the candidate who has the oppose rate.
SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### List all people names in the order of their date of birth from old to young.
SELECT name FROM people ORDER BY date_of_birth; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What are the names of all people, ordered by their date of birth?
SELECT name FROM people ORDER BY date_of_birth; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Find the average height and weight for all males (sex is M).
SELECT avg(height),avg(weight) FROM people WHERE sex = 'M'; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What are the average height and weight across males (sex is M)?
SELECT avg(height),avg(weight) FROM people WHERE sex = 'M'; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### find the names of people who are taller than 200 or lower than 190.
SELECT name FROM people WHERE height > 200 OR height < 190; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What are the names of people who have a height greater than 200 or less than 190?
SELECT name FROM people WHERE height > 200 OR height < 190; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Find the average and minimum weight for each gender.
SELECT avg(weight),min(weight),sex FROM people GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What are the average and minimum weights for people of each sex?
SELECT avg(weight),min(weight),sex FROM people GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### what are the names of people who did not participate in the candidate election.
SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate); ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Give the names of people who did not participate in the candidate election.
SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate); ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### how many people are there whose weight is higher than 85 for each gender?
SELECT count(*),sex FROM people WHERE weight > 85 GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Count the number of people of each sex who have a weight higher than 85.
SELECT count(*),sex FROM people WHERE weight > 85 GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### find the highest support percentage, lowest consider rate and oppose rate of all candidates.
SELECT max(support_rate),min(consider_rate),min(oppose_rate) FROM candidate; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### Return the maximum support rate, minimum consider rate, and minimum oppose rate across all candidates?
SELECT max(support_rate),min(consider_rate),min(oppose_rate) FROM candidate; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### find the name of people whose height is lower than the average.
SELECT name FROM people WHERE height < (SELECT avg(height) FROM people); ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What are the names of people who are shorter than average?
SELECT name FROM people WHERE height < (SELECT avg(height) FROM people); ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### List all info about all people.
SELECT * FROM people; ###
###Postgre SQL tables, with their properties:
# candidate: ["candidate_id", "people_id", "poll_source", "date", "support_rate", "consider_rate", "oppose_rate", "unsure_rate"]
# people: ["people_id", "sex", "name", "date_of_birth", "height", "weight"]
### What is all the information about all people?
SELECT * FROM people; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### Find the titles of all movies directed by steven spielberg.
SELECT title FROM Movie WHERE director = 'Steven Spielberg'; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of all movies directed by Steven Spielberg?
SELECT title FROM Movie WHERE director = 'Steven Spielberg'; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the name of the movie produced after 2000 and directed by James Cameron?
SELECT title FROM Movie WHERE director = 'James Cameron' AND YEAR > 2000; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the titles of all movies that James Cameron directed after 2000?
SELECT title FROM Movie WHERE director = 'James Cameron' AND YEAR > 2000; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### How many movies were made before 2000?
SELECT count(*) FROM Movie WHERE YEAR < 2000; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### How many movies were made before 2000?
SELECT count(*) FROM Movie WHERE YEAR < 2000; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### Who is the director of movie Avatar?
SELECT director FROM Movie WHERE title = 'Avatar'; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### Who directed Avatar?
SELECT director FROM Movie WHERE title = 'Avatar'; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### How many reviewers listed?
SELECT count(*) FROM Reviewer; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### How many reviewers are there?
SELECT count(*) FROM Reviewer; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the id of the reviewer whose name has substring “Mike”?
SELECT rID FROM Reviewer WHERE name LIKE "%Mike%"; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the id of the reviewer whose name includes the word "Mike"?
SELECT rID FROM Reviewer WHERE name LIKE "%Mike%"; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the reviewer id of Daniel Lewis?
SELECT rID FROM Reviewer WHERE name = "Daniel_Lewis"; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the id of the reviewer named Daniel Lewis?
SELECT rID FROM Reviewer WHERE name = "Daniel_Lewis"; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the total number of ratings that has more than 3 stars?
SELECT count(*) FROM Rating WHERE stars > 3; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### How many movie ratings have more than 3 stars?
SELECT count(*) FROM Rating WHERE stars > 3; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the lowest and highest rating star?
SELECT max(stars),min(stars) FROM Rating; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the maximum and mininum number of stars a rating can receive?
SELECT max(stars),min(stars) FROM Rating; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### Find the titles of all movies that have no ratings.
SELECT title FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating); ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the titles of all movies that have not been rated?
SELECT title FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating); ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the name of the most recent movie?
SELECT title FROM Movie WHERE YEAR = (SELECT max(YEAR) FROM Movie); ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the title of the newest movie?
SELECT title FROM Movie WHERE YEAR = (SELECT max(YEAR) FROM Movie); ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What is the names of movies whose created year is after all movies directed by Steven Spielberg?
SELECT title FROM Movie WHERE YEAR > (SELECT max(YEAR) FROM Movie WHERE director = "Steven_Spielberg"); ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of all movies that were created after the most recent Steven Spielberg film?
SELECT title FROM Movie WHERE YEAR > (SELECT max(YEAR) FROM Movie WHERE director = "Steven_Spielberg"); ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### Return all reviewer names and movie names together in a single list.
SELECT name FROM Reviewer UNION SELECT title FROM Movie; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of all the reviewers and movie names?
SELECT name FROM Reviewer UNION SELECT title FROM Movie; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of the directors who made exactly one movie?
SELECT director FROM Movie GROUP BY director HAVING count(*) = 1; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of all directors who made one movie?
SELECT director FROM Movie GROUP BY director HAVING count(*) = 1; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of the directors who made exactly one movie excluding director NULL?
SELECT director FROM Movie WHERE director != "null" GROUP BY director HAVING count(*) = 1; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of all directors who have made one movie except for the director named NULL?
SELECT director FROM Movie WHERE director != "null" GROUP BY director HAVING count(*) = 1; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### Find the average rating star for each movie that received at least 2 ratings.
SELECT mID,avg(stars) FROM Rating GROUP BY mID HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### For each movie that received more than 3 reviews, what is the average rating?
SELECT mID,avg(stars) FROM Rating GROUP BY mID HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### find the ids of reviewers who did not give 4 star.
SELECT rID FROM Rating EXCEPT SELECT rID FROM Rating WHERE stars = 4; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the ids of all reviewers who did not give 4 stars?
SELECT rID FROM Rating EXCEPT SELECT rID FROM Rating WHERE stars = 4; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### Find the ids of reviewers who didn't only give 4 star.
SELECT rID FROM Rating WHERE stars != 4; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the ids of all reviewers who have not given 4 stars at least once?
SELECT rID FROM Rating WHERE stars != 4; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are names of the movies that are either made before 1980 or directed by James Cameron?
SELECT title FROM Movie WHERE director = "James_Cameron" OR YEAR < 1980; ###
###Postgre SQL tables, with their properties:
# movie: ["movie_id", "title", "year", "director"]
# reviewer: ["reviewer_id", "name"]
# rating: ["reviewer_id", "movie_id", "rating_stars", "rating_date"]
### What are the names of all movies made before 1980 or had James Cameron as the director?
SELECT title FROM Movie WHERE director = "James_Cameron" OR YEAR < 1980; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### How many counties are there?
SELECT count(*) FROM county_public_safety; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Count the number of countries.
SELECT count(*) FROM county_public_safety; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### List the names of counties in descending order of population.
SELECT Name FROM county_public_safety ORDER BY Population DESC; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the names of the counties of public safety, ordered by population descending?
SELECT Name FROM county_public_safety ORDER BY Population DESC; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### List the distinct police forces of counties whose location is not on east side.
SELECT DISTINCT Police_force FROM county_public_safety WHERE LOCATION != "East"; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the different police forces of counties that are not located in the East?
SELECT DISTINCT Police_force FROM county_public_safety WHERE LOCATION != "East"; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the minimum and maximum crime rate of counties?
SELECT min(Crime_rate),max(Crime_rate) FROM county_public_safety; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Return the minimum and maximum crime rates across all counties.
SELECT min(Crime_rate),max(Crime_rate) FROM county_public_safety; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Show the crime rates of counties in ascending order of number of police officers.
SELECT Crime_rate FROM county_public_safety ORDER BY Police_officers ASC; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the crime rates of counties sorted by number of offices ascending?
SELECT Crime_rate FROM county_public_safety ORDER BY Police_officers ASC; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the names of cities in ascending alphabetical order?
SELECT Name FROM city ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Return the names of cities, ordered alphabetically.
SELECT Name FROM city ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the percentage of hispanics in cities with the black percentage higher than 10?
SELECT Hispanic FROM city WHERE Black > 10; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Return the hispanic percentage for cities in which the black percentage is greater than 10.
SELECT Hispanic FROM city WHERE Black > 10; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### List the name of the county with the largest population.
SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What is the name of the county with the greatest population?
SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### List the names of the city with the top 5 white percentages.
SELECT Name FROM city ORDER BY White DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the names of the five cities with the greatest proportion of white people?
SELECT Name FROM city ORDER BY White DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Show the name of cities in the county that has the largest number of police officers.
SELECT name FROM city WHERE county_ID = (SELECT county_ID FROM county_public_safety ORDER BY Police_officers DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the names of cities that are in the county with the most police officers?
SELECT name FROM city WHERE county_ID = (SELECT county_ID FROM county_public_safety ORDER BY Police_officers DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Show the number of cities in counties that have a population more than 20000.
SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population > 20000); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### How many cities are in counties that have populations of over 20000?
SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population > 20000); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Please show the police forces and the number of counties with each police force.
SELECT Police_force,COUNT(*) FROM county_public_safety GROUP BY Police_force; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### How many counties correspond to each police force?
SELECT Police_force,COUNT(*) FROM county_public_safety GROUP BY Police_force; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What is the location shared by most counties?
SELECT LOCATION FROM county_public_safety GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Which location has the most corresponding counties?
SELECT LOCATION FROM county_public_safety GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### List the names of counties that do not have any cities.
SELECT Name FROM county_public_safety WHERE County_ID NOT IN (SELECT County_ID FROM city); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the names of counties that do not contain any cities?
SELECT Name FROM county_public_safety WHERE County_ID NOT IN (SELECT County_ID FROM city); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Show the police force shared by counties with location on the east and west.
SELECT Police_force FROM county_public_safety WHERE LOCATION = "East" INTERSECT SELECT Police_force FROM county_public_safety WHERE LOCATION = "West"; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Which police forces operate in both counties that are located in the East and in the West?
SELECT Police_force FROM county_public_safety WHERE LOCATION = "East" INTERSECT SELECT Police_force FROM county_public_safety WHERE LOCATION = "West"; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Show the names of cities in counties that have a crime rate less than 100.
SELECT name FROM city WHERE county_id IN (SELECT county_id FROM county_public_safety WHERE Crime_rate < 100); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the names of cities that are in counties that have a crime rate below 100?
SELECT name FROM city WHERE county_id IN (SELECT county_id FROM county_public_safety WHERE Crime_rate < 100); ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### Show the case burden of counties in descending order of population.
SELECT Case_burden FROM county_public_safety ORDER BY Population DESC; ###
###Postgre SQL tables, with their properties:
# county_public_safety: ["county_id", "name", "population", "police_officers", "residents_per_officer", "case_burden", "crime_rate", "police_force", "location"]
# city: ["city_id", "county_id", "name", "white", "black", "amerindian", "asian", "multiracial", "hispanic"]
### What are the case burdens of counties, ordered descending by population?
SELECT Case_burden FROM county_public_safety ORDER BY Population DESC; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the names of all modern rooms with a base price below $160 and two beds.
SELECT roomName FROM Rooms WHERE basePrice < 160 AND beds = 2 AND decor = 'modern';; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the names of modern rooms that have a base price lower than $160 and two beds.
SELECT roomName FROM Rooms WHERE basePrice < 160 AND beds = 2 AND decor = 'modern';; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find all the rooms that have a price higher than 160 and can accommodate more than 2 people. Report room names and ids.
SELECT roomName,RoomId FROM Rooms WHERE basePrice > 160 AND maxOccupancy > 2;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the room names and ids of all the rooms that cost more than 160 and can accommodate more than two people.
SELECT roomName,RoomId FROM Rooms WHERE basePrice > 160 AND maxOccupancy > 2;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many kids stay in the rooms reserved by ROY SWEAZY?
SELECT kids FROM Reservations WHERE FirstName = "ROY" AND LastName = "SWEAZY";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of kids staying in the rooms reserved by a person called ROY SWEAZ.
SELECT kids FROM Reservations WHERE FirstName = "ROY" AND LastName = "SWEAZY";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many times does ROY SWEAZY has reserved a room.
SELECT count(*) FROM Reservations WHERE FirstName = "ROY" AND LastName = "SWEAZY";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of times ROY SWEAZY has reserved a room.
SELECT count(*) FROM Reservations WHERE FirstName = "ROY" AND LastName = "SWEAZY";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many adults stay in the room CONRAD SELBIG checked in on Oct 23, 2010?
SELECT Adults FROM Reservations WHERE CheckIn = "2010-10-23" AND FirstName = "CONRAD" AND LastName = "SELBIG";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of adults for the room reserved and checked in by CONRAD SELBIG on Oct 23, 2010.
SELECT Adults FROM Reservations WHERE CheckIn = "2010-10-23" AND FirstName = "CONRAD" AND LastName = "SELBIG";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many kids stay in the room DAMIEN TRACHSEL checked in on Sep 21, 2010?
SELECT Kids FROM Reservations WHERE CheckIn = "2010-09-21" AND FirstName = "DAMIEN" AND LastName = "TRACHSEL";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Return the number of kids for the room reserved and checked in by DAMIEN TRACHSEL on Sep 21, 2010.
SELECT Kids FROM Reservations WHERE CheckIn = "2010-09-21" AND FirstName = "DAMIEN" AND LastName = "TRACHSEL";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many king beds are there?
SELECT sum(beds) FROM Rooms WHERE bedtype = 'King';; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the total number of king beds available.
SELECT sum(beds) FROM Rooms WHERE bedtype = 'King';; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### List the names and decor of rooms that have a king bed. Sort the list by their price.
SELECT roomName,decor FROM Rooms WHERE bedtype = 'King' ORDER BY basePrice;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the names and decor of rooms with a king bed? Sort them by their price
SELECT roomName,decor FROM Rooms WHERE bedtype = 'King' ORDER BY basePrice;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Which room has cheapest base price? List the room's name and the base price.
SELECT roomName,basePrice FROM Rooms ORDER BY basePrice ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the room name and base price of the room with the lowest base price?
SELECT roomName,basePrice FROM Rooms ORDER BY basePrice ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What is the decor of room Recluse and defiance?
SELECT decor FROM Rooms WHERE roomName = "Recluse_and_defiance";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Return the decor of the room named "Recluse_and_defiance".
SELECT decor FROM Rooms WHERE roomName = "Recluse_and_defiance";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What is the average base price of different bed type? List bed type and average base price.
SELECT bedType,avg(basePrice) FROM Rooms GROUP BY bedType;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### For each bed type, find the average base price of different bed type.
SELECT bedType,avg(basePrice) FROM Rooms GROUP BY bedType;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What is the total number of people who could stay in the modern rooms in this inn?
SELECT sum(maxOccupancy) FROM Rooms WHERE decor = 'modern';; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many people in total can stay in the modern rooms of this inn?
SELECT sum(maxOccupancy) FROM Rooms WHERE decor = 'modern';; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many rooms are there?
SELECT count(*) FROM Rooms;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What is the total number of rooms available in this inn?
SELECT count(*) FROM Rooms;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of rooms with a king bed.
SELECT count(*) FROM Rooms WHERE bedType = "King";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many rooms have a king bed?
SELECT count(*) FROM Rooms WHERE bedType = "King";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of rooms for each bed type.
SELECT bedType,count(*) FROM Rooms GROUP BY bedType;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the number of rooms for each bed type?
SELECT bedType,count(*) FROM Rooms GROUP BY bedType;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the name of the room with the maximum occupancy.
SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What is the name of the room that can accommodate the most people?
SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the id and name of the most expensive base price room.
SELECT RoomId,roomName FROM Rooms ORDER BY basePrice DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Which room has the highest base price?
SELECT RoomId,roomName FROM Rooms ORDER BY basePrice DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### List the type of bed and name of all traditional rooms.
SELECT roomName,bedType FROM Rooms WHERE decor = "traditional";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the bed type and name of all the rooms with traditional decor?
SELECT roomName,bedType FROM Rooms WHERE decor = "traditional";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of rooms with king bed for each decor type.
SELECT decor,count(*) FROM Rooms WHERE bedType = "King" GROUP BY decor;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many rooms have king beds? Report the number for each decor type.
SELECT decor,count(*) FROM Rooms WHERE bedType = "King" GROUP BY decor;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the average and minimum price of the rooms in different decor.
SELECT decor,avg(basePrice),min(basePrice) FROM Rooms GROUP BY decor;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What is the average minimum and price of the rooms for each different decor.
SELECT decor,avg(basePrice),min(basePrice) FROM Rooms GROUP BY decor;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### List the name of all rooms sorted by their prices.
SELECT roomName FROM Rooms ORDER BY basePrice;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Sort all the rooms according to the price. Just report the room names.
SELECT roomName FROM Rooms ORDER BY basePrice;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of rooms with price higher than 120 for different decor.
SELECT decor,count(*) FROM Rooms WHERE basePrice > 120 GROUP BY decor;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many rooms cost more than 120, for each different decor?
SELECT decor,count(*) FROM Rooms WHERE basePrice > 120 GROUP BY decor;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### For each bed type, find the average room price.
SELECT bedType,avg(basePrice) FROM Rooms GROUP BY bedType;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What is the average base price of rooms, for each bed type?
SELECT bedType,avg(basePrice) FROM Rooms GROUP BY bedType;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### List the name of rooms with king or queen bed.
SELECT roomName FROM Rooms WHERE bedType = "King" OR bedType = "Queen";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the names of rooms that have either king or queen bed?
SELECT roomName FROM Rooms WHERE bedType = "King" OR bedType = "Queen";; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many different types of beds are there?
SELECT count(DISTINCT bedType) FROM Rooms;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of distinct bed types available in this inn.
SELECT count(DISTINCT bedType) FROM Rooms;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the name and id of the top 3 expensive rooms.
SELECT RoomId,roomName FROM Rooms ORDER BY basePrice DESC LIMIT 3;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the name and id of the three highest priced rooms?
SELECT RoomId,roomName FROM Rooms ORDER BY basePrice DESC LIMIT 3;; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the name of rooms whose price is higher than the average price.
SELECT roomName FROM Rooms WHERE basePrice > ( SELECT avg(basePrice) FROM Rooms );; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### What are the name of rooms that cost more than the average.
SELECT roomName FROM Rooms WHERE basePrice > ( SELECT avg(basePrice) FROM Rooms );; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the number of rooms that do not have any reservation.
SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations); ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### How many rooms have not had any reservation yet?
SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations); ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Find the name of rooms whose base price is between 120 and 150.
SELECT roomname FROM rooms WHERE baseprice BETWEEN 120 AND 150; ###
###Postgre SQL tables, with their properties:
# rooms: ["room_id", "room_name", "beds", "bed_type", "max_occupancy", "base_price", "decor"]
# reservations: ["code", "room", "check_in", "check_out", "rate", "last_name", "first_name", "adults", "kids"]
### Which rooms cost between 120 and 150? Give me the room names.
SELECT roomname FROM rooms WHERE baseprice BETWEEN 120 AND 150; ###
###Postgre SQL tables, with their properties:
# customer_master_index: ["master_customer_id", "cmi_details"]
# cmi_cross_references: ["cmi_cross_reference_id", "master_customer_id", "source_system_code"]
# council_tax: ["council_tax_id", "cmi_cross_reference_id"]
# business_rates: ["business_rates_id", "cmi_cross_reference_id"]
# benefits_overpayments: ["council_tax_id", "cmi_cross_ref_id"]
# parking_fines: ["council_tax_id", "cmi_cross_reference_id"]
# rent_arrears: ["council_tax_id", "cmi_cross_reference_id"]
# electoral_register: ["electoral_register_id", "cmi_cross_reference_id"]
### How many different source system code for the cmi cross references are there?
SELECT count(DISTINCT source_system_code) FROM CMI_cross_references; ###
###Postgre SQL tables, with their properties:
# customer_master_index: ["master_customer_id", "cmi_details"]
# cmi_cross_references: ["cmi_cross_reference_id", "master_customer_id", "source_system_code"]
# council_tax: ["council_tax_id", "cmi_cross_reference_id"]
# business_rates: ["business_rates_id", "cmi_cross_reference_id"]
# benefits_overpayments: ["council_tax_id", "cmi_cross_ref_id"]
# parking_fines: ["council_tax_id", "cmi_cross_reference_id"]
# rent_arrears: ["council_tax_id", "cmi_cross_reference_id"]
# electoral_register: ["electoral_register_id", "cmi_cross_reference_id"]
### List all information about customer master index, and sort them by details in descending order.
SELECT * FROM customer_master_index ORDER BY cmi_details DESC; ###
###Postgre SQL tables, with their properties:
# customer_master_index: ["master_customer_id", "cmi_details"]
# cmi_cross_references: ["cmi_cross_reference_id", "master_customer_id", "source_system_code"]
# council_tax: ["council_tax_id", "cmi_cross_reference_id"]
# business_rates: ["business_rates_id", "cmi_cross_reference_id"]
# benefits_overpayments: ["council_tax_id", "cmi_cross_ref_id"]
# parking_fines: ["council_tax_id", "cmi_cross_reference_id"]
# rent_arrears: ["council_tax_id", "cmi_cross_reference_id"]
# electoral_register: ["electoral_register_id", "cmi_cross_reference_id"]
### List the council tax ids and their related cmi cross references of all the parking fines.
SELECT council_tax_id,cmi_cross_ref_id FROM parking_fines; ###
###Postgre SQL tables, with their properties:
# customer_master_index: ["master_customer_id", "cmi_details"]
# cmi_cross_references: ["cmi_cross_reference_id", "master_customer_id", "source_system_code"]
# council_tax: ["council_tax_id", "cmi_cross_reference_id"]
# business_rates: ["business_rates_id", "cmi_cross_reference_id"]
# benefits_overpayments: ["council_tax_id", "cmi_cross_ref_id"]
# parking_fines: ["council_tax_id", "cmi_cross_reference_id"]
# rent_arrears: ["council_tax_id", "cmi_cross_reference_id"]
# electoral_register: ["electoral_register_id", "cmi_cross_reference_id"]
### How many council taxes are collected for renting arrears?
SELECT count(*) FROM rent_arrears; ###
###Postgre SQL tables, with their properties:
# customer_master_index: ["master_customer_id", "cmi_details"]
# cmi_cross_references: ["cmi_cross_reference_id", "master_customer_id", "source_system_code"]
# council_tax: ["council_tax_id", "cmi_cross_reference_id"]
# business_rates: ["business_rates_id", "cmi_cross_reference_id"]
# benefits_overpayments: ["council_tax_id", "cmi_cross_ref_id"]
# parking_fines: ["council_tax_id", "cmi_cross_reference_id"]
# rent_arrears: ["council_tax_id", "cmi_cross_reference_id"]
# electoral_register: ["electoral_register_id", "cmi_cross_reference_id"]
### Which cmi cross reference id is not related to any parking taxes?
SELECT cmi_cross_ref_id FROM cmi_cross_references EXCEPT SELECT cmi_cross_ref_id FROM parking_fines; ###
###Postgre SQL tables, with their properties:
# customer_master_index: ["master_customer_id", "cmi_details"]
# cmi_cross_references: ["cmi_cross_reference_id", "master_customer_id", "source_system_code"]
# council_tax: ["council_tax_id", "cmi_cross_reference_id"]
# business_rates: ["business_rates_id", "cmi_cross_reference_id"]
# benefits_overpayments: ["council_tax_id", "cmi_cross_ref_id"]
# parking_fines: ["council_tax_id", "cmi_cross_reference_id"]
# rent_arrears: ["council_tax_id", "cmi_cross_reference_id"]
# electoral_register: ["electoral_register_id", "cmi_cross_reference_id"]
### Which distinct source system code includes the substring 'en'?
SELECT DISTINCT source_system_code FROM cmi_cross_references WHERE source_system_code LIKE '%en%'; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### How many parties are there?
SELECT count(*) FROM party; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Count the number of parties.
SELECT count(*) FROM party; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### List the themes of parties in ascending order of number of hosts.
SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### What are the themes of parties ordered by the number of hosts in ascending manner?
SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### What are the themes and locations of parties?
SELECT Party_Theme,LOCATION FROM party; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Give me the theme and location of each party.
SELECT Party_Theme,LOCATION FROM party; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Show the first year and last year of parties with theme "Spring" or "Teqnology".
SELECT First_year,Last_year FROM party WHERE Party_Theme = "Spring" OR Party_Theme = "Teqnology"; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### What are the first year and last year of the parties whose theme is "Spring" or "Teqnology"?
SELECT First_year,Last_year FROM party WHERE Party_Theme = "Spring" OR Party_Theme = "Teqnology"; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### What is the average number of hosts for parties?
SELECT avg(Number_of_hosts) FROM party; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Compute the average number of hosts for parties.
SELECT avg(Number_of_hosts) FROM party; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### What is the location of the party with the most hosts?
SELECT LOCATION FROM party ORDER BY Number_of_hosts DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Which party had the most hosts? Give me the party location.
SELECT LOCATION FROM party ORDER BY Number_of_hosts DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Show different nationalities along with the number of hosts of each nationality.
SELECT Nationality,COUNT(*) FROM HOST GROUP BY Nationality; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### How many hosts does each nationality have? List the nationality and the count.
SELECT Nationality,COUNT(*) FROM HOST GROUP BY Nationality; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Show the most common nationality of hosts.
SELECT Nationality FROM HOST GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Which nationality has the most hosts?
SELECT Nationality FROM HOST GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Show the nations that have both hosts older than 45 and hosts younger than 35.
SELECT Nationality FROM HOST WHERE Age > 45 INTERSECT SELECT Nationality FROM HOST WHERE Age < 35; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Which nations have both hosts of age above 45 and hosts of age below 35?
SELECT Nationality FROM HOST WHERE Age > 45 INTERSECT SELECT Nationality FROM HOST WHERE Age < 35; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### Show the name and the nationality of the oldest host.
SELECT Name,Nationality FROM HOST ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### What are the name and the nationality of the host of the highest age?
SELECT Name,Nationality FROM HOST ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### List the names of hosts who did not serve as a host of any party in our record.
SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host); ###
###Postgre SQL tables, with their properties:
# party: ["party_id", "party_theme", "location", "first_year", "last_year", "number_of_hosts"]
# host: ["host_id", "name", "nationality", "age"]
# party_host: ["party_id", "host_id", "is_main_in_charge"]
### What are the names of hosts who did not host any party in our record?
SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host); ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### How many regions do we have?
SELECT count(*) FROM region; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Count the number of regions.
SELECT count(*) FROM region; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Show all region code and region name sorted by the codes.
SELECT region_code,region_name FROM region ORDER BY region_code; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What are the codes and names for all regions, sorted by codes?
SELECT region_code,region_name FROM region ORDER BY region_code; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### List all region names in alphabetical order.
SELECT region_name FROM region ORDER BY region_name; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What are the names of the regions in alphabetical order?
SELECT region_name FROM region ORDER BY region_name; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Show names for all regions except for Denmark.
SELECT region_name FROM region WHERE region_name != 'Denmark'; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Return the names of all regions other than Denmark.
SELECT region_name FROM region WHERE region_name != 'Denmark'; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### How many storms had death records?
SELECT count(*) FROM storm WHERE Number_Deaths > 0; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Count the number of storms in which at least 1 person died.
SELECT count(*) FROM storm WHERE Number_Deaths > 0; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### List name, dates active, and number of deaths for all storms with at least 1 death.
SELECT name,dates_active,number_deaths FROM storm WHERE number_deaths >= 1; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What are the names, dates active, and number of deaths for storms that had 1 or more death?
SELECT name,dates_active,number_deaths FROM storm WHERE number_deaths >= 1; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Show the average and maximum damage for all storms with max speed higher than 1000.
SELECT avg(damage_millions_USD),max(damage_millions_USD) FROM storm WHERE max_speed > 1000; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What is the average and maximum damage in millions for storms that had a max speed over 1000?
SELECT avg(damage_millions_USD),max(damage_millions_USD) FROM storm WHERE max_speed > 1000; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What is the total number of deaths and damage for all storms with a max speed greater than the average?
SELECT sum(number_deaths),sum(damage_millions_USD) FROM storm WHERE max_speed > (SELECT avg(max_speed) FROM storm); ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Return the total number of deaths and total damange in millions for storms that had a max speed greater than the average.
SELECT sum(number_deaths),sum(damage_millions_USD) FROM storm WHERE max_speed > (SELECT avg(max_speed) FROM storm); ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### List name and damage for all storms in a descending order of max speed.
SELECT name,damage_millions_USD FROM storm ORDER BY max_speed DESC; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What are the names and damage in millions for storms, ordered by their max speeds descending?
SELECT name,damage_millions_USD FROM storm ORDER BY max_speed DESC; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### How many regions are affected?
SELECT count(DISTINCT region_id) FROM affected_region; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Count the number of different affected regions.
SELECT count(DISTINCT region_id) FROM affected_region; ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Show the name for regions not affected.
SELECT region_name FROM region WHERE region_id NOT IN (SELECT region_id FROM affected_region); ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What are the names of regions that were not affected?
SELECT region_name FROM region WHERE region_id NOT IN (SELECT region_id FROM affected_region); ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### Show the name of storms which don't have affected region in record.
SELECT name FROM storm WHERE storm_id NOT IN (SELECT storm_id FROM affected_region); ###
###Postgre SQL tables, with their properties:
# storm: ["storm_id", "name", "dates_active", "max_speed", "damage_millions_usd", "number_deaths"]
# region: ["region_id", "region_code", "region_name"]
# affected_region: ["region_id", "storm_id", "number_city_affected"]
### What are the names of storms that did not affect any regions?
SELECT name FROM storm WHERE storm_id NOT IN (SELECT storm_id FROM affected_region); ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### How many counties are there in total?
SELECT count(*) FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Count the total number of counties.
SELECT count(*) FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the county name and population of all counties.
SELECT County_name,Population FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### What are the name and population of each county?
SELECT County_name,Population FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the average population of all counties.
SELECT avg(Population) FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### On average how large is the population of the counties?
SELECT avg(Population) FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Return the maximum and minimum population among all counties.
SELECT max(Population),min(Population) FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### What are the maximum and minimum population of the counties?
SELECT max(Population),min(Population) FROM county; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show all the distinct districts for elections.
SELECT DISTINCT District FROM election; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### What are the distinct districts for elections?
SELECT DISTINCT District FROM election; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the zip code of the county with name "Howard".
SELECT Zip_code FROM county WHERE County_name = "Howard"; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### What is the zip code the county named "Howard" is located in?
SELECT Zip_code FROM county WHERE County_name = "Howard"; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the delegate from district 1 in election.
SELECT Delegate FROM election WHERE District = 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Who is the delegate of district 1 in the elections?
SELECT Delegate FROM election WHERE District = 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the delegate and committee information of elections.
SELECT Delegate,Committee FROM election; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### What are the delegate and committee information for each election record?
SELECT Delegate,Committee FROM election; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### How many distinct governors are there?
SELECT count(DISTINCT Governor) FROM party; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Count the number of distinct governors.
SELECT count(DISTINCT Governor) FROM party; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the lieutenant governor and comptroller from the democratic party.
SELECT Lieutenant_Governor,Comptroller FROM party WHERE Party = "Democratic"; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Who are the lieutenant governor and comptroller from the democratic party?
SELECT Lieutenant_Governor,Comptroller FROM party WHERE Party = "Democratic"; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### In which distinct years was the governor "Eliot_Spitzer"?
SELECT DISTINCT YEAR FROM party WHERE Governor = "Eliot_Spitzer"; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Find the distinct years when the governor was named "Eliot_Spitzer".
SELECT DISTINCT YEAR FROM party WHERE Governor = "Eliot_Spitzer"; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show all the information about election.
SELECT * FROM election; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Return all the information for each election record.
SELECT * FROM election; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Return the names of all counties sorted by population in ascending order.
SELECT County_name FROM county ORDER BY Population ASC; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Sort the names of all counties in ascending order of population.
SELECT County_name FROM county ORDER BY Population ASC; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Return the names of all counties sorted by county name in descending alphabetical order.
SELECT County_name FROM county ORDER BY County_name DESC; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Sort the names of all counties in descending alphabetical order.
SELECT County_name FROM county ORDER BY County_name DESC; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the name of the county with the biggest population.
SELECT County_name FROM county ORDER BY Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Which county has the largest population? Give me the name of the county.
SELECT County_name FROM county ORDER BY Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the 3 counties with the smallest population.
SELECT County_name FROM county ORDER BY Population ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### What are the 3 counties that have the smallest population? Give me the county names.
SELECT County_name FROM county ORDER BY Population ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the name of the party that has at least two records.
SELECT Party FROM party GROUP BY Party HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Which party has two or more records?
SELECT Party FROM party GROUP BY Party HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the people that have been governor the most times.
SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Which people severed as governor most frequently?
SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Show the people that have been comptroller the most times and the corresponding number of times.
SELECT Comptroller,COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Which people severed as comptroller most frequently? Give me the name of the person and the frequency count.
SELECT Comptroller,COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### What are the names of parties that do not have delegates in election?
SELECT Party FROM party WHERE Party_ID NOT IN (SELECT Party FROM election); ###
###Postgre SQL tables, with their properties:
# county: ["county_id", "county_name", "population", "zip_code"]
# party: ["party_id", "year", "party", "governor", "lieutenant_governor", "comptroller", "attorney_general", "us_senate"]
# election: ["election_id", "counties_represented", "district", "delegate", "party", "first_elected", "committee"]
### Which parties did not have any delegates in elections?
SELECT Party FROM party WHERE Party_ID NOT IN (SELECT Party FROM election); ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### How many journalists are there?
SELECT count(*) FROM journalist; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### List the names of journalists in ascending order of years working.
SELECT Name FROM journalist ORDER BY Years_working ASC; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### What are the nationalities and ages of journalists?
SELECT Nationality,Age FROM journalist; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### Show the names of journalists from "England" or "Wales".
SELECT Name FROM journalist WHERE Nationality = "England" OR Nationality = "Wales"; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### What is the average number of years spent working as a journalist?
SELECT avg(Years_working) FROM journalist; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### What is the nationality of the journalist with the largest number of years working?
SELECT Nationality FROM journalist ORDER BY Years_working DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### Show the different nationalities and the number of journalists of each nationality.
SELECT Nationality,COUNT(*) FROM journalist GROUP BY Nationality; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### Show the most common nationality for journalists.
SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### Show the nations that have both journalists with more than 10 years of working and journalists with less than 3 years of working.
SELECT Nationality FROM journalist WHERE Years_working > 10 INTERSECT SELECT Nationality FROM journalist WHERE Years_working < 3; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### Show the dates, places, and names of events in descending order of the attendance.
SELECT Date,Name,venue FROM event ORDER BY Event_Attendance DESC; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### List the names of journalists who have not reported any event.
SELECT Name FROM journalist WHERE journalist_ID NOT IN (SELECT journalist_ID FROM news_report); ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### what are the average and maximum attendances of all events?
SELECT avg(Event_Attendance),max(Event_Attendance) FROM event; ###
###Postgre SQL tables, with their properties:
# event: ["event_id", "date", "venue", "name", "event_attendance"]
# journalist: ["journalist_id", "name", "nationality", "age", "years_working"]
# news_report: ["journalist_id", "event_id", "work_type"]
### List the event venues and names that have the top 2 most number of people attended.
SELECT venue,name FROM event ORDER BY Event_Attendance DESC LIMIT 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Show me all the restaurants.
SELECT ResName FROM Restaurant;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### What is the address of the restaurant Subway?
SELECT Address FROM Restaurant WHERE ResName = "Subway";; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### What is the rating of the restaurant Subway?
SELECT Rating FROM Restaurant WHERE ResName = "Subway";; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### List all restaurant types.
SELECT ResTypeName FROM Restaurant_Type;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### What is the description of the restaurant type Sandwich?
SELECT ResTypeDescription FROM Restaurant_Type WHERE ResTypeName = "Sandwich";; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Which restaurants have highest rating? List the restaurant name and its rating.
SELECT ResName,Rating FROM Restaurant ORDER BY Rating DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### What is the age of student Linda Smith?
SELECT Age FROM Student WHERE Fname = "Linda" AND Lname = "Smith";; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### What is the gender of the student Linda Smith?
SELECT Sex FROM Student WHERE Fname = "Linda" AND Lname = "Smith";; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### List all students' first names and last names who majored in 600.
SELECT Fname,Lname FROM Student WHERE Major = 600;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Which city does student Linda Smith live in?
SELECT city_code FROM Student WHERE Fname = "Linda" AND Lname = "Smith";; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Advisor 1121 has how many students?
SELECT count(*) FROM Student WHERE Advisor = 1121;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Which Advisor has most of students? List advisor and the number of students.
SELECT Advisor,count(*) FROM Student GROUP BY Advisor ORDER BY count(Advisor) DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Which major has least number of students? List the major and the number of students.
SELECT Major,count(*) FROM Student GROUP BY Major ORDER BY count(Major) ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Which major has between 2 and 30 number of students? List major and the number of students.
SELECT Major,count(*) FROM Student GROUP BY Major HAVING count(Major) BETWEEN 2 AND 30;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### Which student's age is older than 18 and is majoring in 600? List each student's first and last name.
SELECT Fname,Lname FROM Student WHERE Age > 18 AND Major = 600;; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# restaurant: ["restaurant_id", "restaurant_name", "address", "rating"]
# type_of_restaurant: ["restaurant_id", "restaurant_type_id"]
# restaurant_type: ["restaurant_type_id", "restaurant_type_name", "restaurant_type_description"]
# visits_restaurant: ["student_id", "restaurant_id", "time", "spent"]
### List all female students age is older than 18 who is not majoring in 600. List students' first name and last name.
SELECT Fname,Lname FROM Student WHERE Age > 18 AND Major != 600 AND Sex = 'F';; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### Find the ids of orders whose status is 'Success'.
SELECT actual_order_id FROM actual_orders WHERE order_status_code = 'Success'; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### Find the number of customers in total.
SELECT count(*) FROM customers; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### How many different payment methods are there?
SELECT count(DISTINCT payment_method) FROM customers; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### Show the details of all trucks in the order of their license number.
SELECT truck_details FROM trucks ORDER BY truck_licence_number; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### Find the name of the most expensive product.
SELECT product_name FROM products ORDER BY product_price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### List the names and emails of customers who payed by Visa card.
SELECT customer_email,customer_name FROM customers WHERE payment_method = 'Visa'; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### Find the states which do not have any employee in their record.
SELECT state_province_county FROM addresses WHERE address_id NOT IN (SELECT employee_address_id FROM Employees); ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### List the names, phone numbers, and emails of all customers sorted by their dates of becoming customers.
SELECT customer_name,customer_phone,customer_email FROM Customers ORDER BY date_became_customer; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### Find the name of the first 5 customers.
SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT 5; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### Find the payment method that is used most frequently.
SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# products: ["product_id", "product_name", "product_price", "product_description"]
# addresses: ["address_id", "address_details", "city", "zip_postcode", "state_province_county", "country"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "date_became_customer"]
# regular_orders: ["regular_order_id", "distributer_id"]
# regular_order_products: ["regular_order_id", "product_id"]
# actual_orders: ["actual_order_id", "order_status_code", "regular_order_id", "actual_order_date"]
# actual_order_products: ["actual_order_id", "product_id"]
# customer_addresses: ["customer_id", "address_id", "date_from", "address_type", "date_to"]
# delivery_routes: ["route_id", "route_name", "other_route_details"]
# delivery_route_locations: ["location_code", "route_id", "location_address_id", "location_name"]
# trucks: ["truck_id", "truck_licence_number", "truck_details"]
# employees: ["employee_id", "employee_address_id", "employee_name", "employee_phone"]
# order_deliveries: ["location_code", "actual_order_id", "delivery_status_code", "driver_employee_id", "truck_id", "delivery_date"]
### List the names of all routes in alphabetic order.
SELECT route_name FROM Delivery_Routes ORDER BY route_name; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### How many authors are there?
SELECT count(*) FROM authors; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Count the number of authors.
SELECT count(*) FROM authors; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### How many institutions are there?
SELECT count(*) FROM inst; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Count the number of institutions.
SELECT count(*) FROM inst; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### How many papers are published in total?
SELECT count(*) FROM papers; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Count the number of total papers.
SELECT count(*) FROM papers; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Find the titles of the papers that contain the word "ML".
SELECT title FROM papers WHERE title LIKE "%ML%"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Which papers have the substring "ML" in their titles? Return the titles of the papers.
SELECT title FROM papers WHERE title LIKE "%ML%"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Which paper's title contains the word "Database"?
SELECT title FROM papers WHERE title LIKE "%Database%"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Which papers have the substring "Database" in their titles? Show the titles of the papers.
SELECT title FROM papers WHERE title LIKE "%Database%"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### What is the first name of the author with last name "Ueno"?
SELECT fname FROM authors WHERE lname = "Ueno"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Which authors have last name "Ueno"? List their first names.
SELECT fname FROM authors WHERE lname = "Ueno"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Find the last name of the author with first name "Amal".
SELECT lname FROM authors WHERE fname = "Amal"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Which authors have first name "Amal"? List their last names.
SELECT lname FROM authors WHERE fname = "Amal"; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Find the first names of all the authors ordered in alphabetical order.
SELECT fname FROM authors ORDER BY fname; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Sort the first names of all the authors in alphabetical order.
SELECT fname FROM authors ORDER BY fname; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Retrieve all the last names of authors in alphabetical order.
SELECT lname FROM authors ORDER BY lname; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Give me a list of all the last names of authors sorted in alphabetical order
SELECT lname FROM authors ORDER BY lname; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Retrieve all the first and last names of authors in the alphabetical order of last names.
SELECT fname,lname FROM authors ORDER BY lname; ###
###Postgre SQL tables, with their properties:
# institution: ["institution_id", "name", "country"]
# authors: ["author_id", "last_name", "first_name"]
# papers: ["paper_id", "title"]
# authorship_count: ["author_id", "institution_id", "paper_id", "author_count"]
### Sort the list of all the first and last names of authors in alphabetical order of the last names.
SELECT fname,lname FROM authors ORDER BY lname; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### How many different last names do the actors and actresses have?
SELECT count(DISTINCT last_name) FROM actor; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Count the number of different last names actors have.
SELECT count(DISTINCT last_name) FROM actor; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What is the most popular first name of the actors?
SELECT first_name FROM actor GROUP BY first_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the most common first name among all actors.
SELECT first_name FROM actor GROUP BY first_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What is the most popular full name of the actors?
SELECT first_name,last_name FROM actor GROUP BY first_name,last_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the most common full name among all actors.
SELECT first_name,last_name FROM actor GROUP BY first_name,last_name ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Which districts have at least two addresses?
SELECT district FROM address GROUP BY district HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Give the districts which have two or more addresses.
SELECT district FROM address GROUP BY district HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What is the phone number and postal code of the address 1031 Daugavpils Parkway?
SELECT phone,postal_code FROM address WHERE address = '1031 Daugavpils Parkway'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Give the phone and postal code corresponding to the address '1031 Daugavpils Parkway'.
SELECT phone,postal_code FROM address WHERE address = '1031 Daugavpils Parkway'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### How many addresses are in the district of California?
SELECT count(*) FROM address WHERE district = 'California'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Count the number of addressed in the California district.
SELECT count(*) FROM address WHERE district = 'California'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### How many customers have an active value of 1?
SELECT count(*) FROM customer WHERE active = '1'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Count the number of customers who are active.
SELECT count(*) FROM customer WHERE active = '1'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Which film has the highest rental rate? And what is the rate?
SELECT title,rental_rate FROM film ORDER BY rental_rate DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What are the title and rental rate of the film with the highest rental rate?
SELECT title,rental_rate FROM film ORDER BY rental_rate DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Which store owns most items?
SELECT store_id FROM inventory GROUP BY store_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What is the id of the store that has the most items in inventory?
SELECT store_id FROM inventory GROUP BY store_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What is the total amount of all payments?
SELECT sum(amount) FROM payment; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the sum of all payment amounts.
SELECT sum(amount) FROM payment; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### How many languages are in these films?
SELECT count(DISTINCT language_id) FROM film; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Count the number of different languages in these films.
SELECT count(DISTINCT language_id) FROM film; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What are all the movies rated as R? List the titles.
SELECT title FROM film WHERE rating = 'R'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the titles of any movies with an R rating.
SELECT title FROM film WHERE rating = 'R'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### How many stores are there?
SELECT count(*) FROM store; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Count the number of stores.
SELECT count(*) FROM store; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### How many kinds of different ratings are listed?
SELECT count(DISTINCT rating) FROM film; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Count the number of different film ratings.
SELECT count(DISTINCT rating) FROM film; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Which movies have 'Deleted Scenes' as a substring in the special feature?
SELECT title FROM film WHERE special_features LIKE '%Deleted Scenes%'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the titles of films that include 'Deleted Scenes' in their special feature section.
SELECT title FROM film WHERE special_features LIKE '%Deleted Scenes%'; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### How many items in inventory does store 1 have?
SELECT count(*) FROM inventory WHERE store_id = 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Count the number of items store 1 has in stock.
SELECT count(*) FROM inventory WHERE store_id = 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### When did the first payment happen?
SELECT payment_date FROM payment ORDER BY payment_date ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What was the date of the earliest payment?
SELECT payment_date FROM payment ORDER BY payment_date ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Find all the films longer than 100 minutes, or rated PG, except those who cost more than 200 for replacement. List the titles.
SELECT title FROM film WHERE LENGTH > 100 OR rating = 'PG' EXCEPT SELECT title FROM film WHERE replacement_cost > 200; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What are the titles of films that are either longer than 100 minutes or rated PG other than those that cost more than 200 to replace?
SELECT title FROM film WHERE LENGTH > 100 OR rating = 'PG' EXCEPT SELECT title FROM film WHERE replacement_cost > 200; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Which store has most the customers?
SELECT store_id FROM customer GROUP BY store_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the id of the store with the most customers.
SELECT store_id FROM customer GROUP BY store_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What is the largest payment amount?
SELECT amount FROM payment ORDER BY amount DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the amount of the largest payment.
SELECT amount FROM payment ORDER BY amount DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### What are the first names of customers who have not rented any films after '2005-08-23 02:06:01'?
SELECT first_name FROM customer WHERE customer_id NOT IN( SELECT customer_id FROM rental WHERE rental_date > '2005-08-23 02:06:01' ); ###
###Postgre SQL tables, with their properties:
# actor: ["actor_id", "first_name", "last_name", "last_update"]
# address: ["address_id", "address", "address2", "district", "city_id", "postal_code", "phone", "last_update"]
# category: ["category_id", "name", "last_update"]
# city: ["city_id", "city", "country_id", "last_update"]
# country: ["country_id", "country", "last_update"]
# customer: ["customer_id", "store_id", "first_name", "last_name", "email", "address_id", "active", "create_date", "last_update"]
# film: ["film_id", "title", "description", "release_year", "language_id", "original_language_id", "rental_duration", "rental_rate", "length", "replacement_cost", "rating", "special_features", "last_update"]
# film_actor: ["actor_id", "film_id", "last_update"]
# film_category: ["film_id", "category_id", "last_update"]
# film_text: ["film_id", "title", "description"]
# inventory: ["inventory_id", "film_id", "store_id", "last_update"]
# language: ["language_id", "name", "last_update"]
# payment: ["payment_id", "customer_id", "staff_id", "rental_id", "amount", "payment_date", "last_update"]
# rental: ["rental_id", "rental_date", "inventory_id", "customer_id", "return_date", "staff_id", "last_update"]
# staff: ["staff_id", "first_name", "last_name", "address_id", "picture", "email", "store_id", "active", "username", "password", "last_update"]
# store: ["store_id", "manager_staff_id", "address_id", "last_update"]
### Return the first names of customers who did not rented a film after the date '2005-08-23 02:06:01'.
SELECT first_name FROM customer WHERE customer_id NOT IN( SELECT customer_id FROM rental WHERE rental_date > '2005-08-23 02:06:01' ); ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### How many bank branches are there?
SELECT count(*) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Count the number of bank branches.
SELECT count(*) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### How many customers are there?
SELECT sum(no_of_customers) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the total number of customers across banks?
SELECT sum(no_of_customers) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the number of customers in the banks at New York City.
SELECT sum(no_of_customers) FROM bank WHERE city = 'New York City'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the total number of customers who use banks in New York City?
SELECT sum(no_of_customers) FROM bank WHERE city = 'New York City'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the average number of customers in all banks of Utah state.
SELECT avg(no_of_customers) FROM bank WHERE state = 'Utah'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the average number of customers across banks in the state of Utah?
SELECT avg(no_of_customers) FROM bank WHERE state = 'Utah'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the average number of customers cross all banks.
SELECT avg(no_of_customers) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the average number of bank customers?
SELECT avg(no_of_customers) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the city and state of the bank branch named morningside.
SELECT city,state FROM bank WHERE bname = 'morningside'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What city and state is the bank with the name morningside in?
SELECT city,state FROM bank WHERE bname = 'morningside'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the branch names of banks in the New York state.
SELECT bname FROM bank WHERE state = 'New York'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the names of banks in the state of New York?
SELECT bname FROM bank WHERE state = 'New York'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### List the name of all customers sorted by their account balance in ascending order.
SELECT cust_name FROM customer ORDER BY acc_bal; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the names of all customers, ordered by account balance?
SELECT cust_name FROM customer ORDER BY acc_bal; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the state, account type, and credit score of the customer whose number of loan is 0.
SELECT state,acc_type,credit_score FROM customer WHERE no_of_loans = 0; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the states, account types, and credit scores for customers who have 0 loans?
SELECT state,acc_type,credit_score FROM customer WHERE no_of_loans = 0; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the number of different cities which banks are located at.
SELECT count(DISTINCT city) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### In how many different cities are banks located?
SELECT count(DISTINCT city) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the number of different states which banks are located at.
SELECT count(DISTINCT state) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### In how many different states are banks located?
SELECT count(DISTINCT state) FROM bank; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### How many distinct types of accounts are there?
SELECT count(DISTINCT acc_type) FROM customer; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Count the number of different account types.
SELECT count(DISTINCT acc_type) FROM customer; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the name and account balance of the customer whose name includes the letter ‘a’.
SELECT cust_name,acc_bal FROM customer WHERE cust_name LIKE '%a%'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the names and account balances of customers with the letter a in their names?
SELECT cust_name,acc_bal FROM customer WHERE cust_name LIKE '%a%'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the total account balance of each customer from Utah or Texas.
SELECT sum(acc_bal) FROM customer WHERE state = 'Utah' OR state = 'Texas'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the total account balances for each customer from Utah or Texas?
SELECT sum(acc_bal) FROM customer WHERE state = 'Utah' OR state = 'Texas'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the name of customers who have both saving and checking account types.
SELECT cust_name FROM customer WHERE acc_type = 'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type = 'checking'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the names of customers who have both savings and checking accounts?
SELECT cust_name FROM customer WHERE acc_type = 'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type = 'checking'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the name of customers who do not have an saving account.
SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type = 'saving'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the names of customers who do not have saving accounts?
SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type = 'saving'; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the name of customers whose credit score is below the average credit scores of all customers.
SELECT cust_name FROM customer WHERE credit_score < (SELECT avg(credit_score) FROM customer); ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What are the names of customers with credit score less than the average credit score across customers?
SELECT cust_name FROM customer WHERE credit_score < (SELECT avg(credit_score) FROM customer); ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the branch name of the bank that has the most number of customers.
SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the name of the bank branch with the greatest number of customers?
SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the name of customer who has the lowest credit score.
SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the name of the customer with the worst credit score?
SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the name, account type, and account balance of the customer who has the highest credit score.
SELECT cust_name,acc_type,acc_bal FROM customer ORDER BY credit_score DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the name, account type, and account balance corresponding to the customer with the highest credit score?
SELECT cust_name,acc_type,acc_bal FROM customer ORDER BY credit_score DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the state which has the most number of customers.
SELECT state FROM bank GROUP BY state ORDER BY sum(no_of_customers) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Which state has the greatest total number of bank customers?
SELECT state FROM bank GROUP BY state ORDER BY sum(no_of_customers) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### For each account type, find the average account balance of customers with credit score lower than 50.
SELECT avg(acc_bal),acc_type FROM customer WHERE credit_score < 50 GROUP BY acc_type; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the average account balance of customers with credit score below 50 for the different account types?
SELECT avg(acc_bal),acc_type FROM customer WHERE credit_score < 50 GROUP BY acc_type; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### For each state, find the total account balance of customers whose credit score is above 100.
SELECT sum(acc_bal),state FROM customer WHERE credit_score > 100 GROUP BY state; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the total account balance for customers with a credit score of above 100 for the different states?
SELECT sum(acc_bal),state FROM customer WHERE credit_score > 100 GROUP BY state; ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the average credit score of the customers who have some loan.
SELECT avg(credit_score) FROM customer WHERE cust_id IN (SELECT cust_id FROM loan); ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the average credit score for customers who have taken a loan?
SELECT avg(credit_score) FROM customer WHERE cust_id IN (SELECT cust_id FROM loan); ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### Find the average credit score of the customers who do not have any loan.
SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan); ###
###Postgre SQL tables, with their properties:
# bank: ["branch_id", "bname", "no_of_customers", "city", "state"]
# customer: ["customer_id", "customer_name", "account_type", "account_balance", "number_of_loans", "credit_score", "branch_id", "state"]
# loan: ["loan_id", "loan_type", "customer_id", "branch_id", "amount"]
### What is the average credit score for customers who have never taken a loan?
SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan); ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### How many assessment notes are there in total?
SELECT count(*) FROM ASSESSMENT_NOTES; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### What are the dates of the assessment notes?
SELECT date_of_notes FROM Assessment_Notes; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### How many addresses have zip code 197?
SELECT count(*) FROM ADDRESSES WHERE zip_postcode = "197"; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### How many distinct incident type codes are there?
SELECT count(DISTINCT incident_type_code) FROM Behavior_Incident; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### Return all distinct detention type codes.
SELECT DISTINCT detention_type_code FROM Detention; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### What are the start and end dates for incidents with incident type code "NOISE"?
SELECT date_incident_start,date_incident_end FROM Behavior_Incident WHERE incident_type_code = "NOISE"; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### Return all detention summaries.
SELECT detention_summary FROM Detention; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### Return the cell phone number and email address for all students.
SELECT cell_mobile_number,email_address FROM STUDENTS; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### What is the email of the student with first name "Emma" and last name "Rohan"?
SELECT email_address FROM Students WHERE first_name = "Emma" AND last_name = "Rohan"; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### How many distinct students have been in detention?
SELECT count(DISTINCT student_id) FROM Students_in_Detention; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### What is the gender of the teacher with last name "Medhurst"?
SELECT gender FROM TEACHERS WHERE last_name = "Medhurst"; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### What is the incident type description for the incident type with code "VIOLENCE"?
SELECT incident_type_description FROM Ref_Incident_Type WHERE incident_type_code = "VIOLENCE"; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### Find the maximum and minimum monthly rental for all student addresses.
SELECT max(monthly_rental),min(monthly_rental) FROM Student_Addresses; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### Find the first names of teachers whose email address contains the word "man".
SELECT first_name FROM Teachers WHERE email_address LIKE '%man%'; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### List all information about the assessment notes sorted by date in ascending order.
SELECT * FROM Assessment_Notes ORDER BY date_of_notes ASC; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### List all cities of addresses in alphabetical order.
SELECT city FROM Addresses ORDER BY city; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### Find the first names and last names of teachers in alphabetical order of last name.
SELECT first_name,last_name FROM Teachers ORDER BY last_name; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### Find all information about student addresses, and sort by monthly rental in descending order.
SELECT * FROM Student_Addresses ORDER BY monthly_rental DESC; ###
###Postgre SQL tables, with their properties:
# reference_address_types: ["address_type_code", "address_type_description"]
# reference_detention_type: ["detention_type_code", "detention_type_description"]
# reference_incident_type: ["incident_type_code", "incident_type_description"]
# addresses: ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# students: ["student_id", "address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "date_first_rental", "date_left_university", "other_student_details"]
# teachers: ["teacher_id", "address_id", "first_name", "middle_name", "last_name", "gender", "cell_mobile_number", "email_address", "other_details"]
# assessment_notes: ["notes_id", "student_id", "teacher_id", "date_of_notes", "text_of_notes", "other_details"]
# behavior_incident: ["incident_id", "incident_type_code", "student_id", "date_incident_start", "date_incident_end", "incident_summary", "recommendations", "other_details"]
# detention: ["detention_id", "detention_type_code", "teacher_id", "datetime_detention_start", "datetime_detention_end", "detention_summary", "other_details"]
# student_addresses: ["student_id", "address_id", "date_address_from", "date_address_to", "monthly_rental", "other_details"]
# students_in_detention: ["student_id", "detention_id", "incident_id"]
### How many students are not involved in any behavior incident?
SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident ); ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### What are all the distinct last names of all the engineers?
SELECT DISTINCT last_name FROM Maintenance_Engineers; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### How many fault status codes are recorded in the fault log parts table?
SELECT DISTINCT fault_status FROM Fault_Log_Parts; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### Which engineers have never visited to maintain the assets? List the engineer first name and last name.
SELECT first_name,last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits); ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### List the asset id, details, make and model for every asset.
SELECT asset_id,asset_details,asset_make,asset_model FROM Assets; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### When was the first asset acquired?
SELECT asset_acquired_date FROM Assets ORDER BY asset_acquired_date ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### What are all the distinct asset models?
SELECT DISTINCT asset_model FROM Assets; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### List the all the assets make, model, details by the disposed date ascendingly.
SELECT asset_make,asset_model,asset_details FROM Assets ORDER BY asset_disposed_date ASC; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### Which part has the least chargeable amount? List the part id and amount.
SELECT part_id,chargeable_amount FROM Parts ORDER BY chargeable_amount ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### Which gender makes up the majority of the staff?
SELECT gender FROM staff GROUP BY gender ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# third_party_companies: ["company_id", "company_type", "company_name", "company_address", "other_company_details"]
# maintenance_contracts: ["maintenance_contract_id", "maintenance_contract_company_id", "contract_start_date", "contract_end_date", "other_contract_details"]
# parts: ["part_id", "part_name", "chargeable_yn", "chargeable_amount", "other_part_details"]
# skills: ["skill_id", "skill_code", "skill_description"]
# staff: ["staff_id", "staff_name", "gender", "other_staff_details"]
# assets: ["asset_id", "maintenance_contract_id", "supplier_company_id", "asset_details", "asset_make", "asset_model", "asset_acquired_date", "asset_disposed_date", "other_asset_details"]
# asset_parts: ["asset_id", "part_id"]
# maintenance_engineers: ["engineer_id", "company_id", "first_name", "last_name", "other_details"]
# engineer_skills: ["engineer_id", "skill_id"]
# fault_log: ["fault_log_entry_id", "asset_id", "recorded_by_staff_id", "fault_log_entry_datetime", "fault_description", "other_fault_details"]
# engineer_visits: ["engineer_visit_id", "contact_staff_id", "engineer_id", "fault_log_entry_id", "fault_status", "visit_start_datetime", "visit_end_datetime", "other_visit_details"]
# part_faults: ["part_fault_id", "part_id", "fault_short_name", "fault_description", "other_fault_details"]
# fault_log_parts: ["fault_log_entry_id", "part_fault_id", "fault_status"]
# skills_required_to_fix: ["part_fault_id", "skill_id"]
### Which assets did not incur any fault log? List the asset model.
SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT asset_id FROM Fault_Log); ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### list the local authorities and services provided by all stations.
SELECT local_authority,services FROM station; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### show all train numbers and names ordered by their time from early to late.
SELECT train_number,name FROM train ORDER BY TIME; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### Give me the times and numbers of all trains that go to Chennai, ordered by time.
SELECT TIME,train_number FROM train WHERE destination = 'Chennai' ORDER BY TIME; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### How many trains have 'Express' in their names?
SELECT count(*) FROM train WHERE name LIKE "%Express%"; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### Find the number and time of the train that goes from Chennai to Guruvayur.
SELECT train_number,TIME FROM train WHERE origin = 'Chennai' AND destination = 'Guruvayur'; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### Find the number of trains starting from each origin.
SELECT origin,count(*) FROM train GROUP BY origin; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### What is the average high temperature for each day of week?
SELECT avg(high_temperature),day_of_week FROM weekly_weather GROUP BY day_of_week; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### How many different services are provided by all stations?
SELECT count(DISTINCT services) FROM station; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### show the lowest low temperature and highest wind speed in miles per hour.
SELECT min(low_temperature),max(wind_speed_mph) FROM weekly_weather; ###
###Postgre SQL tables, with their properties:
# train: ["id", "train_number", "name", "origin", "destination", "time", "interval"]
# station: ["id", "network_name", "services", "local_authority"]
# route: ["train_id", "station_id"]
# weekly_weather: ["station_id", "day_of_week", "high_temperature", "low_temperature", "precipitation", "wind_speed_mph"]
### Find the origins from which more than 1 train starts.
SELECT origin FROM train GROUP BY origin HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many professors are teaching class with code ACCT-211?
SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE = "ACCT-211"; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many professors teach a class with the code ACCT-211?
SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE = "ACCT-211"; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the code of the school where the accounting department belongs to?
SELECT school_code FROM department WHERE dept_name = "Accounting"; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the school code of the accounting department?
SELECT school_code FROM department WHERE dept_name = "Accounting"; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many credits does course CIS-220 have, and what its description?
SELECT crs_credit,crs_description FROM course WHERE crs_code = 'CIS-220'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the description for the CIS-220 and how many credits does it have?
SELECT crs_credit,crs_description FROM course WHERE crs_code = 'CIS-220'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### what is the address of history department?
SELECT dept_address FROM department WHERE dept_name = 'History'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Where is the history department?
SELECT dept_address FROM department WHERE dept_name = 'History'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many different locations does the school with code BUS has?
SELECT count(DISTINCT dept_address) FROM department WHERE school_code = 'BUS'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What are the different locations of the school with the code BUS?
SELECT count(DISTINCT dept_address) FROM department WHERE school_code = 'BUS'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many different locations does each school have?
SELECT count(DISTINCT dept_address),school_code FROM department GROUP BY school_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Count different addresses of each school.
SELECT count(DISTINCT dept_address),school_code FROM department GROUP BY school_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the description and credit for the course QM-261?
SELECT crs_credit,crs_description FROM course WHERE crs_code = 'QM-261'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the course description and number of credits for QM-261?
SELECT crs_credit,crs_description FROM course WHERE crs_code = 'QM-261'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the number of departments in each school.
SELECT count(DISTINCT dept_name),school_code FROM department GROUP BY school_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many departments are in each school?
SELECT count(DISTINCT dept_name),school_code FROM department GROUP BY school_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the number of different departments in each school whose number of different departments is less than 5.
SELECT count(DISTINCT dept_name),school_code FROM department GROUP BY school_code HAVING count(DISTINCT dept_name) < 5; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many different departments are there in each school that has less than 5 apartments?
SELECT count(DISTINCT dept_name),school_code FROM department GROUP BY school_code HAVING count(DISTINCT dept_name) < 5; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many sections does each course has?
SELECT count(*),crs_code FROM CLASS GROUP BY crs_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many sections does each course have?
SELECT count(*),crs_code FROM CLASS GROUP BY crs_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the total credit does each department offer?
SELECT sum(crs_credit),dept_code FROM course GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many credits does the department offer?
SELECT sum(crs_credit),dept_code FROM course GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the number of classes offered for all class rooms that held at least 2 classes.
SELECT count(*),class_room FROM CLASS GROUP BY class_room HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### For each classroom with at least 2 classes, how many classes are offered?
SELECT count(*),class_room FROM CLASS GROUP BY class_room HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the count and code of the job has most employees.
SELECT emp_jobcode,count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the count and code of the job with the most employee?
SELECT emp_jobcode,count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the number of professors with a Ph.D. degree in each department.
SELECT count(*),dept_code FROM professor WHERE prof_high_degree = 'Ph.D.' GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many professors have a Ph.D. in each department?
SELECT count(*),dept_code FROM professor WHERE prof_high_degree = 'Ph.D.' GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the number of students for each department.
SELECT count(*),dept_code FROM student GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many students are in each department?
SELECT count(*),dept_code FROM student GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the total number of hours have done for all students in each department.
SELECT sum(stu_hrs),dept_code FROM student GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many hours do the students spend studying in each department?
SELECT sum(stu_hrs),dept_code FROM student GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the max, average, and minimum gpa of all students in each department.
SELECT max(stu_gpa),avg(stu_gpa),min(stu_gpa),dept_code FROM student GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the highest, lowest, and average student GPA for every department?
SELECT max(stu_gpa),avg(stu_gpa),min(stu_gpa),dept_code FROM student GROUP BY dept_code; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### how many schools exist in total?
SELECT count(DISTINCT school_code) FROM department; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many schools are there in the department?
SELECT count(DISTINCT school_code) FROM department; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many different classes are there?
SELECT count(DISTINCT class_code) FROM CLASS; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many unique classes are offered?
SELECT count(DISTINCT class_code) FROM CLASS; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many courses are offered?
SELECT count(DISTINCT crs_code) FROM CLASS; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What are the number of different course codes?
SELECT count(DISTINCT crs_code) FROM CLASS; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many departments does the college has?
SELECT count(DISTINCT dept_name) FROM department; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many different departments are there?
SELECT count(DISTINCT dept_name) FROM department; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many sections does course ACCT-211 has?
SELECT count(DISTINCT class_section) FROM CLASS WHERE crs_code = 'ACCT-211'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the number of different class sections offered in the course ACCT-211?
SELECT count(DISTINCT class_section) FROM CLASS WHERE crs_code = 'ACCT-211'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the total number of employees.
SELECT count(*) FROM employee; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many employees are there all together?
SELECT count(*) FROM employee; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many professors do have a Ph.D. degree?
SELECT count(*) FROM professor WHERE prof_high_degree = 'Ph.D.'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the total number of professors with a Ph.D.?
SELECT count(*) FROM professor WHERE prof_high_degree = 'Ph.D.'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### list names of all departments ordered by their names.
SELECT dept_name FROM department ORDER BY dept_name; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What are the names of all departments in alphabetical order?
SELECT dept_name FROM department ORDER BY dept_name; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### List the codes of all courses that take place in room KLR209.
SELECT class_code FROM CLASS WHERE class_room = 'KLR209'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What are the codes of all the courses that are located in room KLR209?
SELECT class_code FROM CLASS WHERE class_room = 'KLR209'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### List the first name of all employees with job code PROF ordered by their date of birth.
SELECT emp_fname FROM employee WHERE emp_jobcode = 'PROF' ORDER BY emp_dob; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What are the first names of all employees that are professors ordered by date of birth?
SELECT emp_fname FROM employee WHERE emp_jobcode = 'PROF' ORDER BY emp_dob; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the first and last name of the oldest employee?
SELECT emp_fname,emp_lname FROM employee ORDER BY emp_dob LIMIT 1; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What are the first and last names of the employee with the earliest date of birth?
SELECT emp_fname,emp_lname FROM employee ORDER BY emp_dob LIMIT 1; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the first, last name, gpa of the youngest one among students whose GPA is above 3?
SELECT stu_fname,stu_lname,stu_gpa FROM student WHERE stu_gpa > 3 ORDER BY stu_dob DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the first and last name of the youngest student with a GPA above 3, and what is their GPA?
SELECT stu_fname,stu_lname,stu_gpa FROM student WHERE stu_gpa > 3 ORDER BY stu_dob DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many professors who has a either Ph.D. or MA degree?
SELECT count(*) FROM professor WHERE prof_high_degree = 'Ph.D.' OR prof_high_degree = 'MA'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### How many professors attained either Ph.D. or Masters degrees?
SELECT count(*) FROM professor WHERE prof_high_degree = 'Ph.D.' OR prof_high_degree = 'MA'; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the first name, gpa and phone number of the top 5 students with highest gpa?
SELECT stu_gpa,stu_phone,stu_fname FROM student ORDER BY stu_gpa DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the first name, GPA, and phone number of the students with the top 5 GPAs?
SELECT stu_gpa,stu_phone,stu_fname FROM student ORDER BY stu_gpa DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### Find the first name and gpa of the students whose gpa is lower than the average gpa of all students.
SELECT stu_fname,stu_gpa FROM student WHERE stu_gpa < (SELECT avg(stu_gpa) FROM student); ###
###Postgre SQL tables, with their properties:
# class: ["class_code", "course_code", "class_section", "class_time", "class_room", "professor_employee_number"]
# course: ["course_code", "department_code", "course_description", "course_credit"]
# department: ["department_code", "department_name", "school_code", "employee_number", "department_address", "department_extension"]
# employee: ["employee_number", "employee_last_name", "employee_first_name", "employee_initial", "employee_job_code", "employee_hire_date", "employee_date_of_birth"]
# enroll: ["class_code", "student_number", "enroll_grade"]
# professor: ["employee_number", "department_code", "professor_office", "professor_extension", "professor_high_degree"]
# student: ["student_num", "student_last_name", "student_first_name", "student_init", "student_date_of_birth", "student_class_hours_took", "student_class", "student_gpa", "student_transfer", "department_code", "student_phone", "professor_number"]
### What is the first name and GPA of every student that has a GPA lower than average?
SELECT stu_fname,stu_gpa FROM student WHERE stu_gpa < (SELECT avg(stu_gpa) FROM student); ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### How many clubs are there?
SELECT count(*) FROM club; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What is the total number of clubs?
SELECT count(*) FROM club; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List the distinct region of clubs in ascending alphabetical order.
SELECT DISTINCT Region FROM club ORDER BY Region ASC; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the different regions of clubs in ascending alphabetical order?
SELECT DISTINCT Region FROM club ORDER BY Region ASC; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What is the average number of gold medals for clubs?
SELECT avg(Gold) FROM club_rank; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What is the average number of gold medals for a club?
SELECT avg(Gold) FROM club_rank; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the types and countries of competitions?
SELECT Competition_type,Country FROM competition; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the types of every competition and in which countries are they located?
SELECT Competition_type,Country FROM competition; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the distinct years in which the competitions type is not "Tournament"?
SELECT DISTINCT YEAR FROM competition WHERE Competition_type != "Tournament"; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the different years for all competitions that are not of type equal to tournament?
SELECT DISTINCT YEAR FROM competition WHERE Competition_type != "Tournament"; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the maximum and minimum number of silver medals for clubs.
SELECT max(Silver),min(Silver) FROM club_rank; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the maximum and minimum number of silver medals for all the clubs?
SELECT max(Silver),min(Silver) FROM club_rank; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### How many clubs have total medals less than 10?
SELECT count(*) FROM club_rank WHERE Total < 10; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What is the total number of clubs that have less than 10 medals in total?
SELECT count(*) FROM club_rank WHERE Total < 10; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List all club names in ascending order of start year.
SELECT name FROM club ORDER BY Start_year ASC; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the names of all the clubs starting with the oldest?
SELECT name FROM club ORDER BY Start_year ASC; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List all club names in descending alphabetical order.
SELECT name FROM club ORDER BY name DESC; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the names of all the clubs ordered in descending alphabetical order?
SELECT name FROM club ORDER BY name DESC; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List the position of players and the average number of points of players of each position.
SELECT POSITION,avg(Points) FROM player GROUP BY POSITION; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### For each position, what is the average number of points for players in that position?
SELECT POSITION,avg(Points) FROM player GROUP BY POSITION; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List the position of players with average number of points scored by players of that position bigger than 20.
SELECT POSITION FROM player GROUP BY name HAVING avg(Points) >= 20; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the positions of players whose average number of points scored by that position is larger than 20?
SELECT POSITION FROM player GROUP BY name HAVING avg(Points) >= 20; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List the types of competition and the number of competitions of each type.
SELECT Competition_type,COUNT(*) FROM competition GROUP BY Competition_type; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the types of competition and number of competitions for that type?
SELECT Competition_type,COUNT(*) FROM competition GROUP BY Competition_type; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List the most common type of competition.
SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What is the most common competition type?
SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List the types of competition that have at most five competitions of that type.
SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*) <= 5; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the types of competition that have most 5 competitions for that type?
SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*) <= 5; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### List the names of clubs that do not have any players.
SELECT name FROM CLub WHERE Club_ID NOT IN (SELECT Club_ID FROM player); ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the names of all clubs that do not have any players?
SELECT name FROM CLub WHERE Club_ID NOT IN (SELECT Club_ID FROM player); ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the positions with both players having more than 20 points and less than 10 points.
SELECT POSITION FROM player WHERE Points > 20 INTERSECT SELECT POSITION FROM player WHERE Points < 10; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the positions of both players that have more than 20 20 points and less than 10 points?
SELECT POSITION FROM player WHERE Points > 20 INTERSECT SELECT POSITION FROM player WHERE Points < 10; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### Show total points of all players.
SELECT sum(Points) FROM player; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What is the total number of points for all players?
SELECT sum(Points) FROM player; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### how many different positions are there?
SELECT count(DISTINCT POSITION) FROM player; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### How many different position for players are listed?
SELECT count(DISTINCT POSITION) FROM player; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### what are the name of players who get more than the average points.
SELECT name FROM player WHERE points > (SELECT avg(points) FROM player); ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the names of all players that got more than the average number of points?
SELECT name FROM player WHERE points > (SELECT avg(points) FROM player); ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### find the number of players whose points are lower than 30 in each position.
SELECT count(*),POSITION FROM player WHERE points < 30 GROUP BY POSITION; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What is the number of players who have points less than 30 for each position?
SELECT count(*),POSITION FROM player WHERE points < 30 GROUP BY POSITION; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### which country did participated in the most number of Tournament competitions?
SELECT country FROM competition WHERE competition_type = 'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### what is the name of the country that participated in the most tournament competitions?
SELECT country FROM competition WHERE competition_type = 'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### which countries did participated in both Friendly and Tournament type competitions.
SELECT country FROM competition WHERE competition_type = 'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type = 'Tournament'; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the countries that participated in both friendly and tournament type competitions?
SELECT country FROM competition WHERE competition_type = 'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type = 'Tournament'; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### Find the countries that have never participated in any competition with Friendly type.
SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type = 'Friendly'; ###
###Postgre SQL tables, with their properties:
# club: ["club_id", "name", "region", "start_year"]
# club_rank: ["rank", "club_id", "gold", "silver", "bronze", "total"]
# player: ["player_id", "name", "position", "club_id", "apps", "tries", "goals", "points"]
# competition: ["competition_id", "year", "competition_type", "country"]
# competition_result: ["competition_id", "club_id_1", "club_id_2", "score"]
### What are the countries that have never participated in any friendly-type competitions?
SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type = 'Friendly'; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### How many furniture components are there in total?
SELECT sum(num_of_component) FROM furniture; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### Return the name and id of the furniture with the highest market rate.
SELECT name,furniture_id FROM furniture ORDER BY market_rate DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### find the total market rate of the furnitures that have the top 2 market shares.
SELECT sum(market_rate) FROM furniture ORDER BY market_rate DESC LIMIT 2; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### Find the component amounts and names of all furnitures that have more than 10 components.
SELECT Num_of_Component,name FROM furniture WHERE Num_of_Component > 10; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### Find the name and component amount of the least popular furniture.
SELECT name,Num_of_Component FROM furniture ORDER BY market_rate LIMIT 1; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### Which manufacturer has the most number of shops? List its name and year of opening.
SELECT open_year,name FROM manufacturer ORDER BY num_of_shops DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### Find the average number of factories for the manufacturers that have more than 20 shops.
SELECT avg(Num_of_Factories) FROM manufacturer WHERE num_of_shops > 20; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### List all manufacturer names and ids ordered by their opening year.
SELECT name,manufacturer_id FROM manufacturer ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### Give me the name and year of opening of the manufacturers that have either less than 10 factories or more than 10 shops.
SELECT name,open_year FROM manufacturer WHERE num_of_shops > 10 OR Num_of_Factories < 10; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### what is the average number of factories and maximum number of shops for manufacturers that opened before 1990.
SELECT max(num_of_shops),avg(Num_of_Factories) FROM manufacturer WHERE open_year < 1990; ###
###Postgre SQL tables, with their properties:
# manufacturer: ["manufacturer_id", "open_year", "name", "num_of_factories", "num_of_shops"]
# furniture: ["furniture_id", "name", "num_of_component", "market_rate"]
# furniture_manufacte: ["manufacturer_id", "furniture_id", "price_in_dollar"]
### Find the market shares and names of furnitures which no any company is producing in our records.
SELECT Market_Rate,name FROM furniture WHERE Furniture_ID NOT IN (SELECT Furniture_ID FROM furniture_manufacte); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### List the full name (first and last name), and salary for those employees who earn below 6000.
SELECT first_name,last_name,salary FROM employees WHERE salary < 6000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full names and salaries for any employees earning less than 6000?
SELECT first_name,last_name,salary FROM employees WHERE salary < 6000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Display the first name, and department number for all employees whose last name is "McEwen".
SELECT first_name,department_id FROM employees WHERE last_name = 'McEwen'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the first names and department numbers for employees with last name McEwen?
SELECT first_name,department_id FROM employees WHERE last_name = 'McEwen'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Return all the information for all employees without any department number.
SELECT * FROM employees WHERE department_id = "null"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are all the employees without a department number?
SELECT * FROM employees WHERE department_id = "null"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Display all the information about the department Marketing.
SELECT * FROM departments WHERE department_name = 'Marketing'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is all the information about the Marketing department?
SELECT * FROM departments WHERE department_name = 'Marketing'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### when is the hire date for those employees whose first name does not containing the letter M?
SELECT hire_date FROM employees WHERE first_name NOT LIKE '%M%'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### On what dates were employees without the letter M in their first names hired?
SELECT hire_date FROM employees WHERE first_name NOT LIKE '%M%'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.
SELECT first_name,last_name,hire_date,salary,department_id FROM employees WHERE first_name NOT LIKE '%M%'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full name, hire date, salary, and department id for employees without the letter M in their first name?
SELECT first_name,last_name,hire_date,salary,department_id FROM employees WHERE first_name NOT LIKE '%M%'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.
SELECT first_name,last_name,hire_date,salary,department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?
SELECT first_name,last_name,hire_date,salary,department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### what is the phone number of employees whose salary is in the range of 8000 and 12000?
SELECT phone_number FROM employees WHERE salary BETWEEN 8000 AND 12000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Return the phone numbers of employees with salaries between 8000 and 12000.
SELECT phone_number FROM employees WHERE salary BETWEEN 8000 AND 12000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display all the information of employees whose salary is in the range of 8000 and 12000 and commission is not null or department number does not equal to 40.
SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != "null" OR department_id != 40; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Return all information about employees with salaries between 8000 and 12000 for which commission is not null or where their department id is not 40.
SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != "null" OR department_id != 40; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full name (first and last name) and salary for all employees who does not have any value for commission?
SELECT first_name,last_name,salary FROM employees WHERE commission_pct = "null"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Return the full names and salaries of employees with null commissions.
SELECT first_name,last_name,salary FROM employees WHERE commission_pct = "null"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Display the first and last name, and salary for those employees whose first name is ending with the letter m.
SELECT first_name,last_name,salary FROM employees WHERE first_name LIKE '%m'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Return the full names and salaries for employees with first names that end with the letter m.
SELECT first_name,last_name,salary FROM employees WHERE first_name LIKE '%m'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Find job id and date of hire for those employees who was hired between November 5th, 2007 and July 5th, 2009.
SELECT job_id,hire_date FROM employees WHERE hire_date BETWEEN '2007-11-05' AND '2009-07-05'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the job ids and dates of hire for employees hired after November 5th, 2007 and before July 5th, 2009?
SELECT job_id,hire_date FROM employees WHERE hire_date BETWEEN '2007-11-05' AND '2009-07-05'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the first and last name for those employees who works either in department 70 or 90?
SELECT first_name,last_name FROM employees WHERE department_id = 70 OR department_id = 90; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full names of employees who with in department 70 or 90?
SELECT first_name,last_name FROM employees WHERE department_id = 70 OR department_id = 90; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Find the salary and manager number for those employees who is working under a manager.
SELECT salary,manager_id FROM employees WHERE manager_id != "null"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the salaries and manager ids for employees who have managers?
SELECT salary,manager_id FROM employees WHERE manager_id != "null"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display all the details from Employees table for those employees who was hired before 2002-06-21.
SELECT * FROM employees WHERE hire_date < '2002-06-21'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is all the information about employees hired before June 21, 2002?
SELECT * FROM employees WHERE hire_date < '2002-06-21'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display all the information for all employees who have the letters D or S in their first name and also arrange the result in descending order by salary.
SELECT * FROM employees WHERE first_name LIKE '%D%' OR first_name LIKE '%S%' ORDER BY salary DESC; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is all the information about employees with D or S in their first name, ordered by salary descending?
SELECT * FROM employees WHERE first_name LIKE '%D%' OR first_name LIKE '%S%' ORDER BY salary DESC; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display those employees who joined after 7th September, 1987.
SELECT * FROM employees WHERE hire_date > '1987-09-07'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Which employees were hired after September 7th, 1987?
SELECT * FROM employees WHERE hire_date > '1987-09-07'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the job title of jobs which minimum salary is greater than 9000.
SELECT job_title FROM jobs WHERE min_salary > 9000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Which job titles correspond to jobs with salaries over 9000?
SELECT job_title FROM jobs WHERE min_salary > 9000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display job Title, the difference between minimum and maximum salaries for those jobs which max salary within the range 12000 to 18000.
SELECT job_title,max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?
SELECT job_title,max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the emails of the employees who have no commission percentage and salary within the range 7000 to 12000 and works in that department which number is 50.
SELECT email FROM employees WHERE commission_pct = "null" AND salary BETWEEN 7000 AND 12000 AND department_id = 50; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the emails of employees with null commission, salary between 7000 and 12000, and who work in department 50?
SELECT email FROM employees WHERE commission_pct = "null" AND salary BETWEEN 7000 AND 12000 AND department_id = 50; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee ID for each employee and the date on which he ended his previous job.
SELECT employee_id,MAX(end_date) FROM job_history GROUP BY employee_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the employee ids for each employee and final dates of employment at their last job?
SELECT employee_id,MAX(end_date) FROM job_history GROUP BY employee_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display those departments where more than ten employees work who got a commission percentage.
SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the department ids for which more than 10 employees had a commission?
SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Find the ids of the departments where any manager is managing 4 or more employees.
SELECT DISTINCT department_id FROM employees GROUP BY department_id,manager_id HAVING COUNT(employee_id) >= 4; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are department ids for departments with managers managing more than 3 employees?
SELECT DISTINCT department_id FROM employees GROUP BY department_id,manager_id HAVING COUNT(employee_id) >= 4; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the average salary of employees for each department who gets a commission percentage.
SELECT department_id,AVG(salary) FROM employees WHERE commission_pct != "null" GROUP BY department_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is the average salary of employees who have a commission percentage that is not null?
SELECT department_id,AVG(salary) FROM employees WHERE commission_pct != "null" GROUP BY department_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the country ID and number of cities for each country.
SELECT country_id,COUNT(*) FROM locations GROUP BY country_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Give the country id and corresponding count of cities in each country.
SELECT country_id,COUNT(*) FROM locations GROUP BY country_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display job ID for those jobs that were done by two or more for more than 300 days.
SELECT job_id FROM job_history WHERE end_date - start_date > 300 GROUP BY job_id HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the job ids for jobs done more than once for a period of more than 300 days?
SELECT job_id FROM job_history WHERE end_date - start_date > 300 GROUP BY job_id HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the ID for those employees who did two or more jobs in the past.
SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the employee ids for employees who have held two or more jobs?
SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is the full name ( first name and last name ) for those employees who gets more salary than the employee whose id is 163?
SELECT first_name,last_name FROM employees WHERE salary > (SELECT salary FROM employees WHERE employee_id = 163 ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Provide the full names of employees earning more than the employee with id 163.
SELECT first_name,last_name FROM employees WHERE salary > (SELECT salary FROM employees WHERE employee_id = 163 ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### return the smallest salary for every departments.
SELECT MIN(salary),department_id FROM employees GROUP BY department_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is the minimum salary in each department?
SELECT MIN(salary),department_id FROM employees GROUP BY department_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Find the first name and last name and department id for those employees who earn such amount of salary which is the smallest salary of any of the departments.
SELECT first_name,last_name,department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full names and department ids for the lowest paid employees across all departments.
SELECT first_name,last_name,department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Find the employee id for all employees who earn more than the average salary.
SELECT employee_id FROM employees WHERE salary > (SELECT AVG(salary) FROM employees); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the employee ids for employees who make more than the average?
SELECT employee_id FROM employees WHERE salary > (SELECT AVG(salary) FROM employees); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee id and salary of all employees who report to Payam (first name).
SELECT employee_id,salary FROM employees WHERE manager_id = (SELECT employee_id FROM employees WHERE first_name = 'Payam' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the employee ids of employees who report to Payam, and what are their salaries?
SELECT employee_id,salary FROM employees WHERE manager_id = (SELECT employee_id FROM employees WHERE first_name = 'Payam' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display all the information about the department Marketing.
SELECT * FROM departments WHERE department_name = 'Marketing'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is all the information about the Marketing department?
SELECT * FROM departments WHERE department_name = 'Marketing'; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the ID for those employees who did two or more jobs in the past.
SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the employee ids for those who had two or more jobs.
SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the unique ids of those departments where any manager is managing 4 or more employees.
SELECT DISTINCT department_id FROM employees GROUP BY department_id,manager_id HAVING COUNT(employee_id) >= 4; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?
SELECT DISTINCT department_id FROM employees GROUP BY department_id,manager_id HAVING COUNT(employee_id) >= 4; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Find the job ID for those jobs which average salary is above 8000.
SELECT job_id FROM employees GROUP BY job_id HAVING AVG(salary) > 8000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the job ids corresponding to jobs with average salary above 8000?
SELECT job_id FROM employees GROUP BY job_id HAVING AVG(salary) > 8000; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display all the information of the employees whose salary if within the range of smallest salary and 2500.
SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is all the information regarding employees with salaries above the minimum and under 2500?
SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.
SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?
SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee name ( first name and last name ) and hire date for all employees in the same department as Clara.
SELECT first_name,last_name,hire_date FROM employees WHERE department_id = (SELECT department_id FROM employees WHERE first_name = "Clara"); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full names and hire dates for employees in the same department as someone with the first name Clara?
SELECT first_name,last_name,hire_date FROM employees WHERE department_id = (SELECT department_id FROM employees WHERE first_name = "Clara"); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee name ( first name and last name ) and hire date for all employees in the same department as Clara excluding Clara.
SELECT first_name,last_name,hire_date FROM employees WHERE department_id = ( SELECT department_id FROM employees WHERE first_name = "Clara") AND first_name != "Clara"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?
SELECT first_name,last_name,hire_date FROM employees WHERE department_id = ( SELECT department_id FROM employees WHERE first_name = "Clara") AND first_name != "Clara"; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a ’T’.
SELECT employee_id,first_name,last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the ids and full names for employees who work in a department that has someone with a first name that contains the letter T?
SELECT employee_id,first_name,last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee number, name( first name and last name ), and salary for all employees who earn more than the average salary and who work in a department with any employee with a 'J' in their first name.
SELECT employee_id,first_name,last_name,salary FROM employees WHERE salary > ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%'); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?
SELECT employee_id,first_name,last_name,salary FROM employees WHERE salary > ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%'); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.
SELECT employee_id,job_id FROM employees WHERE salary < ( SELECT min(salary) FROM employees WHERE job_id = 'MK_MAN' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?
SELECT employee_id,job_id FROM employees WHERE salary < ( SELECT min(salary) FROM employees WHERE job_id = 'MK_MAN' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.
SELECT employee_id,first_name,last_name,job_id FROM employees WHERE salary > ( SELECT max(salary) FROM employees WHERE job_id = 'PU_MAN' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?
SELECT employee_id,first_name,last_name,job_id FROM employees WHERE salary > ( SELECT max(salary) FROM employees WHERE job_id = 'PU_MAN' ); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the department id and the total salary for those departments which contains at least two employees.
SELECT department_id,SUM(salary) FROM employees GROUP BY department_id HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are total salaries and department id for each department that has more than 2 employees?
SELECT department_id,SUM(salary) FROM employees GROUP BY department_id HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display all the information of those employees who did not have any job in the past.
SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What is all the information about employees who have never had a job in the past?
SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history); ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.
SELECT first_name, last_name, salary,department_id,MAX(salary) FROM employees GROUP BY department_id; ###
###Postgre SQL tables, with their properties:
# regions: ["region_id", "region_name"]
# countries: ["country_id", "country_name", "region_id"]
# departments: ["department_id", "department_name", "manager_id", "location_id"]
# jobs: ["job_id", "job_title", "min_salary", "max_salary"]
# employees: ["employee_id", "first_name", "last_name", "email", "phone_number", "hire_date", "job_id", "salary", "commission_pct", "manager_id", "department_id"]
# job_history: ["employee_id", "start_date", "end_date", "job_id", "department_id"]
# locations: ["location_id", "street_address", "postal_code", "city", "state_province", "country_id"]
### What are the department ids, full names, and salaries for employees who make the most in their departments?
SELECT first_name, last_name, salary,department_id,MAX(salary) FROM employees GROUP BY department_id; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the name of the song that was released in the most recent year?
SELECT song_name,releasedate FROM song ORDER BY releasedate DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the name of the song that was released most recently?
SELECT song_name,releasedate FROM song ORDER BY releasedate DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the id of the longest song?
SELECT f_id FROM files ORDER BY duration DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the id of the song that lasts the longest.
SELECT f_id FROM files ORDER BY duration DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the names of all English songs.
SELECT song_name FROM song WHERE languages = "english"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of all songs in English?
SELECT song_name FROM song WHERE languages = "english"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the id of songs whose format is mp3.
SELECT f_id FROM files WHERE formats = "mp3"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the id of all the files in mp3 format?
SELECT f_id FROM files WHERE formats = "mp3"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### How many songs have 4 minute duration?
SELECT count(*) FROM files WHERE duration LIKE "4:%"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the count of the songs that last approximately 4 minutes?
SELECT count(*) FROM files WHERE duration LIKE "4:%"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### How many artists are from Bangladesh?
SELECT count(*) FROM artist WHERE country = "Bangladesh"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### How many Bangladeshi artists are listed?
SELECT count(*) FROM artist WHERE country = "Bangladesh"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the most popular file format?
SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the file format that is used by the most files.
SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the names of the artists who are from UK and have produced English songs.
SELECT artist_name FROM artist WHERE country = "UK" INTERSECT SELECT artist_name FROM song WHERE languages = "english"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of the artists that are from the UK and sang songs in English?
SELECT artist_name FROM artist WHERE country = "UK" INTERSECT SELECT artist_name FROM song WHERE languages = "english"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the id of songs that are available in mp4 format and have resolution lower than 1000.
SELECT f_id FROM files WHERE formats = "mp4" INTERSECT SELECT f_id FROM song WHERE resolution < 1000; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?
SELECT f_id FROM files WHERE formats = "mp4" INTERSECT SELECT f_id FROM song WHERE resolution < 1000; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the number of artists for each gender?
SELECT count(*),gender FROM artist GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### How many artists are male and how many are female?
SELECT count(*),gender FROM artist GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the average rating of songs for each language?
SELECT avg(rating),languages FROM song GROUP BY languages; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the average song rating for each language?
SELECT avg(rating),languages FROM song GROUP BY languages; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### For each file format, return the number of artists who released songs in that format.
SELECT count(*),formats FROM files GROUP BY formats; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### How many songs were released for each format?
SELECT count(*),formats FROM files GROUP BY formats; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the distinct names of all songs that have a higher resolution than some songs in English.
SELECT DISTINCT song_name FROM song WHERE resolution > (SELECT min(resolution) FROM song WHERE languages = "english"); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the different names for all songs that have a higher resolution than English songs?
SELECT DISTINCT song_name FROM song WHERE resolution > (SELECT min(resolution) FROM song WHERE languages = "english"); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of all songs that have a lower rating than some song of blues genre?
SELECT song_name FROM song WHERE rating < (SELECT max(rating) FROM song WHERE genre_is = "blues"); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of the songs that have a lower rating than at least one blues song?
SELECT song_name FROM song WHERE rating < (SELECT max(rating) FROM song WHERE genre_is = "blues"); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### List the names of all genres in alphabetical oder, together with its ratings.
SELECT g_name,rating FROM genre ORDER BY g_name; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of all genres in alphabetical order, combined with its ratings?
SELECT g_name,rating FROM genre ORDER BY g_name; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Give me a list of the names of all songs ordered by their resolution.
SELECT song_name FROM song ORDER BY resolution; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of all songs that are ordered by their resolution numbers?
SELECT song_name FROM song ORDER BY resolution; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the ids of songs that are available in either mp4 format or have resolution above 720?
SELECT f_id FROM files WHERE formats = "mp4" UNION SELECT f_id FROM song WHERE resolution > 720; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the ids of all songs that are available on mp4 or have a higher resolution than 720?
SELECT f_id FROM files WHERE formats = "mp4" UNION SELECT f_id FROM song WHERE resolution > 720; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the language used most often in the songs?
SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the languages that are used most often in songs?
SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the language that was used most often in songs with resolution above 500?
SELECT artist_name FROM song WHERE resolution > 500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the name of the artist, for each language, that has the most songs with a higher resolution than 500?
SELECT artist_name FROM song WHERE resolution > 500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of artists who are Male and are from UK?
SELECT artist_name FROM artist WHERE country = "UK" AND gender = "Male"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of all male British artists?
SELECT artist_name FROM artist WHERE country = "UK" AND gender = "Male"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the names of songs whose genre is modern or language is English.
SELECT song_name FROM song WHERE genre_is = "modern" OR languages = "english"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of the songs that are modern or sung in English?
SELECT song_name FROM song WHERE genre_is = "modern" OR languages = "english"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the average rating and resolution of songs that are in Bangla?
SELECT avg(rating),avg(resolution) FROM song WHERE languages = "bangla"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the average rating and resolution of all bangla songs?
SELECT avg(rating),avg(resolution) FROM song WHERE languages = "bangla"; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of the songs whose rating is below the rating of all songs in English?
SELECT song_name FROM song WHERE rating < (SELECT min(rating) FROM song WHERE languages = 'english'); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the song names for every song whose rating is less than the minimum rating for English songs?
SELECT song_name FROM song WHERE rating < (SELECT min(rating) FROM song WHERE languages = 'english'); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is ids of the songs whose resolution is higher than the resolution of any songs with rating lower than 8?
SELECT f_id FROM song WHERE resolution > (SELECT max(resolution) FROM song WHERE rating < 8); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the id of every song that has a resolution higher than that of a song with a rating below 8?
SELECT f_id FROM song WHERE resolution > (SELECT max(resolution) FROM song WHERE rating < 8); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is ids of the songs whose resolution is higher than the average resolution of songs in modern genre?
SELECT f_id FROM song WHERE resolution > (SELECT avg(resolution) FROM song WHERE genre_is = "modern"); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the ids of all songs that have higher resolution of the average resolution in the modern genre?
SELECT f_id FROM song WHERE resolution > (SELECT avg(resolution) FROM song WHERE genre_is = "modern"); ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### List the id, genre and artist name of English songs ordered by rating.
SELECT f_id,genre_is,artist_name FROM song WHERE languages = "english" ORDER BY rating; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What is the id, genre, and name of the artist for every English song ordered by ascending rating?
SELECT f_id,genre_is,artist_name FROM song WHERE languages = "english" ORDER BY rating; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the names of the artists who have produced English songs but have never received rating higher than 8.
SELECT DISTINCT artist_name FROM song WHERE languages = "english" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating > 8; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of the different artists that have produced a song in English but have never receieved a rating higher than 8?
SELECT DISTINCT artist_name FROM song WHERE languages = "english" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating > 8; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### Find the names of the artists who are from Bangladesh and have never received rating higher than 7.
SELECT DISTINCT artist_name FROM artist WHERE country = "Bangladesh" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating > 7; ###
###Postgre SQL tables, with their properties:
# genre: ["genre_name", "rating", "most_popular_in"]
# artist: ["artist_name", "country", "gender", "preferred_genre"]
# files: ["song_id", "artist_name", "file_size", "duration", "formats"]
# song: ["song_name", "artist_name", "country", "song_id", "genre_is", "rating", "languages", "releasedate", "resolution"]
### What are the names of the different artists from Bangladesh who never received a rating higher than a 7?
SELECT DISTINCT artist_name FROM artist WHERE country = "Bangladesh" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating > 7; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How many players enter hall of fame each year?
SELECT yearid,count(*) FROM hall_of_fame GROUP BY yearid;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Count the number of players who enter hall of fame for each year.
SELECT yearid,count(*) FROM hall_of_fame GROUP BY yearid;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### What is the average number of attendance at home games for each year?
SELECT YEAR,avg(attendance) FROM home_game GROUP BY YEAR;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### For each year, return the year and the average number of attendance at home games.
SELECT YEAR,avg(attendance) FROM home_game GROUP BY YEAR;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How many parks are there in the state of NY?
SELECT count(*) FROM park WHERE state = 'NY';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Show me the number of parks the state of NY has.
SELECT count(*) FROM park WHERE state = 'NY';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### List three countries which are the origins of the least players.
SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### What are the three countries that the least players are from?
SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Find all the players' first name and last name who have empty death record.
SELECT name_first,name_last FROM player WHERE death_year = '';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### What are the first name and last name of the players whose death record is empty?
SELECT name_first,name_last FROM player WHERE death_year = '';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How many players born in USA are right-handed batters? That is, have the batter value 'R'.
SELECT count(*) FROM player WHERE birth_country = 'USA' AND bats = 'R';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Count the number of players who were born in USA and have bats information 'R'.
SELECT count(*) FROM player WHERE birth_country = 'USA' AND bats = 'R';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### List players' first name and last name who have weight greater than 220 or height shorter than 75.
SELECT name_first,name_last FROM player WHERE weight > 220 OR height < 75; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### What are the first name and last name of the players who have weight above 220 or height below 75?
SELECT name_first,name_last FROM player WHERE weight > 220 OR height < 75; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How many games in 1885 postseason resulted in ties (that is, the value of "ties" is '1')?
SELECT count(*) FROM postseason WHERE YEAR = 1885 AND ties = 1;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Find the number of tied games (the value of "ties" is '1') in 1885 postseason.
SELECT count(*) FROM postseason WHERE YEAR = 1885 AND ties = 1;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### List the 3 highest salaries of the players in 2001?
SELECT salary FROM salary WHERE YEAR = 2001 ORDER BY salary DESC LIMIT 3;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How much salary did the top 3 well-paid players get in 2001?
SELECT salary FROM salary WHERE YEAR = 2001 ORDER BY salary DESC LIMIT 3;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### What were all the salary values of players in 2010 and 2001?
SELECT salary FROM salary WHERE YEAR = 2010 UNION SELECT salary FROM salary WHERE YEAR = 2001; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### List all the salary values players received in 2010 and 2001.
SELECT salary FROM salary WHERE YEAR = 2010 UNION SELECT salary FROM salary WHERE YEAR = 2001; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### In which year did the least people enter hall of fame?
SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Find the year in which the least people enter hall of fame.
SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How many parks are there in Atlanta city?
SELECT count(*) FROM park WHERE city = 'Atlanta';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How many parks does Atlanta city have?
SELECT count(*) FROM park WHERE city = 'Atlanta';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### List the names of states that have more than 2 parks.
SELECT state FROM park GROUP BY state HAVING count(*) > 2;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Which states have more than 2 parks?
SELECT state FROM park GROUP BY state HAVING count(*) > 2;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### How many team franchises are active, with active value 'Y'?
SELECT count(*) FROM team_franchise WHERE active = 'Y';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Find the number of team franchises that are active (have 'Y' as "active" information).
SELECT count(*) FROM team_franchise WHERE active = 'Y';; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Which cities have 2 to 4 parks?
SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN 2 AND 4;; ###
###Postgre SQL tables, with their properties:
# all_star: ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"]
# appearances: ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"]
# manager_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# player_award: ["player_id", "award_id", "year", "league_id", "tie", "notes"]
# manager_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# player_award_vote: ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"]
# batting: ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# batting_postseason: ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"]
# player_college: ["player_id", "college_id", "year"]
# fielding: ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"]
# fielding_outfield: ["player_id", "year", "stint", "glf", "gcf", "grf"]
# fielding_postseason: ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"]
# hall_of_fame: ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"]
# home_game: ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"]
# manager: ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"]
# manager_half: ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"]
# player: ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"]
# park: ["park_id", "park_name", "park_alias", "city", "state", "country"]
# pitching: ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# pitching_postseason: ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"]
# salary: ["year", "team_id", "league_id", "player_id", "salary"]
# college: ["college_id", "name_full", "city", "state", "country"]
# postseason: ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"]
# team: ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"]
# team_franchise: ["franchise_id", "franchise_name", "active", "na_assoc"]
# team_half: ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]
### Find all the cities that have 2 to 4 parks.
SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN 2 AND 4;; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### How many camera lenses have a focal length longer than 15 mm?
SELECT count(*) FROM camera_lens WHERE focal_length_mm > 15; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### Find the brand and name for each camera lens, and sort in descending order of maximum aperture.
SELECT brand,name FROM camera_lens ORDER BY max_aperture DESC; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### List the id, color scheme, and name for all the photos.
SELECT id,color,name FROM photos; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### What are the maximum and average height of the mountains?
SELECT max(height),avg(height) FROM mountain; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### What are the average prominence of the mountains in country 'Morocco'?
SELECT avg(prominence) FROM mountain WHERE country = 'Morocco'; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### What are the name, height and prominence of mountains which do not belong to the range 'Aberdare Range'?
SELECT name,height,prominence FROM mountain WHERE range != 'Aberdare Range'; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### How many different kinds of lens brands are there?
SELECT count(DISTINCT brand) FROM camera_lens; ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### How many camera lenses are not used in taking any photos?
SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos ); ###
###Postgre SQL tables, with their properties:
# mountain: ["id", "name", "height", "prominence", "range", "country"]
# camera_lens: ["id", "brand", "name", "focal_length_mm", "max_aperture"]
# photos: ["id", "camera_lens_id", "mountain_id", "color", "name"]
### List the camera lens names containing substring "Digital".
SELECT name FROM camera_lens WHERE name LIKE "%Digital%"; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Find the names of channels that are not owned by CCTV.
SELECT name FROM channel WHERE OWNER != 'CCTV'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Which channels are not owned by CCTV? Give me the channel names.
SELECT name FROM channel WHERE OWNER != 'CCTV'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### List all channel names ordered by their rating in percent from big to small.
SELECT name FROM channel ORDER BY rating_in_percent DESC; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Give me a list of all the channel names sorted by the channel rating in descending order.
SELECT name FROM channel ORDER BY rating_in_percent DESC; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### What is the owner of the channel that has the highest rating ratio?
SELECT OWNER FROM channel ORDER BY rating_in_percent DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Show me the owner of the channel with the highest rating.
SELECT OWNER FROM channel ORDER BY rating_in_percent DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### how many programs are there?
SELECT count(*) FROM program; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Count the number of programs.
SELECT count(*) FROM program; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### list all the names of programs, ordering by launch time.
SELECT name FROM program ORDER BY launch; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### What is the list of program names, sorted by the order of launch date?
SELECT name FROM program ORDER BY launch; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### List the name, origin and owner of each program.
SELECT name,origin,OWNER FROM program; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### What are the name, origin and owner of each program?
SELECT name,origin,OWNER FROM program; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### find the name of the program that was launched most recently.
SELECT name FROM program ORDER BY launch DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Which program was launched most recently? Return the program name.
SELECT name FROM program ORDER BY launch DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### find the total percentage share of all channels owned by CCTV.
SELECT sum(Share_in_percent) FROM channel WHERE OWNER = 'CCTV'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### What is the total share (in percent) of all the channels owned by CCTV?
SELECT sum(Share_in_percent) FROM channel WHERE OWNER = 'CCTV'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### how many programs are broadcast in each time section of the day?
SELECT count(*),time_of_day FROM broadcast GROUP BY time_of_day; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Count the number of programs broadcast for each time section of a day.
SELECT count(*),time_of_day FROM broadcast GROUP BY time_of_day; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### find the number of different programs that are broadcast during night time.
SELECT count(DISTINCT program_id) FROM broadcast WHERE time_of_day = 'Night'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### How many distinct programs are broadcast at "Night" time?
SELECT count(DISTINCT program_id) FROM broadcast WHERE time_of_day = 'Night'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### List all program origins in the alphabetical order.
SELECT origin FROM program ORDER BY origin; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### What is the list of program origins ordered alphabetically?
SELECT origin FROM program ORDER BY origin; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### what is the number of different channel owners?
SELECT count(DISTINCT OWNER) FROM channel; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Count the number of distinct channel owners.
SELECT count(DISTINCT OWNER) FROM channel; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### find the names of programs whose origin is not in Beijing.
SELECT name FROM program WHERE origin != 'Beijing'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Which programs' origins are not "Beijing"? Give me the program names.
SELECT name FROM program WHERE origin != 'Beijing'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### What are the names of the channels owned by CCTV or HBS?
SELECT name FROM channel WHERE OWNER = 'CCTV' OR OWNER = 'HBS'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### List the names of all the channels owned by either CCTV or HBS
SELECT name FROM channel WHERE OWNER = 'CCTV' OR OWNER = 'HBS'; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### Find the total rating ratio for each channel owner.
SELECT sum(Rating_in_percent),OWNER FROM channel GROUP BY OWNER; ###
###Postgre SQL tables, with their properties:
# program: ["program_id", "name", "origin", "launch", "owner"]
# channel: ["channel_id", "name", "owner", "share_in_percent", "rating_in_percent"]
# broadcast: ["channel_id", "program_id", "time_of_day"]
# broadcast_share: ["channel_id", "program_id", "date", "share_in_percent"]
### What is the total rating of channel for each channel owner?
SELECT sum(Rating_in_percent),OWNER FROM channel GROUP BY OWNER; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### How many courses are there in total?
SELECT count(*) FROM COURSES; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the total number of courses offered.
SELECT count(*) FROM COURSES; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the descriptions of the courses with name "database"?
SELECT course_description FROM COURSES WHERE course_name = "database"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Return the description for the courses named "database".
SELECT course_description FROM COURSES WHERE course_name = "database"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the addresses of the course authors or tutors with personal name "Cathrine"
SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name	 = "Cathrine"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Return the addresses of the course authors or tutors whose personal name is "Cathrine".
SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name	 = "Cathrine"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### List the addresses of all the course authors or tutors.
SELECT address_line_1 FROM Course_Authors_and_Tutors; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What is the address of each course author or tutor?
SELECT address_line_1 FROM Course_Authors_and_Tutors; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### List all the login names and family names of course author and tutors.
SELECT login_name,family_name FROM Course_Authors_and_Tutors; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the login names and family names of course author and tutors?
SELECT login_name,family_name FROM Course_Authors_and_Tutors; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### List all the dates of enrollment and completion of students.
SELECT date_of_enrolment,date_of_completion FROM Student_Course_Enrolment; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are all the dates of enrollment and completion in record?
SELECT date_of_enrolment,date_of_completion FROM Student_Course_Enrolment; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### How many distinct students are enrolled in courses?
SELECT count(DISTINCT student_id) FROM Student_Course_Enrolment; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the number of distinct students enrolled in courses.
SELECT count(DISTINCT student_id) FROM Student_Course_Enrolment; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### How many distinct courses are enrolled in by students?
SELECT count(course_id) FROM Student_Course_Enrolment; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the number of distinct courses that have enrolled students.
SELECT count(course_id) FROM Student_Course_Enrolment; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the dates of the tests taken with result "Pass".
SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result = "Pass"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Which tests have "Pass" results? Return the dates when the tests were taken.
SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result = "Pass"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### How many tests have result "Fail"?
SELECT count(*) FROM Student_Tests_Taken WHERE test_result = "Fail"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Count the number of tests with "Fail" result.
SELECT count(*) FROM Student_Tests_Taken WHERE test_result = "Fail"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the login names of the students with family name "Ward"?
SELECT login_name FROM Students WHERE family_name = "Ward"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Return the login names of the students whose family name is "Ward".
SELECT login_name FROM Students WHERE family_name = "Ward"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the dates of the latest logon of the students with family name "Jaskolski" or "Langosh"?
SELECT date_of_latest_logon FROM Students WHERE family_name = "Jaskolski" OR family_name = "Langosh"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the latest logon date of the students whose family name is "Jaskolski" or "Langosh".
SELECT date_of_latest_logon FROM Students WHERE family_name = "Jaskolski" OR family_name = "Langosh"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### How many students have personal names that contain the word "son"?
SELECT COUNT(*) FROM Students WHERE personal_name LIKE "%son%"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the number of students who have the word "son" in their personal names.
SELECT COUNT(*) FROM Students WHERE personal_name LIKE "%son%"; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### List all the subject names.
SELECT subject_name FROM SUBJECTS; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the names of all the subjects.
SELECT subject_name FROM SUBJECTS; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### List all the information about course authors and tutors in alphabetical order of the personal name.
SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Sort the information about course authors and tutors in alphabetical order of the personal name.
SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### List the personal names and family names of all the students in alphabetical order of family name.
SELECT personal_name,family_name FROM Students ORDER BY family_name; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the personal names and family names of the students? Sort the result in alphabetical order of the family name.
SELECT personal_name,family_name FROM Students ORDER BY family_name; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### List each test result and its count in descending order of count.
SELECT test_result,COUNT(*) FROM Student_Tests_Taken GROUP BY test_result ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### For each distinct test result, find the number of students who got the result.
SELECT test_result,COUNT(*) FROM Student_Tests_Taken GROUP BY test_result ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### How many students did not have any course enrollment?
SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment); ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Count the number of students who did not enroll in any course.
SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment); ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the common login name of course authors and students.
SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the login names used both by some course authors and some students?
SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### Find the common personal name of course authors and students.
SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students; ###
###Postgre SQL tables, with their properties:
# course_authors_and_tutors: ["author_id", "author_tutor_atb", "login_name", "password", "personal_name", "middle_name", "family_name", "gender_mf", "address_line_1"]
# students: ["student_id", "date_of_registration", "date_of_latest_logon", "login_name", "password", "personal_name", "middle_name", "family_name"]
# subjects: ["subject_id", "subject_name"]
# courses: ["course_id", "author_id", "subject_id", "course_name", "course_description"]
# student_course_enrolment: ["registration_id", "student_id", "course_id", "date_of_enrolment", "date_of_completion"]
# student_tests_taken: ["registration_id", "date_test_taken", "test_result"]
### What are the personal names used both by some course authors and some students?
SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### List the method, date and amount of all the payments, in ascending order of date.
SELECT Payment_Method_Code,Date_Payment_Made,Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What are the method, date and amount of each payment? Sort the list in ascending order of date.
SELECT Payment_Method_Code,Date_Payment_Made,Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Among all the claims, what is the settlement amount of the claim with the largest claim amount? List both the settlement amount and claim amount.
SELECT Amount_Settled,Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.
SELECT Amount_Settled,Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Among all the claims, what is the amount claimed in the claim with the least amount settled? List both the settlement amount and claim amount.
SELECT Amount_Settled,Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Find the claimed amount in the claim with the least amount settled. Show both the settlement amount and claim amount.
SELECT Amount_Settled,Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Among all the claims, which claims have a claimed amount larger than the average? List the date the claim was made and the date it was settled.
SELECT Date_Claim_Made,Date_Claim_Settled FROM Claims WHERE Amount_Claimed > ( SELECT avg(Amount_Claimed) FROM Claims ); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Give me the claim date, settlement date for all the claims whose claimed amount is larger than the average.
SELECT Date_Claim_Made,Date_Claim_Settled FROM Claims WHERE Amount_Claimed > ( SELECT avg(Amount_Claimed) FROM Claims ); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.
SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled <= ( SELECT avg(Amount_Settled) FROM Claims ); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Return the claim start date for the claims whose claimed amount is no more than the average
SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled <= ( SELECT avg(Amount_Settled) FROM Claims ); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Of all the claims, what was the earliest date when any claim was made?
SELECT Date_Claim_Made FROM Claims ORDER BY Date_Claim_Made ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Tell me the the date when the first claim was made.
SELECT Date_Claim_Made FROM Claims ORDER BY Date_Claim_Made ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What is the total amount of settlement made for all the settlements?
SELECT sum(Amount_Settled) FROM Settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Compute the total amount of settlement across all the settlements.
SELECT sum(Amount_Settled) FROM Settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What are the claim dates and settlement dates of all the settlements?
SELECT Date_Claim_Made,Date_Claim_Settled FROM Settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Tell me the the claim date and settlement date for each settlement case.
SELECT Date_Claim_Made,Date_Claim_Settled FROM Settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What is the most popular payment method?
SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Which payment method is used the most often?
SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### With which kind of payment method were the least number of payments processed?
SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What is the payment method that were used the least often?
SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What is the total amount of payment?
SELECT sum(Amount_Payment) FROM Payments; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Compute the total amount of payment processed.
SELECT sum(Amount_Payment) FROM Payments; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What are all the distinct details of the customers?
SELECT DISTINCT customer_details FROM Customers; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Return the distinct customer details.
SELECT DISTINCT customer_details FROM Customers; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Which kind of policy type was chosen by the most customers?
SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Find the policy type the most customers choose.
SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### How many settlements are there in total?
SELECT count(*) FROM Settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Count the total number of settlements made.
SELECT count(*) FROM Settlements; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Which Payments were processed with Visa? List the payment Id, the date and the amount.
SELECT Payment_ID,Date_Payment_Made,Amount_Payment FROM Payments WHERE Payment_Method_Code = 'Visa'; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Give me the payment Id, the date and the amount for all the payments processed with Visa.
SELECT Payment_ID,Date_Payment_Made,Amount_Payment FROM Payments WHERE Payment_Method_Code = 'Visa'; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### Find the total claimed amount of all the claims.
SELECT sum(Amount_Claimed) FROM Claims; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# customer_policies: ["policy_id", "customer_id", "policy_type_code", "start_date", "end_date"]
# claims: ["claim_id", "policy_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled"]
# settlements: ["settlement_id", "claim_id", "date_claim_made", "date_claim_settled", "amount_claimed", "amount_settled", "customer_policy_id"]
# payments: ["payment_id", "settlement_id", "payment_method_code", "date_payment_made", "amount_payment"]
### What is total amount claimed summed across all the claims?
SELECT sum(Amount_Claimed) FROM Claims; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Which department has the largest number of employees?
SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the department with the most employees.
SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What is the employee id of the head whose department has the least number of employees?
SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Tell me the employee id of the head of the department with the least employees.
SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the id of the appointment with the most recent start date?
SELECT appointmentid FROM appointment ORDER BY START DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What is the id of the appointment that started most recently?
SELECT appointmentid FROM appointment ORDER BY START DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### How many patients stay in room 112?
SELECT count(patient) FROM stay WHERE room = 112; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Count the number of patients who stayed in room 112.
SELECT count(patient) FROM stay WHERE room = 112; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the patient who most recently stayed in room 111.
SELECT patient FROM stay WHERE room = 111 ORDER BY staystart DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What is the id of the patient who stayed in room 111 most recently?
SELECT patient FROM stay WHERE room = 111 ORDER BY staystart DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What are the unique block codes that have available rooms?
SELECT DISTINCT blockcode FROM room WHERE unavailable = 0; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Tell me the distinct block codes where some rooms are available.
SELECT DISTINCT blockcode FROM room WHERE unavailable = 0; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### How many different types of rooms are there?
SELECT count(DISTINCT roomtype) FROM room; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the number of distinct room types available.
SELECT count(DISTINCT roomtype) FROM room; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the name of physicians whose position title contains the word 'senior'.
SELECT name FROM physician WHERE POSITION LIKE '%senior%'; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What are the names of the physicians who have 'senior' in their titles.
SELECT name FROM physician WHERE POSITION LIKE '%senior%'; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the patient who has the most recent undergoing treatment?
SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Which patient is undergoing the most recent treatment?
SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### List the names of all distinct nurses ordered by alphabetical order?
SELECT DISTINCT name FROM nurse ORDER BY name; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What is the alphabetically ordered list of all the distinct names of nurses?
SELECT DISTINCT name FROM nurse ORDER BY name; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### List the names of all distinct medications, ordered in an alphabetical order.
SELECT DISTINCT name FROM medication ORDER BY name; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What is the alphabetically ordered list of all distinct medications?
SELECT DISTINCT name FROM medication ORDER BY name; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### List the physicians' employee ids together with their primary affiliation departments' ids.
SELECT physician,department FROM affiliated_with WHERE primaryaffiliation = 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What are each physician's employee id and department id primarily affiliated.
SELECT physician,department FROM affiliated_with WHERE primaryaffiliation = 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What nurses are on call with block floor 1 and block code 1? Tell me their names.
SELECT nurse FROM on_call WHERE blockfloor = 1 AND blockcode = 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the ids of the nurses who are on call in block floor 1 and block code 1.
SELECT nurse FROM on_call WHERE blockfloor = 1 AND blockcode = 1; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What are the highest cost, lowest cost and average cost of procedures?
SELECT MAX(cost),MIN(cost),AVG(cost) FROM procedures; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Tell me the highest, lowest, and average cost of procedures.
SELECT MAX(cost),MIN(cost),AVG(cost) FROM procedures; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### List the name and cost of all procedures sorted by the cost from the highest to the lowest.
SELECT name,cost FROM procedures ORDER BY cost DESC; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Sort the list of names and costs of all procedures in the descending order of cost.
SELECT name,cost FROM procedures ORDER BY cost DESC; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Find the three most expensive procedures.
SELECT name FROM procedures ORDER BY cost LIMIT 3; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### What are the three most costly procedures?
SELECT name FROM procedures ORDER BY cost LIMIT 3; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### How many appointments are there?
SELECT count(*) FROM appointment; ###
###Postgre SQL tables, with their properties:
# physician: ["employee_id", "name", "position", "ssn"]
# department: ["departmentid", "name", "head"]
# affiliated_with: ["physician", "department", "primary_affiliation"]
# procedures: ["code", "name", "cost"]
# trained_in: ["physician", "treatment", "certification_date", "certification_expires"]
# patient: ["ssn", "name", "address", "phone", "insurance_id", "pcp"]
# nurse: ["employee_id", "name", "position", "registered", "ssn"]
# appointment: ["appointment_id", "patient", "prep_nurse", "physician", "start", "end", "examination_room"]
# medication: ["code", "name", "brand", "description"]
# prescribes: ["physician", "patient", "medication", "date", "appointment", "dose"]
# block: ["block_floor", "block_code"]
# room: ["roomnumber", "room_type", "block_floor", "block_code", "unavailable"]
# on_call: ["nurse", "block_floor", "block_code", "oncall_start", "oncall_end"]
# stay: ["stay_id", "patient", "room", "stay_start", "stay_end"]
# undergoes: ["patient", "procedures", "stay", "date_undergoes", "physician", "assisting_nurse"]
### Count how many appointments have been made in total.
SELECT count(*) FROM appointment; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### How many ships are there?
SELECT count(*) FROM ship; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What is the number of ships?
SELECT count(*) FROM ship; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### List the name of ships in ascending order of tonnage.
SELECT Name FROM ship ORDER BY Tonnage ASC; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### what are the names of the ships ordered by ascending tonnage?
SELECT Name FROM ship ORDER BY Tonnage ASC; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What are the type and nationality of ships?
SELECT TYPE,Nationality FROM ship; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What are the types and nationalities of every ship?
SELECT TYPE,Nationality FROM ship; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### List the name of ships whose nationality is not "United_States".
SELECT Name FROM ship WHERE Nationality != "United_States"; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What are the names of the ships that are not from the United States?
SELECT Name FROM ship WHERE Nationality != "United_States"; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### Show the name of ships whose nationality is either United States or United Kingdom.
SELECT Name FROM ship WHERE Nationality = "United_States" OR Nationality = "United_Kingdom"; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What are the names of the ships that are from either the US or the UK?
SELECT Name FROM ship WHERE Nationality = "United_States" OR Nationality = "United_Kingdom"; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What is the name of the ship with the largest tonnage?
SELECT Name FROM ship ORDER BY Tonnage DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What is the ship with the largest amount of tonnage called?
SELECT Name FROM ship ORDER BY Tonnage DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### Show different types of ships and the number of ships of each type.
SELECT TYPE,COUNT(*) FROM ship GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### For each type, how many ships are there?
SELECT TYPE,COUNT(*) FROM ship GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### Please show the most common type of ships.
SELECT TYPE FROM ship GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What is the most common type of ships?
SELECT TYPE FROM ship GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### List the nations that have more than two ships.
SELECT Nationality FROM ship GROUP BY Nationality HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What are the nations that have more than two ships?
SELECT Nationality FROM ship GROUP BY Nationality HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### Show different types of ships and the average tonnage of ships of each type.
SELECT TYPE,avg(Tonnage) FROM ship GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### For each type, what is the average tonnage?
SELECT TYPE,avg(Tonnage) FROM ship GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### List the name of ships that are not involved in any mission
SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission); ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What are the names of the ships that are not involved in any missions?
SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission); ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### Show the types of ships that have both ships with tonnage larger than 6000 and ships with tonnage smaller than 4000.
SELECT TYPE FROM ship WHERE Tonnage > 6000 INTERSECT SELECT TYPE FROM ship WHERE Tonnage < 4000; ###
###Postgre SQL tables, with their properties:
# mission: ["mission_id", "ship_id", "code", "launched_year", "location", "speed_knots", "fate"]
# ship: ["ship_id", "name", "type", "nationality", "tonnage"]
### What are the types of the ships that have both shiips with tonnage more than 6000 and those with tonnage less than 4000?
SELECT TYPE FROM ship WHERE Tonnage > 6000 INTERSECT SELECT TYPE FROM ship WHERE Tonnage < 4000; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the number of students in total.
SELECT count(*) FROM list; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### How many students are there?
SELECT count(*) FROM list; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the last names of students studying in room 111.
SELECT lastname FROM list WHERE classroom = 111; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### What are the last names of students in room 111?
SELECT lastname FROM list WHERE classroom = 111; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the first names of students studying in room 108.
SELECT firstname FROM list WHERE classroom = 108; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### What are the first names of students in room 108?
SELECT firstname FROM list WHERE classroom = 108; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### What are the first names of students studying in room 107?
SELECT DISTINCT firstname FROM list WHERE classroom = 107; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### List the first names of all the students in room 107.
SELECT DISTINCT firstname FROM list WHERE classroom = 107; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each classroom report the grade that is taught in it. Report just the classroom number and the grade number.
SELECT DISTINCT classroom,grade FROM list; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### What are the grade number and classroom number of each class in the list?
SELECT DISTINCT classroom,grade FROM list; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Which grade is studying in classroom 103?
SELECT DISTINCT grade FROM list WHERE classroom = 103; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the grade taught in classroom 103.
SELECT DISTINCT grade FROM list WHERE classroom = 103; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the grade studying in room 105.
SELECT DISTINCT grade FROM list WHERE classroom = 105; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Which grade is studying in room 105?
SELECT DISTINCT grade FROM list WHERE classroom = 105; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Which classrooms are used by grade 4?
SELECT DISTINCT classroom FROM list WHERE grade = 4; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the classrooms in which grade 4 is studying.
SELECT DISTINCT classroom FROM list WHERE grade = 4; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Which classrooms are used by grade 5?
SELECT DISTINCT classroom FROM list WHERE grade = 5; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Show me the classrooms grade 5 is using.
SELECT DISTINCT classroom FROM list WHERE grade = 5; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the first names of all the teachers that teach in classroom 110.
SELECT firstname FROM teachers WHERE classroom = 110; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Which teachers teach in classroom 110? Give me their first names.
SELECT firstname FROM teachers WHERE classroom = 110; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the last names of teachers teaching in classroom 109.
SELECT lastname FROM teachers WHERE classroom = 109; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Which teachers teach in classroom 109? Give me their last names.
SELECT lastname FROM teachers WHERE classroom = 109; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Report the first name and last name of all the teachers.
SELECT DISTINCT firstname,lastname FROM teachers; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### What are the first name and last name of all the teachers?
SELECT DISTINCT firstname,lastname FROM teachers; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Report the first name and last name of all the students.
SELECT DISTINCT firstname,lastname FROM list; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Show each student's first name and last name.
SELECT DISTINCT firstname,lastname FROM list; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each grade, report the grade, the number of classrooms in which it is taught and the total number of students in the grade.
SELECT grade,count(DISTINCT classroom),count(*) FROM list GROUP BY grade; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each grade, return the grade number, the number of classrooms used for the grade, and the total number of students enrolled in the grade.
SELECT grade,count(DISTINCT classroom),count(*) FROM list GROUP BY grade; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each classroom, report the classroom number and the number of grades using it.
SELECT classroom,count(DISTINCT grade) FROM list GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each classroom, show the classroom number and count the number of distinct grades that use the room.
SELECT classroom,count(DISTINCT grade) FROM list GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Which classroom has the most students?
SELECT classroom FROM list GROUP BY classroom ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the classroom that the most students use.
SELECT classroom FROM list GROUP BY classroom ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Report the number of students in each classroom.
SELECT classroom,count(*) FROM list GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each classroom, show the classroom number and find how many students are using it.
SELECT classroom,count(*) FROM list GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each grade 0 classroom, report the total number of students.
SELECT classroom,count(*) FROM list WHERE grade = "0" GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each grade 0 classroom, return the classroom number and the count of students.
SELECT classroom,count(*) FROM list WHERE grade = "0" GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Report the total number of students for each fourth-grade classroom.
SELECT classroom,count(*) FROM list WHERE grade = "4" GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### For each fourth-grade classroom, show the classroom number and the total number of students using it.
SELECT classroom,count(*) FROM list WHERE grade = "4" GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### Find the number of students in one classroom.
SELECT count(*),classroom FROM list GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# list: ["last_name", "first_name", "grade", "class_room"]
# teachers: ["last_name", "first_name", "class_room"]
### How many students does one classroom have?
SELECT count(*),classroom FROM list GROUP BY classroom; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### How many companies are headquartered in the US?
SELECT count(*) FROM company WHERE Headquarters = 'USA'; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### List the names of companies by ascending number of sales.
SELECT Name FROM company ORDER BY Sales_in_Billion ASC; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### What are the headquarters and industries of all companies?
SELECT Headquarters,Industry FROM company; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### Show the names of companies in the banking or retailing industry?
SELECT Name FROM company WHERE Industry = "Banking" OR Industry = "Retailing"; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### What is the maximum and minimum market value of companies?
SELECT max(Market_Value_in_Billion),min(Market_Value_in_Billion) FROM company; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### What is the headquarter of the company with the largest sales?
SELECT Headquarters FROM company ORDER BY Sales_in_Billion DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### Show the different headquarters and number of companies at each headquarter.
SELECT Headquarters,COUNT(*) FROM company GROUP BY Headquarters; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### Show the most common headquarter for companies.
SELECT Headquarters FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### Show the headquarters that have at least two companies.
SELECT Headquarters FROM company GROUP BY Headquarters HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### Show the headquarters that have both companies in banking industry and companies in oil and gas industry.
SELECT Headquarters FROM company WHERE Industry = "Banking" INTERSECT SELECT Headquarters FROM company WHERE Industry = "Oil_and_gas"; ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### List the names of people that are not employed by any company
SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM employment); ###
###Postgre SQL tables, with their properties:
# people: ["people_id", "age", "name", "nationality", "graduation_college"]
# company: ["company_id", "name", "headquarters", "industry", "sales_in_billion", "profits_in_billion", "assets_in_billion", "market_value_in_billion"]
# employment: ["company_id", "people_id", "year_working"]
### list the names of the companies with more than 200 sales in the descending order of sales and profits.
SELECT name FROM company WHERE Sales_in_Billion > 200 ORDER BY Sales_in_Billion,Profits_in_Billion DESC; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### How many film are there?
SELECT count(*) FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Count the number of films.
SELECT count(*) FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List the distinct director of all films.
SELECT DISTINCT Director FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the different film Directors?
SELECT DISTINCT Director FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What is the average ticket sales gross in dollars of films?
SELECT avg(Gross_in_dollar) FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Return the average gross sales in dollars across all films.
SELECT avg(Gross_in_dollar) FROM film; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the low and high estimates of film markets?
SELECT Low_Estimate,High_Estimate FROM film_market_estimation; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Return the low and high estimates for all film markets.
SELECT Low_Estimate,High_Estimate FROM film_market_estimation; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the types of film market estimations in year 1995?
SELECT TYPE FROM film_market_estimation WHERE YEAR = 1995; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Return the types of film market estimations in 1995.
SELECT TYPE FROM film_market_estimation WHERE YEAR = 1995; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the maximum and minimum number of cities in all markets.
SELECT max(Number_cities),min(Number_cities) FROM market; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Return the maximum and minimum number of cities across all markets.
SELECT max(Number_cities),min(Number_cities) FROM market; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### How many markets have number of cities smaller than 300?
SELECT count(*) FROM market WHERE Number_cities < 300; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Count the number of markets that have a number of cities lower than 300.
SELECT count(*) FROM market WHERE Number_cities < 300; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List all countries of markets in ascending alphabetical order.
SELECT Country FROM market ORDER BY Country ASC; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the countries for each market, ordered alphabetically?
SELECT Country FROM market ORDER BY Country ASC; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List all countries of markets in descending order of number of cities.
SELECT Country FROM market ORDER BY Number_cities DESC; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the countries for each market ordered by decreasing number of cities?
SELECT Country FROM market ORDER BY Number_cities DESC; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List the studios of each film and the number of films produced by that studio.
SELECT Studio,COUNT(*) FROM film GROUP BY Studio; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### How films are produced by each studio?
SELECT Studio,COUNT(*) FROM film GROUP BY Studio; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List the name of film studio that have the most number of films.
SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What is the name of teh studio that created the most films?
SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List the names of studios that have at least two films.
SELECT Studio FROM film GROUP BY Studio HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the names of studios that have made two or more films?
SELECT Studio FROM film GROUP BY Studio HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List the title of films that do not have any market estimation.
SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation); ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the titles of films that do not have a film market estimation?
SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation); ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Show the studios that have produced films with director "Nicholas_Meyer" and "Walter_Hill".
SELECT Studio FROM film WHERE Director = "Nicholas_Meyer" INTERSECT SELECT Studio FROM film WHERE Director = "Walter_Hill"; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the names of studios that have produced films with both Nicholas Meyer and Walter Hill?
SELECT Studio FROM film WHERE Director = "Nicholas_Meyer" INTERSECT SELECT Studio FROM film WHERE Director = "Walter_Hill"; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Find the titles and studios of the films that are produced by some film studios that contained the word "Universal".
SELECT title,Studio FROM film WHERE Studio LIKE "%Universal%"; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### What are the titles and studios of films that have been produced by a studio whose name contains "Universal"?
SELECT title,Studio FROM film WHERE Studio LIKE "%Universal%"; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Show the studios that have not produced films with director "Walter_Hill".
SELECT Studio FROM film EXCEPT SELECT Studio FROM film WHERE Director = "Walter_Hill"; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Which studios have never worked with the director Walter Hill?
SELECT Studio FROM film EXCEPT SELECT Studio FROM film WHERE Director = "Walter_Hill"; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### List the studios which average gross is above 4500000.
SELECT Studio FROM film GROUP BY Studio HAVING avg(Gross_in_dollar) >= 4500000; ###
###Postgre SQL tables, with their properties:
# film: ["film_id", "title", "studio", "director", "gross_in_dollar"]
# market: ["market_id", "country", "number_cities"]
# film_market_estimation: ["estimation_id", "low_estimate", "high_estimate", "film_id", "type", "market_id", "year"]
### Which studios have an average gross of over 4500000?
SELECT Studio FROM film GROUP BY Studio HAVING avg(Gross_in_dollar) >= 4500000; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### How many calendar items do we have?
SELECT count(*) FROM Ref_calendar; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Count the number of all the calendar items.
SELECT count(*) FROM Ref_calendar; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show all calendar dates and day Numbers.
SELECT calendar_date,day_Number FROM Ref_calendar; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are all the calendar dates and day Numbers?
SELECT calendar_date,day_Number FROM Ref_calendar; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the number of document types.
SELECT count(*) FROM Ref_document_types; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### How many document types are there?
SELECT count(*) FROM Ref_document_types; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### List all document type codes and document type names.
SELECT document_type_code,document_type_name FROM Ref_document_types; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are all the document type codes and document type names?
SELECT document_type_code,document_type_name FROM Ref_document_types; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the name and description for document type code RV?
SELECT document_type_name,document_type_description FROM Ref_document_types WHERE document_type_code = "RV"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Give me the name and description of the document type code RV.
SELECT document_type_name,document_type_description FROM Ref_document_types WHERE document_type_code = "RV"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the document type code for document type "Paper"?
SELECT document_type_code FROM Ref_document_types WHERE document_type_name = "Paper"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Find the code of the document type "Paper".
SELECT document_type_code FROM Ref_document_types WHERE document_type_name = "Paper"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the number of documents with document type code CV or BK.
SELECT count(*) FROM All_documents WHERE document_type_code = "CV" OR document_type_code = "BK"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### How many documents have document type code CV or BK?
SELECT count(*) FROM All_documents WHERE document_type_code = "CV" OR document_type_code = "BK"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the date when the document "Marry_CV" was stored?
SELECT date_stored FROM All_documents WHERE Document_name = "Marry_CV"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### When was the document named "Marry_CV" stored? Give me the date.
SELECT date_stored FROM All_documents WHERE Document_name = "Marry_CV"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the number of locations.
SELECT count(*) FROM Ref_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### How many locations are listed in the database?
SELECT count(*) FROM Ref_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### List all location codes and location names.
SELECT location_code,location_name FROM Ref_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are all the location codes and location names?
SELECT location_code,location_name FROM Ref_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the name and description for location code x?
SELECT location_name,location_description FROM Ref_locations WHERE location_code = "x"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Give me the name and description of the location with code x.
SELECT location_name,location_description FROM Ref_locations WHERE location_code = "x"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the location code for the country "Canada"?
SELECT location_code FROM Ref_locations WHERE location_name = "Canada"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the location code of the country "Canada".
SELECT location_code FROM Ref_locations WHERE location_name = "Canada"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### How many roles are there?
SELECT count(*) FROM ROLES; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Count the total number of roles listed.
SELECT count(*) FROM ROLES; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### List all role codes, role names, and role descriptions.
SELECT role_code,role_name,role_description FROM ROLES; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are all the role codes, role names, and role descriptions?
SELECT role_code,role_name,role_description FROM ROLES; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the name and description for role code "MG"?
SELECT role_name,role_description FROM ROLES WHERE role_code = "MG"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Find the name and description of the role with code "MG".
SELECT role_name,role_description FROM ROLES WHERE role_code = "MG"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the description for role name "Proof_Reader".
SELECT role_description FROM ROLES WHERE role_name = "Proof_Reader"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the description of the role named "Proof_Reader"?
SELECT role_description FROM ROLES WHERE role_name = "Proof_Reader"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### How many employees do we have?
SELECT count(*) FROM Employees; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Find the number of employees we have.
SELECT count(*) FROM Employees; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the name, role code, and date of birth for the employee with name 'Armani'.
SELECT employee_name,role_code,date_of_birth FROM Employees WHERE employee_Name = 'Armani'; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the name, role code, and date of birth of the employee named 'Armani'?
SELECT employee_name,role_code,date_of_birth FROM Employees WHERE employee_Name = 'Armani'; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the id for the employee called Ebba?
SELECT employee_ID FROM Employees WHERE employee_name = "Ebba"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the id of the employee named Ebba.
SELECT employee_ID FROM Employees WHERE employee_name = "Ebba"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the names of all the employees with role "HR".
SELECT employee_name FROM Employees WHERE role_code = "HR"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Which employees have the role with code "HR"? Find their names.
SELECT employee_name FROM Employees WHERE role_code = "HR"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show all role codes and the number of employees in each role.
SELECT role_code,count(*) FROM Employees GROUP BY role_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the code of each role and the number of employees in each role?
SELECT role_code,count(*) FROM Employees GROUP BY role_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the role code with the largest number of employees?
SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Find the code of the role that have the most employees.
SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show all role codes with at least 3 employees.
SELECT role_code FROM Employees GROUP BY role_code HAVING count(*) >= 3; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the roles with three or more employees? Give me the role codes.
SELECT role_code FROM Employees GROUP BY role_code HAVING count(*) >= 3; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the role code with the least employees.
SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the role with the smallest number of employees? Find the role codes.
SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the different location codes for documents?
SELECT DISTINCT location_code FROM Document_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Give me all the distinct location codes for documents.
SELECT DISTINCT location_code FROM Document_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the location code, the starting date and ending data in that location for all the documents.
SELECT location_code,date_in_location_from,date_in_locaton_to FROM Document_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are each document's location code, and starting date and ending data in that location?
SELECT location_code,date_in_location_from,date_in_locaton_to FROM Document_locations; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the location codes and the number of documents in each location.
SELECT location_code,count(*) FROM Document_locations GROUP BY location_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the code of each location and the number of documents in that location?
SELECT location_code,count(*) FROM Document_locations GROUP BY location_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What is the location code with the most documents?
SELECT location_code FROM Document_locations GROUP BY location_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Find the code of the location with the largest number of documents.
SELECT location_code FROM Document_locations GROUP BY location_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the location codes with at least 3 documents.
SELECT location_code FROM Document_locations GROUP BY location_code HAVING count(*) >= 3; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the codes of the locations with at least three documents?
SELECT location_code FROM Document_locations GROUP BY location_code HAVING count(*) >= 3; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the id of each employee and the number of document destruction authorised by that employee.
SELECT Destruction_Authorised_by_Employee_ID,count(*) FROM Documents_to_be_destroyed GROUP BY Destruction_Authorised_by_Employee_ID; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the id of each employee and the number of document destruction authorised by that employee?
SELECT Destruction_Authorised_by_Employee_ID,count(*) FROM Documents_to_be_destroyed GROUP BY Destruction_Authorised_by_Employee_ID; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the employee ids and the number of documents destroyed by each employee.
SELECT Destroyed_by_Employee_ID,count(*) FROM Documents_to_be_destroyed GROUP BY Destroyed_by_Employee_ID; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the id of each employee and the number of document destroyed by that employee?
SELECT Destroyed_by_Employee_ID,count(*) FROM Documents_to_be_destroyed GROUP BY Destroyed_by_Employee_ID; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the ids of the employees who don't authorize destruction for any document.
SELECT employee_id FROM Employees EXCEPT SELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Which employees do not authorize destruction for any document? Give me their employee ids.
SELECT employee_id FROM Employees EXCEPT SELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the ids of all employees who have authorized destruction.
SELECT DISTINCT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the ids of all the employees who authorize document destruction?
SELECT DISTINCT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the ids of all employees who have destroyed a document.
SELECT DISTINCT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### What are the ids of all the employees who have destroyed documents?
SELECT DISTINCT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the ids of all employees who don't destroy any document.
SELECT employee_id FROM Employees EXCEPT SELECT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Which employees do not destroy any document? Find their employee ids.
SELECT employee_id FROM Employees EXCEPT SELECT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Show the ids of all employees who have either destroyed a document or made an authorization to do this.
SELECT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed UNION SELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_calendar: ["calendar_date", "day_number"]
# reference_locations: ["location_code", "location_name", "location_description"]
# roles: ["role_code", "role_name", "role_description"]
# all_documents: ["document_id", "date_stored", "document_type_code", "document_name", "document_description", "other_details"]
# employees: ["employee_id", "role_code", "employee_name", "gender_mfu", "date_of_birth", "other_details"]
# document_locations: ["document_id", "location_code", "date_in_location_from", "date_in_locaton_to"]
# documents_to_be_destroyed: ["document_id", "destruction_authorised_by_employee_id", "destroyed_by_employee_id", "planned_destruction_date", "actual_destruction_date", "other_details"]
### Which employees have either destroyed a document or made an authorization to do so? Return their employee ids.
SELECT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed UNION SELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### How many clubs are there?
SELECT count(*) FROM club; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Count the total number of clubs.
SELECT count(*) FROM club; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### What are the names of all clubs?
SELECT clubname FROM club; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Give me the name of each club.
SELECT clubname FROM club; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### How many students are there?
SELECT count(*) FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Count the total number of students.
SELECT count(*) FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### What are the first names of all the students?
SELECT DISTINCT fname FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Find each student's first name.
SELECT DISTINCT fname FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### What is the description of the club named "Tennis_Club"?
SELECT clubdesc FROM club WHERE clubname = "Tennis_Club"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Find the description of the club called "Tennis_Club".
SELECT clubdesc FROM club WHERE clubname = "Tennis_Club"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Find the description of the club "Pen_and_Paper_Gaming".
SELECT clubdesc FROM club WHERE clubname = "Pen_and_Paper_Gaming"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### What is the description of the club "Pen_and_Paper_Gaming"?
SELECT clubdesc FROM club WHERE clubname = "Pen_and_Paper_Gaming"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### What is the location of the club named "Tennis_Club"?
SELECT clublocation FROM club WHERE clubname = "Tennis_Club"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Where us the club named "Tennis_Club" located?
SELECT clublocation FROM club WHERE clubname = "Tennis_Club"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Find the location of the club "Pen_and_Paper_Gaming".
SELECT clublocation FROM club WHERE clubname = "Pen_and_Paper_Gaming"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Where is the club "Pen_and_Paper_Gaming" located?
SELECT clublocation FROM club WHERE clubname = "Pen_and_Paper_Gaming"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Where is the club "Hopkins_Student_Enterprises" located?
SELECT clublocation FROM club WHERE clubname = "Hopkins_Student_Enterprises"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Tell me the location of the club "Hopkins_Student_Enterprises".
SELECT clublocation FROM club WHERE clubname = "Hopkins_Student_Enterprises"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Find the name of all the clubs at "AKW".
SELECT clubname FROM club WHERE clublocation = "AKW"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Which clubs are located at "AKW"? Return the club names.
SELECT clubname FROM club WHERE clublocation = "AKW"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### How many clubs are located at "HHH"?
SELECT count(*) FROM club WHERE clublocation = "HHH"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# club: ["club_id", "club_name", "club_description", "club_location"]
# member_of_club: ["student_id", "club_id", "position"]
### Count the number of clubs located at "HHH".
SELECT count(*) FROM club WHERE clublocation = "HHH"; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### List from which date and to which date these staff work: project staff of the project which hires the most staffs
SELECT date_from,date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from,date_to FROM Project_Staff WHERE role_code = 'leader'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?
SELECT date_from,date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from,date_to FROM Project_Staff WHERE role_code = 'leader'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### List the project details of the projects which did not hire any staff for a researcher role.
SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code = 'researcher' ); ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What are the details for all projects that did not hire any staff in a research role?
SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code = 'researcher' ); ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### When do all the researcher role staff start to work, and when do they stop working?
SELECT date_from,date_to FROM Project_Staff WHERE role_code = 'researcher'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### When did researchers start and stop working?
SELECT date_from,date_to FROM Project_Staff WHERE role_code = 'researcher'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many kinds of roles are there for the staff?
SELECT count(DISTINCT role_code) FROM Project_Staff; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many different roles are there on the project staff?
SELECT count(DISTINCT role_code) FROM Project_Staff; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the total amount of grants given by each organisations? Also list the organisation id.
SELECT sum(grant_amount),organisation_id FROM Grants GROUP BY organisation_id; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the total amount of grant money given to each organization and what is its id?
SELECT sum(grant_amount),organisation_id FROM Grants GROUP BY organisation_id; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the complete description of the researcher role.
SELECT role_description FROM Staff_Roles WHERE role_code = 'researcher'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the complete description of the job of a researcher?
SELECT role_description FROM Staff_Roles WHERE role_code = 'researcher'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### When did the first staff for the projects started working?
SELECT date_from FROM Project_Staff ORDER BY date_from ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### When did the first staff member start working?
SELECT date_from FROM Project_Staff ORDER BY date_from ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### Which projects have no outcome? List the project details.
SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes ); ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What are the details of the project with no outcomes?
SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes ); ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### Which document type is described with the prefix 'Initial'?
SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the type of the document whose description starts with the word 'Initial'?
SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many documents can one grant have at most? List the grant id and number.
SELECT grant_id,count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### For each grant id, how many documents does it have, and which one has the most?
SELECT grant_id,count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many Patent outcomes are generated from all the projects?
SELECT count(*) FROM Project_outcomes WHERE outcome_code = 'Patent'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many patents outcomes were listed for all the projects?
SELECT count(*) FROM Project_outcomes WHERE outcome_code = 'Patent'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?
SELECT count(*) FROM Project_Staff WHERE role_code = 'leader' OR date_from < '1989-04-24 23:51:54'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many project members were leaders or started working before '1989-04-24 23:51:54'?
SELECT count(*) FROM Project_Staff WHERE role_code = 'leader' OR date_from < '1989-04-24 23:51:54'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the last date of the staff leaving the projects?
SELECT date_to FROM Project_Staff ORDER BY date_to DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the last date that a staff member left a project?
SELECT date_to FROM Project_Staff ORDER BY date_to DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### List the project details of the projects launched by the organisation
SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 ); ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What are the details for the projects which were launched by the organization with the most projects?
SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 ); ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### List the research staff details, and order in ascending order.
SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What details are there on the research staff? List the result in ascending alphabetical order.
SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many tasks are there in total?
SELECT count(*) FROM Tasks; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### How many tasks are there?
SELECT count(*) FROM Tasks; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What are the staff roles of the staff who
SELECT role_code FROM Project_Staff WHERE date_from > '2003-04-19 15:06:20' AND date_to < '2016-03-15 00:33:18'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What roles did staff members play between '2003-04-19 15:06:20' and '2016-03-15 00:33:18'?
SELECT role_code FROM Project_Staff WHERE date_from > '2003-04-19 15:06:20' AND date_to < '2016-03-15 00:33:18'; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### Which role is most common for the staff?
SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# document_types: ["document_type_code", "document_description"]
# documents: ["document_id", "document_type_code", "grant_id", "sent_date", "response_received_date", "other_details"]
# grants: ["grant_id", "organisation_id", "grant_amount", "grant_start_date", "grant_end_date", "other_details"]
# organisation_types: ["organisation_type", "organisation_type_description"]
# organisations: ["organisation_id", "organisation_type", "organisation_details"]
# project_outcomes: ["project_id", "outcome_code", "outcome_details"]
# project_staff: ["staff_id", "project_id", "role_code", "date_from", "date_to", "other_details"]
# projects: ["project_id", "organisation_id", "project_details"]
# research_outcomes: ["outcome_code", "outcome_description"]
# research_staff: ["staff_id", "employer_organisation_id", "staff_details"]
# staff_roles: ["role_code", "role_description"]
# tasks: ["task_id", "project_id", "task_details", "eg_agree_objectives"]
### What is the most common role for the staff?
SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many females does this network has?
SELECT count(*) FROM Person WHERE gender = 'female'; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many females are in the network?
SELECT count(*) FROM Person WHERE gender = 'female'; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the average age for all person?
SELECT avg(age) FROM Person; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the average age for all people in the table?
SELECT avg(age) FROM Person; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many different cities are they from?
SELECT count(DISTINCT city) FROM Person; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many different cities do people originate from?
SELECT count(DISTINCT city) FROM Person; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many type of jobs do they have?
SELECT count(DISTINCT job) FROM Person; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many different jobs are listed?
SELECT count(DISTINCT job) FROM Person; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Who is the oldest person?
SELECT name FROM Person WHERE age = (SELECT max(age) FROM person); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the name of the person who is the oldest?
SELECT name FROM Person WHERE age = (SELECT max(age) FROM person); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Who is the oldest person whose job is student?
SELECT name FROM Person WHERE job = 'student' AND age = (SELECT max(age) FROM person WHERE job = 'student' ); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the name of the oldest student?
SELECT name FROM Person WHERE job = 'student' AND age = (SELECT max(age) FROM person WHERE job = 'student' ); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Who is the youngest male?
SELECT name FROM Person WHERE gender = 'male' AND age = (SELECT min(age) FROM person WHERE gender = 'male' ); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the name of the youngest male?
SELECT name FROM Person WHERE gender = 'male' AND age = (SELECT min(age) FROM person WHERE gender = 'male' ); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How old is the doctor named Zach?
SELECT age FROM Person WHERE job = 'doctor' AND name = 'Zach'; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the age of the doctor named Zach?
SELECT age FROM Person WHERE job = 'doctor' AND name = 'Zach'; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Who is the person whose age is below 30?
SELECT name FROM Person WHERE age < 30; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the name of the person whose age is below 30?
SELECT name FROM Person WHERE age < 30; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many people whose age is greater 30 and job is engineer?
SELECT count(*) FROM Person WHERE age > 30 AND job = 'engineer'; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### HOw many engineers are older than 30?
SELECT count(*) FROM Person WHERE age > 30 AND job = 'engineer'; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the average age for each gender?
SELECT avg(age),gender FROM Person GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How old is each gender, on average?
SELECT avg(age),gender FROM Person GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is average age for different job title?
SELECT avg(age),job FROM Person GROUP BY job; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How old is the average person for each job?
SELECT avg(age),job FROM Person GROUP BY job; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is average age of male for different job title?
SELECT avg(age),job FROM Person WHERE gender = 'male' GROUP BY job; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the average age for a male in each job?
SELECT avg(age),job FROM Person WHERE gender = 'male' GROUP BY job; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is minimum age for different job title?
SELECT min(age),job FROM Person GROUP BY job; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How old is the youngest person for each job?
SELECT min(age),job FROM Person GROUP BY job; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Find the number of people who is under 40 for each gender.
SELECT count(*),gender FROM Person WHERE age < 40 GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many people are under 40 for each gender?
SELECT count(*),gender FROM Person WHERE age < 40 GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Find the name of people whose age is greater than any engineer sorted by their age.
SELECT name FROM Person WHERE age > (SELECT min(age) FROM person WHERE job = 'engineer') ORDER BY age; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the name of all the people who are older than at least one engineer? Order them by age.
SELECT name FROM Person WHERE age > (SELECT min(age) FROM person WHERE job = 'engineer') ORDER BY age; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Find the number of people whose age is greater than all engineers.
SELECT count(*) FROM Person WHERE age > (SELECT max(age) FROM person WHERE job = 'engineer'); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### How many people are older than every engineer?
SELECT count(*) FROM Person WHERE age > (SELECT max(age) FROM person WHERE job = 'engineer'); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### list the name, job title of all people ordered by their names.
SELECT name,job FROM Person ORDER BY name; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What are the names and job titles of every person ordered alphabetically by name?
SELECT name,job FROM Person ORDER BY name; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Find the names of all person sorted in the descending order using age.
SELECT name FROM Person ORDER BY age DESC; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What are the names of everybody sorted by age in descending order?
SELECT name FROM Person ORDER BY age DESC; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Find the name and age of all males in order of their age.
SELECT name FROM Person WHERE gender = 'male' ORDER BY age; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the name and age of every male? Order the results by age.
SELECT name FROM Person WHERE gender = 'male' ORDER BY age; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Find the person who has exactly one friend.
SELECT name FROM PersonFriend GROUP BY name HAVING count(*) = 1; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What are the names of everybody who has exactly one friend?
SELECT name FROM PersonFriend GROUP BY name HAVING count(*) = 1; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Who is the friend of Zach with longest year relationship?
SELECT friend FROM PersonFriend WHERE name = 'Zach' AND YEAR = (SELECT max(YEAR) FROM PersonFriend WHERE name = 'Zach'); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Which friend of Zach has the longest-lasting friendship?
SELECT friend FROM PersonFriend WHERE name = 'Zach' AND YEAR = (SELECT max(YEAR) FROM PersonFriend WHERE name = 'Zach'); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Find the name of persons who are friends with Alice for the shortest years.
SELECT name FROM PersonFriend WHERE friend = 'Alice' AND YEAR = (SELECT min(YEAR) FROM PersonFriend WHERE friend = 'Alice'); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What are the names of all people who are friends with Alice for the shortest amount of time?
SELECT name FROM PersonFriend WHERE friend = 'Alice' AND YEAR = (SELECT min(YEAR) FROM PersonFriend WHERE friend = 'Alice'); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### Who is the person that has no friend?
SELECT name FROM person EXCEPT SELECT name FROM PersonFriend; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What are the names of all people who do not have friends?
SELECT name FROM person EXCEPT SELECT name FROM PersonFriend; ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the total number of people who has no friend living in the city of Austin.
SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city = 'Austin'); ###
###Postgre SQL tables, with their properties:
# person: ["name", "age", "city", "gender", "job"]
# person_friend: ["name", "friend", "year"]
### What is the total number of people who have no friends living in Austin?
SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city = 'Austin'); ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### How many members are there?
SELECT count(*) FROM member; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### List the names of members in ascending alphabetical order.
SELECT Name FROM member ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### What are the names and countries of members?
SELECT Name,Country FROM member; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### Show the names of members whose country is "United_States" or "Canada".
SELECT Name FROM member WHERE Country = "United_States" OR Country = "Canada"; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### Show the different countries and the number of members from each.
SELECT Country,COUNT(*) FROM member GROUP BY Country; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### Show the most common country across members.
SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### Which countries have more than two members?
SELECT Country FROM member GROUP BY Country HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### Show the leader names and locations of colleges.
SELECT Leader_Name,College_Location FROM college; ###
###Postgre SQL tables, with their properties:
# college: ["college_id", "name", "leader_name", "college_location"]
# member: ["member_id", "name", "country", "college_id"]
# round: ["round_id", "member_id", "decoration_theme", "rank_in_round"]
### List the names of members who did not participate in any round.
SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM round); ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the name and access counts of all documents, in alphabetic order of the document name.
SELECT document_name,access_count FROM documents ORDER BY document_name; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the names of all the documents, as well as the access counts of each, ordered alphabetically?
SELECT document_name,access_count FROM documents ORDER BY document_name; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the name of the document that has been accessed the greatest number of times, as well as the count of how many times it has been accessed?
SELECT document_name,access_count FROM documents ORDER BY access_count DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What is the name of the document which has been accessed the most times, as well as the number of times it has been accessed?
SELECT document_name,access_count FROM documents ORDER BY access_count DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the types of documents with more than 4 documents.
SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*) > 4; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the codes of types of documents of which there are for or more?
SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*) > 4; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the total access count of all documents in the most popular document type.
SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What is the total access count of documents that are of the most common document type?
SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What is the average access count of documents?
SELECT avg(access_count) FROM documents; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the average access count across all documents?
SELECT avg(access_count) FROM documents; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What is the type of the document named "David_CV"?
SELECT document_type_code FROM documents WHERE document_name = "David_CV"; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Return the type code of the document named "David_CV".
SELECT document_type_code FROM documents WHERE document_name = "David_CV"; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the list of documents that are both in the most three popular type and have the most three popular structure.
SELECT document_name FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 3 INTERSECT SELECT document_name FROM documents GROUP BY document_structure_code ORDER BY count(*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the names of documents that have both one of the three most common types and one of three most common structures?
SELECT document_name FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 3 INTERSECT SELECT document_name FROM documents GROUP BY document_structure_code ORDER BY count(*) DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What document types do have more than 10000 total access number.
SELECT document_type_code FROM documents GROUP BY document_type_code HAVING sum(access_count) > 10000; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Return the codes of the document types that do not have a total access count of over 10000.
SELECT document_type_code FROM documents GROUP BY document_type_code HAVING sum(access_count) > 10000; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find all the name of documents without any sections.
SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections); ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the names of documents that do not have any sections?
SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections); ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### List all the username and passwords of users with the most popular role.
SELECT user_name,password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the usernames and passwords of users that have the most common role?
SELECT user_name,password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### List all the document names which contains "CV".
SELECT document_name FROM documents WHERE document_name LIKE "%CV%"; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the names of documents that contain the substring "CV"?
SELECT document_name FROM documents WHERE document_name LIKE "%CV%"; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### How many users are logged in?
SELECT count(*) FROM users WHERE user_login = 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Count the number of users that are logged in.
SELECT count(*) FROM users WHERE user_login = 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the description of the most popular role among the users that have logged in.
SELECT role_description FROM ROLES WHERE role_code = (SELECT role_code FROM users WHERE user_login = 1 GROUP BY role_code ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What is the description of the most popular role among users that have logged in?
SELECT role_description FROM ROLES WHERE role_code = (SELECT role_code FROM users WHERE user_login = 1 GROUP BY role_code ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the average access count of documents with the least popular structure.
SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What is the average access count of documents that have the least common structure?
SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### List all the image name and URLs in the order of their names.
SELECT image_name,image_url FROM images ORDER BY image_name; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the names and urls of images, sorted alphabetically?
SELECT image_name,image_url FROM images ORDER BY image_name; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Find the number of users in each role.
SELECT count(*),role_code FROM users GROUP BY role_code; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What are the different role codes for users, and how many users have each?
SELECT count(*),role_code FROM users GROUP BY role_code; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### What document types have more than 2 corresponding documents?
SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# roles: ["role_code", "role_description"]
# users: ["user_id", "role_code", "user_name", "user_login", "password"]
# document_structures: ["document_structure_code", "parent_document_structure_code", "document_structure_description"]
# functional_areas: ["functional_area_code", "parent_functional_area_code", "functional_area_description"]
# images: ["image_id", "image_alt_text", "image_name", "image_url"]
# documents: ["document_code", "document_structure_code", "document_type_code", "access_count", "document_name"]
# document_functional_areas: ["document_code", "functional_area_code"]
# document_sections: ["section_id", "document_code", "section_sequence", "section_code", "section_title"]
# document_sections_images: ["section_id", "image_id"]
### Give the codes of document types that have more than 2 corresponding documents.
SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### How many companies are there?
SELECT count(*) FROM Companies; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Count the number of companies.
SELECT count(*) FROM Companies; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### List the names of companies in descending order of market value.
SELECT name FROM Companies ORDER BY Market_Value_billion DESC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Sort the company names in descending order of the company's market value.
SELECT name FROM Companies ORDER BY Market_Value_billion DESC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### What are the names of companies whose headquarters are not "USA"?
SELECT name FROM Companies WHERE Headquarters != 'USA'; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Find the names of the companies whose headquarters are not located in "USA".
SELECT name FROM Companies WHERE Headquarters != 'USA'; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### What are the name and assets of each company, sorted in ascending order of company name?
SELECT name,Assets_billion FROM Companies ORDER BY name ASC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### List the name and assets of each company in ascending order of company name.
SELECT name,Assets_billion FROM Companies ORDER BY name ASC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### What are the average profits of companies?
SELECT avg(Profits_billion) FROM Companies; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Compute the average profits companies make.
SELECT avg(Profits_billion) FROM Companies; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### What are the maximum and minimum sales of the companies whose industries are not "Banking".
SELECT max(Sales_billion),min(Sales_billion) FROM Companies WHERE Industry != "Banking"; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Find the maximum and minimum sales of the companies that are not in the "Banking" industry.
SELECT max(Sales_billion),min(Sales_billion) FROM Companies WHERE Industry != "Banking"; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### How many different industries are the companies in?
SELECT count(DISTINCT Industry) FROM Companies; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Count the number of distinct company industries.
SELECT count(DISTINCT Industry) FROM Companies; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### List the names of buildings in descending order of building height.
SELECT name FROM buildings ORDER BY Height DESC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### What are the names of buildings sorted in descending order of building height?
SELECT name FROM buildings ORDER BY Height DESC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Find the stories of the building with the largest height.
SELECT Stories FROM buildings ORDER BY Height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### What is the stories of highest building?
SELECT Stories FROM buildings ORDER BY Height DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Please show the names of the buildings whose status is "on-hold", in ascending order of stories.
SELECT name FROM buildings WHERE Status = "on-hold" ORDER BY Stories ASC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Find the names of the buildings in "on-hold" status, and sort them in ascending order of building stories.
SELECT name FROM buildings WHERE Status = "on-hold" ORDER BY Stories ASC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Please show each industry and the corresponding number of companies in that industry.
SELECT Industry,COUNT(*) FROM Companies GROUP BY Industry; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Whah are the name of each industry and the number of companies in that industry?
SELECT Industry,COUNT(*) FROM Companies GROUP BY Industry; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Please show the industries of companies in descending order of the number of companies.
SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Sort all the industries in descending order of the count of companies in each industry
SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### List the industry shared by the most companies.
SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Which industry has the most companies?
SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### List the names of buildings that have no company office.
SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations); ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Which buildings do not have any company office? Give me the building names.
SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations); ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Show the industries shared by companies whose headquarters are "USA" and companies whose headquarters are "China".
SELECT Industry FROM Companies WHERE Headquarters = "USA" INTERSECT SELECT Industry FROM Companies WHERE Headquarters = "China"; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Which industries have both companies with headquarter in "USA" and companies with headquarter in "China"?
SELECT Industry FROM Companies WHERE Headquarters = "USA" INTERSECT SELECT Industry FROM Companies WHERE Headquarters = "China"; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Find the number of companies whose industry is "Banking" or "Conglomerate",
SELECT count(*) FROM Companies WHERE Industry = "Banking" OR Industry = "Conglomerate"; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### How many companies are in either "Banking" industry or "Conglomerate" industry?
SELECT count(*) FROM Companies WHERE Industry = "Banking" OR Industry = "Conglomerate"; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Show the headquarters shared by more than two companies.
SELECT Headquarters FROM Companies GROUP BY Headquarters HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# buildings: ["id", "name", "city", "height", "stories", "status"]
# companies: ["id", "name", "headquarters", "industry", "sales_billion", "profits_billion", "assets_billion", "market_value_billion"]
# office_locations: ["building_id", "company_id", "move_in_year"]
### Which headquarter locations are used by more than 2 companies?
SELECT Headquarters FROM Companies GROUP BY Headquarters HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### How many products are there?
SELECT count(*) FROM Products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### List the name of products in ascending order of price.
SELECT Product_Name FROM Products ORDER BY Product_Price ASC; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### What are the names and type codes of products?
SELECT Product_Name,Product_Type_Code FROM Products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### Show the prices of the products named "Dining" or "Trading_Policy".
SELECT Product_Price FROM Products WHERE Product_Name = "Dining" OR Product_Name = "Trading_Policy"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### What is the average price for products?
SELECT avg(Product_Price) FROM Products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### What is the name of the product with the highest price?
SELECT Product_Name FROM Products ORDER BY Product_Price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### Show different type codes of products and the number of products with each type code.
SELECT Product_Type_Code,COUNT(*) FROM Products GROUP BY Product_Type_Code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### Show the most common type code across products.
SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### Show the product type codes that have at least two products.
SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code HAVING COUNT(*) >= 2; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### Show the product type codes that have both products with price higher than 4500 and products with price lower than 3000.
SELECT Product_Type_Code FROM Products WHERE Product_Price > 4500 INTERSECT SELECT Product_Type_Code FROM Products WHERE Product_Price < 3000; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# locations: ["location_id", "other_details"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# parties: ["party_id", "party_details"]
# assets: ["asset_id", "other_details"]
# channels: ["channel_id", "other_details"]
# finances: ["finance_id", "other_details"]
# events: ["event_id", "address_id", "channel_id", "event_type_code", "finance_id", "location_id"]
# products_in_events: ["product_in_event_id", "event_id", "product_id"]
# parties_in_events: ["party_id", "event_id", "role_code"]
# agreements: ["document_id", "event_id"]
# assets_in_events: ["asset_id", "event_id"]
### List the names of products that are not in any event.
SELECT Product_Name FROM Products WHERE Product_ID NOT IN (SELECT Product_ID FROM Products_in_Events); ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### How many artworks are there?
SELECT count(*) FROM artwork; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### List the name of artworks in ascending alphabetical order.
SELECT Name FROM artwork ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### List the name of artworks whose type is not "Program_Talent_Show".
SELECT Name FROM artwork WHERE TYPE != "Program_Talent_Show"; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### What are the names and locations of festivals?
SELECT Festival_Name,LOCATION FROM festival_detail; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### What are the names of the chairs of festivals, sorted in ascending order of the year held?
SELECT Chair_Name FROM festival_detail ORDER BY YEAR ASC; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### What is the location of the festival with the largest number of audience?
SELECT LOCATION FROM festival_detail ORDER BY Num_of_Audience DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### What are the names of festivals held in year 2007?
SELECT Festival_Name FROM festival_detail WHERE YEAR = 2007; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### What is the average number of audience for festivals?
SELECT avg(Num_of_Audience) FROM festival_detail; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### Show the names of the three most recent festivals.
SELECT Festival_Name FROM festival_detail ORDER BY YEAR DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### Please show different types of artworks with the corresponding number of artworks of each type.
SELECT TYPE,COUNT(*) FROM artwork GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### List the most common type of artworks.
SELECT TYPE FROM artwork GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### List the year in which there are more than one festivals.
SELECT YEAR FROM festival_detail GROUP BY YEAR HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### List the name of artworks that are not nominated.
SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination); ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### Show the number of audience in year 2008 or 2010.
SELECT Num_of_Audience FROM festival_detail WHERE YEAR = 2008 OR YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### What are the total number of the audiences who visited any of the festivals?
SELECT sum(Num_of_Audience) FROM festival_detail; ###
###Postgre SQL tables, with their properties:
# festival_detail: ["festival_id", "festival_name", "chair_name", "location", "year", "num_of_audience"]
# artwork: ["artwork_id", "type", "name"]
# nomination: ["artwork_id", "festival_id", "result"]
### In which year are there festivals both inside the 'United States' and outside the 'United States'?
SELECT YEAR FROM festival_detail WHERE LOCATION = 'United States' INTERSECT SELECT YEAR FROM festival_detail WHERE LOCATION != 'United States'; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### How many premises are there?
SELECT count(*) FROM premises; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### What are all the distinct premise types?
SELECT DISTINCT premises_type FROM premises; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### Find the types and details for all premises and order by the premise type.
SELECT premises_type,premise_details FROM premises ORDER BY premises_type; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### Show each premise type and the number of premises in that type.
SELECT premises_type,count(*) FROM premises GROUP BY premises_type; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### Show all distinct product categories along with the number of mailshots in each category.
SELECT product_category,count(*) FROM mailshot_campaigns GROUP BY product_category; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### Show the name and phone of the customer without any mailshot.
SELECT customer_name,customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers); ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### Show the outcome code of mailshots along with the number of mailshots in each outcome code.
SELECT outcome_code,count(*) FROM mailshot_customers GROUP BY outcome_code; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### What are the distinct address type codes for all customer addresses?
SELECT DISTINCT address_type_code FROM customer_addresses; ###
###Postgre SQL tables, with their properties:
# premises: ["premise_id", "premises_type", "premise_details"]
# products: ["product_id", "product_category", "product_name"]
# customers: ["customer_id", "payment_method", "customer_name", "customer_phone", "customer_email", "customer_address", "customer_login", "customer_password"]
# mailshot_campaigns: ["mailshot_id", "product_category", "mailshot_name", "mailshot_start_date", "mailshot_end_date"]
# customer_addresses: ["customer_id", "premise_id", "date_address_from", "address_type_code", "date_address_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "shipping_method_code", "order_placed_datetime", "order_delivered_datetime", "order_shipping_charges"]
# mailshot_customers: ["mailshot_id", "customer_id", "outcome_code", "mailshot_customer_date"]
# order_items: ["item_id", "order_item_status_code", "order_id", "product_id", "item_status_code", "item_delivered_datetime", "item_order_quantity"]
### Show the shipping charge and customer id for customer orders with order status Cancelled or Paid.
SELECT order_shipping_charges,customer_id FROM customer_orders WHERE order_status_code = 'Cancelled' OR order_status_code = 'Paid'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### How many courses are there in total?
SELECT count(*) FROM COURSE; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Count the number of courses.
SELECT count(*) FROM COURSE; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### How many courses have more than 2 credits?
SELECT count(*) FROM COURSE WHERE Credits > 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Count the number of courses with more than 2 credits.
SELECT count(*) FROM COURSE WHERE Credits > 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### List all names of courses with 1 credit?
SELECT CName FROM COURSE WHERE Credits = 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the names of courses with 1 credit?
SELECT CName FROM COURSE WHERE Credits = 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Which courses are taught on days MTW?
SELECT CName FROM COURSE WHERE Days = "MTW"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the course names for courses taught on MTW?
SELECT CName FROM COURSE WHERE Days = "MTW"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What is the number of departments in Division "AS"?
SELECT count(*) FROM DEPARTMENT WHERE Division = "AS"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### How many departments are in the division AS?
SELECT count(*) FROM DEPARTMENT WHERE Division = "AS"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the phones of departments in Room 268?
SELECT DPhone FROM DEPARTMENT WHERE Room = 268; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Give the phones for departments in room 268.
SELECT DPhone FROM DEPARTMENT WHERE Room = 268; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the number of students that have at least one grade "B".
SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade = "B"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### How many students have had at least one "B" grade?
SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade = "B"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the max and min grade point for all letter grade.
SELECT max(gradepoint),min(gradepoint) FROM GRADECONVERSION; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the maximum and minumum grade points?
SELECT max(gradepoint),min(gradepoint) FROM GRADECONVERSION; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the first names of students whose first names contain letter "a".
SELECT DISTINCT Fname FROM STUDENT WHERE Fname LIKE '%a%'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the first names for students who have an "a" in their first name?
SELECT DISTINCT Fname FROM STUDENT WHERE Fname LIKE '%a%'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the first names and last names of male (sex is M) faculties who live in building NEB.
SELECT Fname,Lname FROM FACULTY WHERE sex = "M" AND Building = "NEB"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the full names of faculties with sex M and who live in building NEB?
SELECT Fname,Lname FROM FACULTY WHERE sex = "M" AND Building = "NEB"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the rooms of faculties with rank professor who live in building NEB.
SELECT Room FROM FACULTY WHERE Rank = "Professor" AND Building = "NEB"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the rooms for members of the faculty who are professors and who live in building NEB?
SELECT Room FROM FACULTY WHERE Rank = "Professor" AND Building = "NEB"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the department name that is in Building "Mergenthaler".
SELECT DName FROM DEPARTMENT WHERE Building = "Mergenthaler"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What is the name of the department in the Building Mergenthaler?
SELECT DName FROM DEPARTMENT WHERE Building = "Mergenthaler"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### List all information about courses sorted by credits in the ascending order.
SELECT * FROM COURSE ORDER BY Credits; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What is all the information about courses, ordered by credits ascending?
SELECT * FROM COURSE ORDER BY Credits; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### List the course name of courses sorted by credits.
SELECT CName FROM COURSE ORDER BY Credits; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the course names, ordered by credits?
SELECT CName FROM COURSE ORDER BY Credits; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the first name of students in the descending order of age.
SELECT Fname FROM STUDENT ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the first names of students, ordered by age from greatest to least?
SELECT Fname FROM STUDENT ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the last name of female (sex is F) students in the descending order of age.
SELECT LName FROM STUDENT WHERE Sex = "F" ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the last names of female students, ordered by age descending?
SELECT LName FROM STUDENT WHERE Sex = "F" ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the last names of faculties in building Barton in alphabetic order.
SELECT Lname FROM FACULTY WHERE Building = "Barton" ORDER BY Lname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the last names of faculty in building Barton, sorted by last name?
SELECT Lname FROM FACULTY WHERE Building = "Barton" ORDER BY Lname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the first names of faculties of rank Professor in alphabetic order.
SELECT Fname FROM FACULTY WHERE Rank = "Professor" ORDER BY Fname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the first names for all faculty professors, ordered by first name?
SELECT Fname FROM FACULTY WHERE Rank = "Professor" ORDER BY Fname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the rank of the faculty that the fewest faculties belong to.
SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What is the least common faculty rank?
SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the names of courses that have either 3 credits or 1 credit but 4 hours.
SELECT CName FROM COURSE WHERE Credits = 3 UNION SELECT CName FROM COURSE WHERE Credits = 1 AND Hours = 4; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the names of courses that give either 3 credits, or 1 credit and 4 hours?
SELECT CName FROM COURSE WHERE Credits = 3 UNION SELECT CName FROM COURSE WHERE Credits = 1 AND Hours = 4; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the names of departments that are either in division AS or in division EN and in Building NEB.
SELECT DName FROM DEPARTMENT WHERE Division = "AS" UNION SELECT DName FROM DEPARTMENT WHERE Division = "EN" AND Building = "NEB"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the names of departments either in division AS, or in division EN and in building NEB?
SELECT DName FROM DEPARTMENT WHERE Division = "AS" UNION SELECT DName FROM DEPARTMENT WHERE Division = "EN" AND Building = "NEB"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### Find the first name of students not enrolled in any course.
SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
# department: ["department_number", "division", "department_name", "room", "building", "department_phone"]
# member_of: ["faculty_id", "department_number", "appt_type"]
# course: ["course_id", "course_name", "credits", "instructor", "days", "hours", "department_number"]
# minor_in: ["student_id", "department_number"]
# enrolled_in: ["student_id", "course_id", "grade"]
# grade_conversion: ["letter_grade", "grade_point"]
### What are the first names of all students that are not enrolled in courses?
SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the ids of the top three products that were purchased in the largest amount?
SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Give the ids of the three products purchased in the largest amounts.
SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the product id and product type of the cheapest product?
SELECT product_id,product_type_code FROM products ORDER BY product_price LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Give the id and product type of the product with the lowest price.
SELECT product_id,product_type_code FROM products ORDER BY product_price LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Find the number of different product types.
SELECT count(DISTINCT product_type_code) FROM products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Count the number of distinct product types.
SELECT count(DISTINCT product_type_code) FROM products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### For each payment method, return how many customers use it.
SELECT payment_method_code,count(*) FROM customers GROUP BY payment_method_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### How many customers use each payment method?
SELECT payment_method_code,count(*) FROM customers GROUP BY payment_method_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is the id of the product that was ordered the most often?
SELECT product_id FROM order_items GROUP BY product_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Give the product id for the product that was ordered most frequently.
SELECT product_id FROM order_items GROUP BY product_id ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is the average price for each type of product?
SELECT product_type_code,avg(product_price) FROM products GROUP BY product_type_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the average price for each product type.
SELECT product_type_code,avg(product_price) FROM products GROUP BY product_type_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the ids of the two department store chains with the largest number of department stores?
SELECT dept_store_chain_id FROM department_stores GROUP BY dept_store_chain_id ORDER BY count(*) DESC LIMIT 2; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the ids of the two department store chains with the most department stores.
SELECT dept_store_chain_id FROM department_stores GROUP BY dept_store_chain_id ORDER BY count(*) DESC LIMIT 2; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is the id of the department with the least number of staff?
SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the id of the department with the fewest staff assignments.
SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### For each product type, return the maximum and minimum price.
SELECT product_type_code,max(product_price),min(product_price) FROM products GROUP BY product_type_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the maximum and minimum product prices for each product type?
SELECT product_type_code,max(product_price),min(product_price) FROM products GROUP BY product_type_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Find the product type whose average price is higher than the average price of all products.
SELECT product_type_code FROM products GROUP BY product_type_code HAVING avg(product_price) > (SELECT avg(product_price) FROM products); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is the code of the product type with an average price higher than the average price of all products?
SELECT product_type_code FROM products GROUP BY product_type_code HAVING avg(product_price) > (SELECT avg(product_price) FROM products); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the names and ids of all products whose price is between 600 and 700.
SELECT product_name,product_id FROM products WHERE product_price BETWEEN 600 AND 700; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the names and ids of products costing between 600 and 700?
SELECT product_name,product_id FROM products WHERE product_price BETWEEN 600 AND 700; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Find the ids of all distinct customers who made order after some orders that were Cancelled.
SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date > (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code = "Cancelled"); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the distinct ids of customers who made an order after any order that was Cancelled?
SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date > (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code = "Cancelled"); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?
SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to < (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical Staff'); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the id of the staff whose Staff Department Assignment was earlier than that of any Clerical Staff.
SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to < (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical Staff'); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the names and ids of customers whose address contains TN?
SELECT customer_name,customer_id FROM customers WHERE customer_address LIKE "%TN%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the names and ids of customers who have TN in their address.
SELECT customer_name,customer_id FROM customers WHERE customer_address LIKE "%TN%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the phone numbers of all customers and suppliers.
SELECT customer_phone FROM customers UNION SELECT supplier_phone FROM suppliers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the phone numbers for all customers and suppliers.
SELECT customer_phone FROM customers UNION SELECT supplier_phone FROM suppliers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the ids of all products that were ordered more than three times or supplied more than 80000.
SELECT product_id FROM Order_Items GROUP BY product_id HAVING count(*) > 3 UNION SELECT product_id FROM Product_Suppliers GROUP BY product_id HAVING sum(total_amount_purchased) > 80000; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the ids of all products that were either ordered more than 3 times or have a cumulative amount purchased of above 80000?
SELECT product_id FROM Order_Items GROUP BY product_id HAVING count(*) > 3 UNION SELECT product_id FROM Product_Suppliers GROUP BY product_id HAVING sum(total_amount_purchased) > 80000; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are id and name of the products whose price is lower than 600 or higher than 900?
SELECT product_id,product_name FROM products WHERE product_price < 600 OR product_price > 900; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Give the ids and names of products with price lower than 600 or higher than 900.
SELECT product_id,product_name FROM products WHERE product_price < 600 OR product_price > 900; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Find the id of suppliers whose average amount purchased for each product is above 50000 or below 30000.
SELECT supplier_id FROM Product_Suppliers GROUP BY supplier_id HAVING avg(total_amount_purchased) > 50000 OR avg(total_amount_purchased) < 30000; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the ids of suppliers which have an average amount purchased of above 50000 or below 30000?
SELECT supplier_id FROM Product_Suppliers GROUP BY supplier_id HAVING avg(total_amount_purchased) > 50000 OR avg(total_amount_purchased) < 30000; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the average amount purchased and value purchased for the supplier who supplies the most products.
SELECT avg(total_amount_purchased),avg(total_value_purchased) FROM Product_Suppliers WHERE supplier_id = (SELECT supplier_id FROM Product_Suppliers GROUP BY supplier_id ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the average total amount purchased and total value purchased for the supplier who supplies the greatest number of products.
SELECT avg(total_amount_purchased),avg(total_value_purchased) FROM Product_Suppliers WHERE supplier_id = (SELECT supplier_id FROM Product_Suppliers GROUP BY supplier_id ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is the largest and smallest customer codes?
SELECT max(customer_code),min(customer_code) FROM Customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Return the maximum and minimum customer codes.
SELECT max(customer_code),min(customer_code) FROM Customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the highest and lowest prices of products, grouped by and alphabetically ordered by product type?
SELECT max(product_price),min(product_price),product_type_code FROM products GROUP BY product_type_code ORDER BY product_type_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Give the maximum and minimum product prices for each product type, grouped and ordered by product type.
SELECT max(product_price),min(product_price),product_type_code FROM products GROUP BY product_type_code ORDER BY product_type_code; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### List the order id, customer id for orders in Cancelled status, ordered by their order dates.
SELECT order_id,customer_id FROM customer_orders WHERE order_status_code = "Cancelled" ORDER BY order_date; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the order ids and customer ids for orders that have been Cancelled, sorted by their order dates?
SELECT order_id,customer_id FROM customer_orders WHERE order_status_code = "Cancelled" ORDER BY order_date; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Find the id and name of customers whose address contains WY state and do not use credit card for payment.
SELECT customer_id,customer_name FROM customers WHERE customer_address LIKE "%WY%" AND payment_method_code != "Credit_Card"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?
SELECT customer_id,customer_name FROM customers WHERE customer_address LIKE "%WY%" AND payment_method_code != "Credit_Card"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Find the average price of all product clothes.
SELECT avg(product_price) FROM products WHERE product_type_code = 'Clothes'; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is the average price of clothes?
SELECT avg(product_price) FROM products WHERE product_type_code = 'Clothes'; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### Find the name of the most expensive hardware product.
SELECT product_name FROM products WHERE product_type_code = 'Hardware' ORDER BY product_price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_details"]
# staff: ["staff_id", "staff_gender", "staff_name"]
# suppliers: ["supplier_id", "supplier_name", "supplier_phone"]
# department_store_chain: ["department_store_chain_id", "department_store_chain_name"]
# customers: ["customer_id", "payment_method_code", "customer_code", "customer_name", "customer_address", "customer_phone", "customer_email"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# supplier_addresses: ["supplier_id", "address_id", "date_from", "date_to"]
# customer_addresses: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_status_code", "order_date"]
# department_stores: ["department_store_id", "department_store_chain_id", "store_name", "store_address", "store_phone", "store_email"]
# departments: ["department_id", "department_store_id", "department_name"]
# order_items: ["order_item_id", "order_id", "product_id"]
# product_suppliers: ["product_id", "supplier_id", "date_supplied_from", "date_supplied_to", "total_amount_purchased", "total_value_purchased"]
# staff_department_assignments: ["staff_id", "department_id", "date_assigned_from", "job_title_code", "date_assigned_to"]
### What is the name of the hardware product with the greatest price?
SELECT product_name FROM products WHERE product_type_code = 'Hardware' ORDER BY product_price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### How many aircrafts are there?
SELECT count(*) FROM aircraft; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What is the number of aircraft?
SELECT count(*) FROM aircraft; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### List the description of all aircrafts.
SELECT Description FROM aircraft; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the descriptions for the aircrafts?
SELECT Description FROM aircraft; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What is the average number of international passengers of all airports?
SELECT avg(International_Passengers) FROM airport; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What is the average number of international passengers for an airport?
SELECT avg(International_Passengers) FROM airport; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the number of international and domestic passengers of the airport named London "Heathrow"?
SELECT International_Passengers,Domestic_Passengers FROM airport WHERE Airport_Name = "London_Heathrow"; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### How many international and domestic passengers are there in the airport London Heathrow?
SELECT International_Passengers,Domestic_Passengers FROM airport WHERE Airport_Name = "London_Heathrow"; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the total number of Domestic Passengers of airports that contain the word "London".
SELECT sum(Domestic_Passengers) FROM airport WHERE Airport_Name LIKE "%London%"; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the total number of domestic passengers at all London airports?
SELECT sum(Domestic_Passengers) FROM airport WHERE Airport_Name LIKE "%London%"; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the maximum and minimum number of transit passengers of all aiports.
SELECT max(Transit_Passengers),min(Transit_Passengers) FROM airport; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What is the maximum and mininum number of transit passengers for all airports?
SELECT max(Transit_Passengers),min(Transit_Passengers) FROM airport; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the name of pilots aged 25 or older?
SELECT Name FROM pilot WHERE Age >= 25; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### what is the name of every pilot who is at least 25 years old?
SELECT Name FROM pilot WHERE Age >= 25; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### List all pilot names in ascending alphabetical order.
SELECT Name FROM pilot ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the names of the pilots in alphabetical order?
SELECT Name FROM pilot ORDER BY Name ASC; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### List names of all pilot aged 30 or younger in descending alphabetical order.
SELECT Name FROM pilot WHERE Age <= 30 ORDER BY Name DESC; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the names of all pilots 30 years old or young in descending alphabetical order?
SELECT Name FROM pilot WHERE Age <= 30 ORDER BY Name DESC; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### List names of all pilot in descending order of age.
SELECT Name FROM pilot ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the names of all pilots listed by descending age?
SELECT Name FROM pilot ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### List the names of aircrafts and that did not win any match.
SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM MATCH); ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the names of all aicrafts that have never won any match?
SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM MATCH); ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### Show all information on the airport that has the largest number of international passengers.
SELECT * FROM airport ORDER BY International_Passengers DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What is all the information on the airport with the largest number of international passengers?
SELECT * FROM airport ORDER BY International_Passengers DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### find the name of pilots who did not win the matches held in the country of Australia.
SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot FROM MATCH WHERE country = 'Australia'); ###
###Postgre SQL tables, with their properties:
# pilot: ["pilot_id", "name", "age"]
# aircraft: ["aircraft_id", "aircraft", "description", "max_gross_weight", "total_disk_area", "max_disk_loading"]
# match: ["round", "location", "country", "date", "fastest_qualifying", "winning_pilot", "winning_aircraft"]
# airport: ["airport_id", "airport_name", "total_passengers", "%_change_2007", "international_passengers", "domestic_passengers", "transit_passengers", "aircraft_movements", "freight_metric_tonnes"]
# airport_aircraft: ["id", "airport_id", "aircraft_id"]
### What are the names of the pilots that have not won any matches in Australia?
SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot FROM MATCH WHERE country = 'Australia'); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# properties: ["property_id", "property_type_code", "property_address", "other_details"]
# residents: ["resident_id", "property_id", "date_moved_in", "date_moved_out", "other_details"]
# organizations: ["organization_id", "parent_organization_id", "organization_details"]
# services: ["service_id", "organization_id", "service_type_code", "service_details"]
# residents_services: ["resident_id", "service_id", "date_moved_in", "property_id", "date_requested", "date_provided", "other_details"]
# things: ["thing_id", "organization_id", "type_of_thing_code", "service_type_code", "service_details"]
# customer_events: ["customer_event_id", "customer_id", "date_moved_in", "property_id", "resident_id", "thing_id"]
# customer_event_notes: ["customer_event_note_id", "customer_event_id", "service_type_code", "resident_id", "property_id", "date_moved_in"]
# timed_status_of_things: ["thing_id", "date_and_date", "status_of_thing_code"]
# timed_locations_of_things: ["thing_id", "date_and_time", "location_code"]
### How many different status codes of things are there?
SELECT count(DISTINCT Status_of_Thing_Code) FROM Timed_Status_of_Things; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# properties: ["property_id", "property_type_code", "property_address", "other_details"]
# residents: ["resident_id", "property_id", "date_moved_in", "date_moved_out", "other_details"]
# organizations: ["organization_id", "parent_organization_id", "organization_details"]
# services: ["service_id", "organization_id", "service_type_code", "service_details"]
# residents_services: ["resident_id", "service_id", "date_moved_in", "property_id", "date_requested", "date_provided", "other_details"]
# things: ["thing_id", "organization_id", "type_of_thing_code", "service_type_code", "service_details"]
# customer_events: ["customer_event_id", "customer_id", "date_moved_in", "property_id", "resident_id", "thing_id"]
# customer_event_notes: ["customer_event_note_id", "customer_event_id", "service_type_code", "resident_id", "property_id", "date_moved_in"]
# timed_status_of_things: ["thing_id", "date_and_date", "status_of_thing_code"]
# timed_locations_of_things: ["thing_id", "date_and_time", "location_code"]
### Which organizations are not a parent organization of others? List the organization id.
SELECT organization_id FROM organizations EXCEPT SELECT parent_organization_id FROM organizations; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# properties: ["property_id", "property_type_code", "property_address", "other_details"]
# residents: ["resident_id", "property_id", "date_moved_in", "date_moved_out", "other_details"]
# organizations: ["organization_id", "parent_organization_id", "organization_details"]
# services: ["service_id", "organization_id", "service_type_code", "service_details"]
# residents_services: ["resident_id", "service_id", "date_moved_in", "property_id", "date_requested", "date_provided", "other_details"]
# things: ["thing_id", "organization_id", "type_of_thing_code", "service_type_code", "service_details"]
# customer_events: ["customer_event_id", "customer_id", "date_moved_in", "property_id", "resident_id", "thing_id"]
# customer_event_notes: ["customer_event_note_id", "customer_event_id", "service_type_code", "resident_id", "property_id", "date_moved_in"]
# timed_status_of_things: ["thing_id", "date_and_date", "status_of_thing_code"]
# timed_locations_of_things: ["thing_id", "date_and_time", "location_code"]
### When is the last day any resident moved in?
SELECT max(date_moved_in) FROM Residents; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# properties: ["property_id", "property_type_code", "property_address", "other_details"]
# residents: ["resident_id", "property_id", "date_moved_in", "date_moved_out", "other_details"]
# organizations: ["organization_id", "parent_organization_id", "organization_details"]
# services: ["service_id", "organization_id", "service_type_code", "service_details"]
# residents_services: ["resident_id", "service_id", "date_moved_in", "property_id", "date_requested", "date_provided", "other_details"]
# things: ["thing_id", "organization_id", "type_of_thing_code", "service_type_code", "service_details"]
# customer_events: ["customer_event_id", "customer_id", "date_moved_in", "property_id", "resident_id", "thing_id"]
# customer_event_notes: ["customer_event_note_id", "customer_event_id", "service_type_code", "resident_id", "property_id", "date_moved_in"]
# timed_status_of_things: ["thing_id", "date_and_date", "status_of_thing_code"]
# timed_locations_of_things: ["thing_id", "date_and_time", "location_code"]
### What are the resident details containing the substring 'Miss'?
SELECT other_details FROM Residents WHERE other_details LIKE '%Miss%'; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# properties: ["property_id", "property_type_code", "property_address", "other_details"]
# residents: ["resident_id", "property_id", "date_moved_in", "date_moved_out", "other_details"]
# organizations: ["organization_id", "parent_organization_id", "organization_details"]
# services: ["service_id", "organization_id", "service_type_code", "service_details"]
# residents_services: ["resident_id", "service_id", "date_moved_in", "property_id", "date_requested", "date_provided", "other_details"]
# things: ["thing_id", "organization_id", "type_of_thing_code", "service_type_code", "service_details"]
# customer_events: ["customer_event_id", "customer_id", "date_moved_in", "property_id", "resident_id", "thing_id"]
# customer_event_notes: ["customer_event_note_id", "customer_event_id", "service_type_code", "resident_id", "property_id", "date_moved_in"]
# timed_status_of_things: ["thing_id", "date_and_date", "status_of_thing_code"]
# timed_locations_of_things: ["thing_id", "date_and_time", "location_code"]
### List the customer event id and the corresponding move in date and property id.
SELECT customer_event_id,date_moved_in,property_id FROM customer_events; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# properties: ["property_id", "property_type_code", "property_address", "other_details"]
# residents: ["resident_id", "property_id", "date_moved_in", "date_moved_out", "other_details"]
# organizations: ["organization_id", "parent_organization_id", "organization_details"]
# services: ["service_id", "organization_id", "service_type_code", "service_details"]
# residents_services: ["resident_id", "service_id", "date_moved_in", "property_id", "date_requested", "date_provided", "other_details"]
# things: ["thing_id", "organization_id", "type_of_thing_code", "service_type_code", "service_details"]
# customer_events: ["customer_event_id", "customer_id", "date_moved_in", "property_id", "resident_id", "thing_id"]
# customer_event_notes: ["customer_event_note_id", "customer_event_id", "service_type_code", "resident_id", "property_id", "date_moved_in"]
# timed_status_of_things: ["thing_id", "date_and_date", "status_of_thing_code"]
# timed_locations_of_things: ["thing_id", "date_and_time", "location_code"]
### How many customers did not have any event?
SELECT count(*) FROM customers WHERE customer_id NOT IN ( SELECT customer_id FROM customer_events ); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_details"]
# properties: ["property_id", "property_type_code", "property_address", "other_details"]
# residents: ["resident_id", "property_id", "date_moved_in", "date_moved_out", "other_details"]
# organizations: ["organization_id", "parent_organization_id", "organization_details"]
# services: ["service_id", "organization_id", "service_type_code", "service_details"]
# residents_services: ["resident_id", "service_id", "date_moved_in", "property_id", "date_requested", "date_provided", "other_details"]
# things: ["thing_id", "organization_id", "type_of_thing_code", "service_type_code", "service_details"]
# customer_events: ["customer_event_id", "customer_id", "date_moved_in", "property_id", "resident_id", "thing_id"]
# customer_event_notes: ["customer_event_note_id", "customer_event_id", "service_type_code", "resident_id", "property_id", "date_moved_in"]
# timed_status_of_things: ["thing_id", "date_and_date", "status_of_thing_code"]
# timed_locations_of_things: ["thing_id", "date_and_time", "location_code"]
### What are the distinct move in dates of the residents?
SELECT DISTINCT date_moved_in FROM residents; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### How many schools are there?
SELECT count(*) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Count the number of schools.
SELECT count(*) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### List the locations of schools in ascending order of enrollment.
SELECT LOCATION FROM school ORDER BY Enrollment ASC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What is the list of school locations sorted in ascending order of school enrollment?
SELECT LOCATION FROM school ORDER BY Enrollment ASC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### List the locations of schools in descending order of founded year.
SELECT LOCATION FROM school ORDER BY Founded DESC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What is the list of school locations sorted in descending order of school foundation year?
SELECT LOCATION FROM school ORDER BY Founded DESC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What are the enrollments of schools whose denomination is not "Catholic"?
SELECT Enrollment FROM school WHERE Denomination != "Catholic"; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### List the enrollment for each school that does not have "Catholic" as denomination.
SELECT Enrollment FROM school WHERE Denomination != "Catholic"; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What is the average enrollment of schools?
SELECT avg(Enrollment) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Take the average of the school enrollment.
SELECT avg(Enrollment) FROM school; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What are the teams of the players, sorted in ascending alphabetical order?
SELECT Team FROM player ORDER BY Team ASC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Find the team of each player and sort them in ascending alphabetical order.
SELECT Team FROM player ORDER BY Team ASC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### How many different positions of players are there?
SELECT count(DISTINCT POSITION) FROM player; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Count the number of distinct player positions.
SELECT count(DISTINCT POSITION) FROM player; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Find the team of the player of the highest age.
SELECT Team FROM player ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Which team has the oldest player?
SELECT Team FROM player ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### List the teams of the players with the top 5 largest ages.
SELECT Team FROM player ORDER BY Age DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What are the teams that have the 5 oldest players?
SELECT Team FROM player ORDER BY Age DESC LIMIT 5; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Please show different denominations and the corresponding number of schools.
SELECT Denomination,COUNT(*) FROM school GROUP BY Denomination; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### For each denomination, return the denomination and the count of schools with that denomination.
SELECT Denomination,COUNT(*) FROM school GROUP BY Denomination; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Please show different denominations and the corresponding number of schools in descending order.
SELECT Denomination,COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Order denominations in descending order of the count of schools with the denomination. Return each denomination with the count of schools.
SELECT Denomination,COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### List the school color of the school that has the largest enrollment.
SELECT School_Colors FROM school ORDER BY Enrollment DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What is the school color of the school with the largest enrollment?
SELECT School_Colors FROM school ORDER BY Enrollment DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### List the locations of schools that do not have any player.
SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player); ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Which schools do not have any player? Give me the school locations.
SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player); ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Show the denomination shared by schools founded before 1890 and schools founded after 1900
SELECT Denomination FROM school WHERE Founded < 1890 INTERSECT SELECT Denomination FROM school WHERE Founded > 1900; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What are the denominations used by both schools founded before 1890 and schools founded after 1900?
SELECT Denomination FROM school WHERE Founded < 1890 INTERSECT SELECT Denomination FROM school WHERE Founded > 1900; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Show the nicknames of schools that are not in division 1.
SELECT Nickname FROM school_details WHERE Division != "Division_1"; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What are the nicknames of schools whose division is not 1?
SELECT Nickname FROM school_details WHERE Division != "Division_1"; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### Show the denomination shared by more than one school.
SELECT Denomination FROM school GROUP BY Denomination HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# school: ["school_id", "school", "location", "enrollment", "founded", "denomination", "boys_or_girls", "day_or_boarding", "year_entered_competition", "school_colors"]
# school_details: ["school_id", "nickname", "colors", "league", "class", "division"]
# school_performance: ["school_id", "school_year", "class_a", "class_aa"]
# player: ["player_id", "player", "team", "age", "position", "school_id"]
### What are the denomination more than one school have?
SELECT Denomination FROM school GROUP BY Denomination HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find all the distinct district names ordered by city area in descending.
SELECT DISTINCT District_name FROM district ORDER BY city_area DESC; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What are the different district names in order of descending city area?
SELECT DISTINCT District_name FROM district ORDER BY city_area DESC; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find the list of page size which have more than 3 product listed
SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the maximum page size for everything that has more than 3 products listed?
SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find the name and population of district with population between 200000 and 2000000
SELECT District_name,City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What are the district names and city populations for all districts that between 200,000 and 2,000,000 residents?
SELECT District_name,City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find the name all districts with city area greater than 10 or population larger than 100000
SELECT district_name FROM district WHERE city_area > 10 OR City_Population > 100000; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What are the names of all districts with a city area greater than 10 or have more than 100000 people living there?
SELECT district_name FROM district WHERE city_area > 10 OR City_Population > 100000; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Which district has the largest population?
SELECT district_name FROM district ORDER BY city_population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the name of the district with the most residents?
SELECT district_name FROM district ORDER BY city_population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Which district has the least area?
SELECT district_name FROM district ORDER BY city_area ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the name of the district with the smallest area?
SELECT district_name FROM district ORDER BY city_area ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find the total population of the top 3 districts with the largest area.
SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the total number of residents for the districts with the 3 largest areas?
SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find all types of store and number of them.
SELECT TYPE,count(*) FROM store GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### For each type of store, how many of them are there?
SELECT TYPE,count(*) FROM store GROUP BY TYPE; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the average pages per minute color?
SELECT avg(pages_per_minute_color) FROM product; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the average number of pages per minute color?
SELECT avg(pages_per_minute_color) FROM product; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find products with max page size as "A4" and pages per minute color smaller than 5.
SELECT product FROM product WHERE max_page_size = "A4" AND pages_per_minute_color < 5; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What are the products with the maximum page size A4 that also have a pages per minute color smaller than 5?
SELECT product FROM product WHERE max_page_size = "A4" AND pages_per_minute_color < 5; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find products with max page size as "A4" or pages per minute color smaller than 5.
SELECT product FROM product WHERE max_page_size = "A4" OR pages_per_minute_color < 5; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?
SELECT product FROM product WHERE max_page_size = "A4" OR pages_per_minute_color < 5; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find all the product whose name contains the word "Scanner".
SELECT product FROM product WHERE product LIKE "%Scanner%"; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What are all of the products whose name includes the substring "Scanner"?
SELECT product FROM product WHERE product LIKE "%Scanner%"; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find the most prominent max page size among all the products.
SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the most common maximum page size?
SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find the name of the products that are not using the most frequently-used max page size.
SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What are the names of all products that are not the most frequently-used maximum page size?
SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### Find the total population of the districts where the area is bigger than the average city area.
SELECT sum(city_population) FROM district WHERE city_area > (SELECT avg(city_area) FROM district); ###
###Postgre SQL tables, with their properties:
# product: ["product_id", "product", "dimensions", "dpi", "pages_per_minute_color", "max_page_size", "interface"]
# store: ["store_id", "store_name", "type", "area_size", "number_of_product_category", "ranking"]
# district: ["district_id", "district_name", "headquartered_city", "city_population", "city_area"]
# store_product: ["store_id", "product_id"]
# store_district: ["store_id", "district_id"]
### What is the total population for all the districts that have an area larger tahn the average city area?
SELECT sum(city_population) FROM district WHERE city_area > (SELECT avg(city_area) FROM district); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the total enrollment number of all colleges?
SELECT sum(enr) FROM College; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many students are enrolled in college?
SELECT sum(enr) FROM College; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the average enrollment number?
SELECT avg(enr) FROM College; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many students, on average, does each college have enrolled?
SELECT avg(enr) FROM College; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many colleges in total?
SELECT count(*) FROM College; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many different colleges are there?
SELECT count(*) FROM College; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many players have more than 1000 hours of training?
SELECT count(*) FROM Player WHERE HS > 1000; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many different players trained for more than 1000 hours?
SELECT count(*) FROM Player WHERE HS > 1000; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many colleges has more than 15000 students?
SELECT count(*) FROM College WHERE enr > 15000; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the number of colleges with a student population greater than 15000?
SELECT count(*) FROM College WHERE enr > 15000; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the average training hours of all players?
SELECT avg(HS) FROM Player; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many hours do the players train on average?
SELECT avg(HS) FROM Player; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the name and training hours of players whose hours are below 1500.
SELECT pName,HS FROM Player WHERE HS < 1500; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names and number of hours spent training for each player who trains for less than 1500 hours?
SELECT pName,HS FROM Player WHERE HS < 1500; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many different colleges do attend the tryout test?
SELECT count(DISTINCT cName) FROM tryout; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many different colleges were represented at tryouts?
SELECT count(DISTINCT cName) FROM tryout; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the unique types of player positions in the tryout?
SELECT count(DISTINCT pPos) FROM tryout; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the different types of player positions?
SELECT count(DISTINCT pPos) FROM tryout; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many students got accepted after the tryout?
SELECT count(*) FROM tryout WHERE decision = 'yes'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many students received a yes from tryouts?
SELECT count(*) FROM tryout WHERE decision = 'yes'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many students whose are playing the role of goalie?
SELECT count(*) FROM tryout WHERE pPos = 'goalie'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the number of students playing as a goalie?
SELECT count(*) FROM tryout WHERE pPos = 'goalie'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the max, average and min training hours of all players.
SELECT avg(HS),max(HS),min(HS) FROM Player; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the average, maximum, and minimum for the number of hours spent training?
SELECT avg(HS),max(HS),min(HS) FROM Player; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is average enrollment of colleges in the state FL?
SELECT avg(enr) FROM College WHERE state = 'FL'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is average number of students enrolled in Florida colleges?
SELECT avg(enr) FROM College WHERE state = 'FL'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of players whose training hours is between 500 and 1500?
SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of players who train between 500 and 1500 hours?
SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the players whose names contain letter 'a'.
SELECT DISTINCT pName FROM Player WHERE pName LIKE '%a%'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Who are the players that have names containing the letter a?
SELECT DISTINCT pName FROM Player WHERE pName LIKE '%a%'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the name, enrollment of the colleges whose size is bigger than 10000 and location is in state LA.
SELECT cName,enr FROM College WHERE enr > 10000 AND state = "LA"; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?
SELECT cName,enr FROM College WHERE enr > 10000 AND state = "LA"; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### List all information about college sorted by enrollment number in the ascending order.
SELECT * FROM College ORDER BY enr; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What information do you have on colleges sorted by increasing enrollment numbers?
SELECT * FROM College ORDER BY enr; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### List the name of the colleges whose enrollment is greater 18000 sorted by the college's name.
SELECT cName FROM College WHERE enr > 18000 ORDER BY cName; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the name of every college in alphabetical order that has more than 18000 students enrolled?
SELECT cName FROM College WHERE enr > 18000 ORDER BY cName; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the name of players whose card is yes in the descending order of training hours.
SELECT pName FROM Player WHERE yCard = 'yes' ORDER BY HS DESC; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the name of the players who received a card in descending order of the hours of training?
SELECT pName FROM Player WHERE yCard = 'yes' ORDER BY HS DESC; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the name of different colleges involved in the tryout in alphabetical order.
SELECT DISTINCT cName FROM tryout ORDER BY cName; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the different names of the colleges involved in the tryout in alphabetical order?
SELECT DISTINCT cName FROM tryout ORDER BY cName; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Which position is most popular among players in the tryout?
SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What was the most popular position at tryouts?
SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the number of students who participate in the tryout for each college ordered by descending count.
SELECT count(*),cName FROM tryout GROUP BY cName ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many students participated in tryouts for each college by descennding count?
SELECT count(*),cName FROM tryout GROUP BY cName ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of schools with the top 3 largest size?
SELECT cName FROM college ORDER BY enr DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of the schools with the top 3 largest class sizes?
SELECT cName FROM college ORDER BY enr DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the name of school that has the smallest enrollment in each state?
SELECT cName,state,min(enr) FROM college GROUP BY state; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the name of the school with smallest enrollment size per state?
SELECT cName,state,min(enr) FROM college GROUP BY state; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Which college has any student who is a goalie and succeeded in the tryout.
SELECT cName FROM tryout WHERE decision = 'yes' AND pPos = 'goalie'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What college has a student who successfully made the team in the role of a goalie?
SELECT cName FROM tryout WHERE decision = 'yes' AND pPos = 'goalie'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the names of either colleges in LA with greater than 15000 size or in state AZ with less than 13000 enrollment.
SELECT cName FROM College WHERE enr < 13000 AND state = "AZ" UNION SELECT cName FROM College WHERE enr > 15000 AND state = "LA"; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of colleges in LA that have more than 15,000 students and of colleges in AZ with less than 13,000 students?
SELECT cName FROM College WHERE enr < 13000 AND state = "AZ" UNION SELECT cName FROM College WHERE enr > 15000 AND state = "LA"; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the names of schools that have some students playing in goalie and mid positions.
SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of all schools that have students trying out for the position of goal and 'mid'-field.
SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many schools have some students playing in goalie and mid positions.
SELECT COUNT(*) FROM (SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid'); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many schools have students playing in goalie and mid-field positions?
SELECT COUNT(*) FROM (SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid'); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the names of schools that have some players in the mid position but not in the goalie position.
SELECT cName FROM tryout WHERE pPos = 'mid' EXCEPT SELECT cName FROM tryout WHERE pPos = 'goalie'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of the schools with some players in the mid position but no goalies?
SELECT cName FROM tryout WHERE pPos = 'mid' EXCEPT SELECT cName FROM tryout WHERE pPos = 'goalie'; ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find the states where have the colleges whose enrollments are less than the largest size.
SELECT DISTINCT state FROM college WHERE enr < (SELECT max(enr) FROM college); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the states with colleges that have enrollments less than the some other college?
SELECT DISTINCT state FROM college WHERE enr < (SELECT max(enr) FROM college); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find names of colleges with enrollment greater than that of some (at least one) college in the FL state.
SELECT DISTINCT cName FROM college WHERE enr > (SELECT min(enr) FROM college WHERE state = 'FL'); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of the colleges that are larger than at least one college in Florida?
SELECT DISTINCT cName FROM college WHERE enr > (SELECT min(enr) FROM college WHERE state = 'FL'); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### Find names of all colleges whose enrollment is greater than that of all colleges in the FL state.
SELECT cName FROM college WHERE enr > (SELECT max(enr) FROM college WHERE state = 'FL'); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What are the names of all colleges with a larger enrollment than the largest college in Florida?
SELECT cName FROM college WHERE enr > (SELECT max(enr) FROM college WHERE state = 'FL'); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the total number of enrollment of schools that do not have any goalie player?
SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos = "goalie"); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the total number of students enrolled in schools without any goalies?
SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos = "goalie"); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the number of states that has some college whose enrollment is larger than the average enrollment?
SELECT count(DISTINCT state) FROM college WHERE enr > (SELECT avg(enr) FROM college); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many states have a college with more students than average?
SELECT count(DISTINCT state) FROM college WHERE enr > (SELECT avg(enr) FROM college); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### What is the number of states that has some colleges whose enrollment is smaller than the average enrollment?
SELECT count(DISTINCT state) FROM college WHERE enr < (SELECT avg(enr) FROM college); ###
###Postgre SQL tables, with their properties:
# college: ["college_name", "state", "enrollment"]
# player: ["player_id", "player_name", "yes_card", "training_hours"]
# tryout: ["player_id", "college_name", "player_position", "decision"]
### How many states have smaller colleges than average?
SELECT count(DISTINCT state) FROM college WHERE enr < (SELECT avg(enr) FROM college); ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### How many devices are there?
SELECT count(*) FROM device; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Count the number of devices.
SELECT count(*) FROM device; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### List the carriers of devices in ascending alphabetical order.
SELECT Carrier FROM device ORDER BY Carrier ASC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the different carriers for devices, listed in alphabetical order?
SELECT Carrier FROM device ORDER BY Carrier ASC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the carriers of devices whose software platforms are not "Android"?
SELECT Carrier FROM device WHERE Software_Platform != 'Android'; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Return the device carriers that do not have Android as their software platform.
SELECT Carrier FROM device WHERE Software_Platform != 'Android'; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the names of shops in ascending order of open year?
SELECT Shop_Name FROM shop ORDER BY Open_Year ASC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Return the names of shops, ordered by year of opening ascending.
SELECT Shop_Name FROM shop ORDER BY Open_Year ASC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What is the average quantity of stocks?
SELECT avg(Quantity) FROM stock; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Give the average quantity of stocks.
SELECT avg(Quantity) FROM stock; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the names and location of the shops in ascending alphabetical order of name.
SELECT Shop_Name,LOCATION FROM shop ORDER BY Shop_Name ASC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Return the names and locations of shops, ordered by name in alphabetical order.
SELECT Shop_Name,LOCATION FROM shop ORDER BY Shop_Name ASC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### How many different software platforms are there for devices?
SELECT count(DISTINCT Software_Platform) FROM device; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Count the number of different software platforms.
SELECT count(DISTINCT Software_Platform) FROM device; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### List the open date of open year of the shop named "Apple".
SELECT Open_Date,Open_Year FROM shop WHERE Shop_Name = "Apple"; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the open dates and years for the shop named Apple?
SELECT Open_Date,Open_Year FROM shop WHERE Shop_Name = "Apple"; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### List the name of the shop with the latest open year.
SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What is the shop name corresponding to the shop that opened in the most recent year?
SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Please show different software platforms and the corresponding number of devices using each.
SELECT Software_Platform,COUNT(*) FROM device GROUP BY Software_Platform; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the different software platforms for devices, and how many devices have each?
SELECT Software_Platform,COUNT(*) FROM device GROUP BY Software_Platform; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Please show the software platforms of devices in descending order of the count.
SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the different software platforms for devices, ordered by frequency descending?
SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### List the software platform shared by the greatest number of devices.
SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What is the software platform that is most common amongst all devices?
SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### List the names of shops that have no devices in stock.
SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock); ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the names of shops that do not have any devices in stock?
SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock); ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Show the locations shared by shops with open year later than 2012 and shops with open year before 2008.
SELECT LOCATION FROM shop WHERE Open_Year > 2012 INTERSECT SELECT LOCATION FROM shop WHERE Open_Year < 2008; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### Which locations contains both shops that opened after the year 2012 and shops that opened before 2008?
SELECT LOCATION FROM shop WHERE Open_Year > 2012 INTERSECT SELECT LOCATION FROM shop WHERE Open_Year < 2008; ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### List the carriers of devices that have no devices in stock.
SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock); ###
###Postgre SQL tables, with their properties:
# device: ["device_id", "device", "carrier", "package_version", "applications", "software_platform"]
# shop: ["shop_id", "shop_name", "location", "open_date", "open_year"]
# stock: ["shop_id", "device_id", "quantity"]
### What are the carriers of devices that are not in stock anywhere?
SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock); ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### How many bookings do we have?
SELECT count(*) FROM BOOKINGS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Count the total number of bookings made.
SELECT count(*) FROM BOOKINGS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### List the order dates of all the bookings.
SELECT Order_Date FROM BOOKINGS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the order date of each booking?
SELECT Order_Date FROM BOOKINGS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Show all the planned delivery dates and actual delivery dates of bookings.
SELECT Planned_Delivery_Date,Actual_Delivery_Date FROM BOOKINGS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the planned delivery date and actual delivery date for each booking?
SELECT Planned_Delivery_Date,Actual_Delivery_Date FROM BOOKINGS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### How many customers do we have?
SELECT count(*) FROM CUSTOMERS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Count the number of customers recorded.
SELECT count(*) FROM CUSTOMERS; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the phone and email for customer Harold?
SELECT Customer_Phone,Customer_Email_Address FROM CUSTOMERS WHERE Customer_Name = "Harold"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Find the phone number and email address of customer "Harold".
SELECT Customer_Phone,Customer_Email_Address FROM CUSTOMERS WHERE Customer_Name = "Harold"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Show all the Store_Name of drama workshop groups.
SELECT Store_Name FROM Drama_Workshop_Groups; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the store names of drama workshop groups?
SELECT Store_Name FROM Drama_Workshop_Groups; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Show the minimum, average, maximum order quantity of all invoices.
SELECT min(Order_Quantity),avg(Order_Quantity),max(Order_Quantity) FROM INVOICES; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the minimum, average, and maximum quantities ordered? Check all the invoices.
SELECT min(Order_Quantity),avg(Order_Quantity),max(Order_Quantity) FROM INVOICES; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the distinct payment method codes in all the invoices?
SELECT DISTINCT payment_method_code FROM INVOICES; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Show me the distinct payment method codes from the invoice record.
SELECT DISTINCT payment_method_code FROM INVOICES; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the description of the marketing region China?
SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name = "China"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Find the marketing region description of China?
SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name = "China"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Show all the distinct product names with price higher than the average.
SELECT DISTINCT Product_Name FROM PRODUCTS WHERE Product_Price > (SELECT avg(Product_Price) FROM PRODUCTS); ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the distinct names of the products that cost more than the average?
SELECT DISTINCT Product_Name FROM PRODUCTS WHERE Product_Price > (SELECT avg(Product_Price) FROM PRODUCTS); ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the name of the most expensive product?
SELECT Product_Name FROM PRODUCTS ORDER BY Product_Price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Tell me the name of the most pricy product.
SELECT Product_Name FROM PRODUCTS ORDER BY Product_Price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### List all product names in ascending order of price.
SELECT Product_Name FROM Products ORDER BY Product_Price ASC; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Sort the names of products in ascending order of their price.
SELECT Product_Name FROM Products ORDER BY Product_Price ASC; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the phone number of the performer Ashley?
SELECT Customer_Phone FROM PERFORMERS WHERE Customer_Name = "Ashley"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Find the phone number of performer "Ashley".
SELECT Customer_Phone FROM PERFORMERS WHERE Customer_Name = "Ashley"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Show all payment method codes and the number of orders for each code.
SELECT payment_method_code,count(*) FROM INVOICES GROUP BY payment_method_code; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### List the distinct payment method codes with the number of orders made
SELECT payment_method_code,count(*) FROM INVOICES GROUP BY payment_method_code; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the payment method code used by the most orders?
SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Find the payment method that is used the most often in all the invoices. Give me its code.
SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the different product names? What is the average product price for each of them?
SELECT Product_Name,avg(Product_Price) FROM PRODUCTS GROUP BY Product_Name; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### For each distinct product name, show its average product price.
SELECT Product_Name,avg(Product_Price) FROM PRODUCTS GROUP BY Product_Name; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What are the product names with average product price smaller than 1000000?
SELECT Product_Name FROM PRODUCTS GROUP BY Product_Name HAVING avg(Product_Price) < 1000000; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Find the product names whose average product price is below 1000000.
SELECT Product_Name FROM PRODUCTS GROUP BY Product_Name HAVING avg(Product_Price) < 1000000; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### How many distinct currency codes are there for all drama workshop groups?
SELECT count(DISTINCT Currency_Code) FROM Drama_Workshop_Groups; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Find the number of distinct currency codes used in drama workshop groups.
SELECT count(DISTINCT Currency_Code) FROM Drama_Workshop_Groups; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the marketing region code that has the most drama workshop groups?
SELECT Marketing_Region_Code FROM Drama_Workshop_Groups GROUP BY Marketing_Region_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Which marketing region has the most drama workshop groups? Give me the region code.
SELECT Marketing_Region_Code FROM Drama_Workshop_Groups GROUP BY Marketing_Region_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the most frequent status of bookings?
SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Which status code is the most common of all the bookings?
SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the average quantities ordered with payment method code "MasterCard" on invoices?
SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code = "MasterCard"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Check the invoices record and compute the average quantities ordered with the payment method "MasterCard".
SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code = "MasterCard"; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### What is the product ID of the most frequently ordered item on invoices?
SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_payment_methods: ["payment_method_code", "payment_method_description"]
# reference_service_types: ["service_type_code", "parent_service_type_code", "service_type_description"]
# addresses: ["address_id", "line_1", "line_2", "city_town", "state_county", "other_details"]
# products: ["product_id", "product_name", "product_price", "product_description", "other_product_service_details"]
# marketing_regions: ["marketing_region_code", "marketing_region_name", "marketing_region_descriptrion", "other_details"]
# clients: ["client_id", "address_id", "customer_email_address", "customer_name", "customer_phone", "other_details"]
# drama_workshop_groups: ["workshop_group_id", "address_id", "currency_code", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# performers: ["performer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# customers: ["customer_id", "address_id", "customer_name", "customer_phone", "customer_email_address", "other_details"]
# stores: ["store_id", "address_id", "marketing_region_code", "store_name", "store_phone", "store_email_address", "other_details"]
# bookings: ["booking_id", "customer_id", "workshop_group_id", "status_code", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# performers_in_bookings: ["order_id", "performer_id"]
# customer_orders: ["order_id", "customer_id", "store_id", "order_date", "planned_delivery_date", "actual_delivery_date", "other_order_details"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity", "other_item_details"]
# invoices: ["invoice_id", "order_id", "payment_method_code", "product_id", "order_quantity", "other_item_details", "order_item_id"]
# services: ["service_id", "service_type_code", "workshop_group_id", "product_description", "product_name", "product_price", "other_product_service_details"]
# bookings_services: ["order_id", "product_id"]
# invoice_items: ["invoice_item_id", "invoice_id", "order_id", "order_item_id", "product_id", "order_quantity", "other_item_details"]
### Find the id of the product ordered the most often on invoices.
SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### How many bands are there?
SELECT count(*) FROM Band; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### Find the number of bands.
SELECT count(*) FROM Band; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are all the labels?
SELECT DISTINCT label FROM Albums; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are the different album labels listed?
SELECT DISTINCT label FROM Albums; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### Find all the albums in 2012.
SELECT * FROM Albums WHERE YEAR = 2012; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### return all columns of the albums created in the year of 2012.
SELECT * FROM Albums WHERE YEAR = 2012; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### How many songs are there?
SELECT count(*) FROM Songs; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### Count the number of songs.
SELECT count(*) FROM Songs; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### How many unique labels are there for albums?
SELECT count(DISTINCT label) FROM albums; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are the unique labels for the albums?
SELECT count(DISTINCT label) FROM albums; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What is the label that has the most albums?
SELECT label FROM albums GROUP BY label ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What is the label with the most albums?
SELECT label FROM albums GROUP BY label ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### Find all the songs whose name contains the word "the".
SELECT title FROM songs WHERE title LIKE '% the %'; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are the names of the songs whose title has the word "the"?
SELECT title FROM songs WHERE title LIKE '% the %'; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are all the instruments used?
SELECT DISTINCT instrument FROM Instruments; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are the different instruments listed in the database?
SELECT DISTINCT instrument FROM Instruments; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What is the most used instrument?
SELECT instrument FROM instruments GROUP BY instrument ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What instrument is used the most?
SELECT instrument FROM instruments GROUP BY instrument ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### How many songs have used the instrument "drums"?
SELECT count(*) FROM instruments WHERE instrument = "drums"; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### How many songs use drums as an instrument?
SELECT count(*) FROM instruments WHERE instrument = "drums"; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### Which vocal type is the most frequently appearring type?
SELECT TYPE FROM vocals GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What is the type of vocables that appears most frequently?
SELECT TYPE FROM vocals GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### Find all the vocal types.
SELECT DISTINCT TYPE FROM vocals; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are the different types of vocals?
SELECT DISTINCT TYPE FROM vocals; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What are the albums produced in year 2010?
SELECT * FROM Albums WHERE YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# songs: ["song_id", "title"]
# albums: ["aid", "title", "year", "label", "type"]
# band: ["id", "first_name", "last_name"]
# instruments: ["song_id", "bandmate_id", "instrument"]
# performance: ["song_id", "bandmate", "stage_position"]
# track_lists: ["album_id", "position", "song_id"]
# vocals: ["song_id", "bandmate", "type"]
### What information is there on albums from 2010?
SELECT * FROM Albums WHERE YEAR = 2010; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Who is the founder of Sony?
SELECT founder FROM manufacturers WHERE name = 'Sony'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Return the founder of Sony.
SELECT founder FROM manufacturers WHERE name = 'Sony'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Where is the headquarter of the company founded by James?
SELECT headquarter FROM manufacturers WHERE founder = 'James'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the headquarter of the company whose founder is James?
SELECT headquarter FROM manufacturers WHERE founder = 'James'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find all manufacturers' names and their headquarters, sorted by the ones with highest revenue first.
SELECT name,headquarter FROM manufacturers ORDER BY revenue DESC; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names and headquarters of all manufacturers, ordered by revenue descending?
SELECT name,headquarter FROM manufacturers ORDER BY revenue DESC; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the average, maximum and total revenues of all companies?
SELECT avg(revenue),max(revenue),sum(revenue) FROM manufacturers; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Return the average, maximum, and total revenues across all manufacturers.
SELECT avg(revenue),max(revenue),sum(revenue) FROM manufacturers; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### How many companies were created by Andy?
SELECT count(*) FROM manufacturers WHERE founder = 'Andy'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Return the number of companies created by Andy.
SELECT count(*) FROM manufacturers WHERE founder = 'Andy'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the total revenue created by the companies whose headquarter is located at Austin.
SELECT sum(revenue) FROM manufacturers WHERE headquarter = 'Austin'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the sum of revenue from companies with headquarters in Austin?
SELECT sum(revenue) FROM manufacturers WHERE headquarter = 'Austin'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the different cities listed?
SELECT DISTINCT headquarter FROM manufacturers; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Give the distinct headquarters of manufacturers.
SELECT DISTINCT headquarter FROM manufacturers; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the number of manufactures that are based in Tokyo or Beijing.
SELECT count(*) FROM manufacturers WHERE headquarter = 'Tokyo' OR headquarter = 'Beijing'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### How many manufacturers have headquarters in either Tokyo or Beijing?
SELECT count(*) FROM manufacturers WHERE headquarter = 'Tokyo' OR headquarter = 'Beijing'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the founder of the company whose name begins with the letter 'S'.
SELECT founder FROM manufacturers WHERE name LIKE 'S%'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Who is the founders of companies whose first letter is S?
SELECT founder FROM manufacturers WHERE name LIKE 'S%'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the name of companies whose revenue is between 100 and 150.
SELECT name FROM manufacturers WHERE revenue BETWEEN 100 AND 150; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names of companies with revenue between 100 and 150?
SELECT name FROM manufacturers WHERE revenue BETWEEN 100 AND 150; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the total revenue of all companies whose main office is at Tokyo or Taiwan?
SELECT sum(revenue) FROM manufacturers WHERE Headquarter = 'Tokyo' OR Headquarter = 'Taiwan'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Return the total revenue of companies with headquarters in Tokyo or Taiwan.
SELECT sum(revenue) FROM manufacturers WHERE Headquarter = 'Tokyo' OR Headquarter = 'Taiwan'; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the name, headquarter and founder of the manufacturer that has the highest revenue.
SELECT name,headquarter,founder FROM manufacturers ORDER BY revenue DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names, headquarters and founders of the company with the highest revenue?
SELECT name,headquarter,founder FROM manufacturers ORDER BY revenue DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the name, headquarter and revenue of all manufacturers sorted by their revenue in the descending order.
SELECT name,headquarter,revenue FROM manufacturers ORDER BY revenue DESC; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names, headquarters and revenues for manufacturers, sorted by revenue descending?
SELECT name,headquarter,revenue FROM manufacturers ORDER BY revenue DESC; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the name of companies whose revenue is greater than the average revenue of all companies.
SELECT name FROM manufacturers WHERE revenue > (SELECT avg(revenue) FROM manufacturers); ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names of manufacturers with revenue greater than the average of all revenues?
SELECT name FROM manufacturers WHERE revenue > (SELECT avg(revenue) FROM manufacturers); ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the name of companies whose revenue is smaller than the revenue of all companies based in Austin.
SELECT name FROM manufacturers WHERE revenue < (SELECT min(revenue) FROM manufacturers WHERE headquarter = 'Austin'); ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names of companies with revenue less than the lowest revenue of any manufacturer in Austin?
SELECT name FROM manufacturers WHERE revenue < (SELECT min(revenue) FROM manufacturers WHERE headquarter = 'Austin'); ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the total revenue of companies whose revenue is larger than the revenue of some companies based in Austin.
SELECT sum(revenue) FROM manufacturers WHERE revenue > (SELECT min(revenue) FROM manufacturers WHERE headquarter = 'Austin'); ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the total revenue of companies with revenue greater than the lowest revenue of any manufacturer in Austin?
SELECT sum(revenue) FROM manufacturers WHERE revenue > (SELECT min(revenue) FROM manufacturers WHERE headquarter = 'Austin'); ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the total revenue of companies of each founder.
SELECT sum(revenue),founder FROM manufacturers GROUP BY founder; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the total revenue of companies started by founder?
SELECT sum(revenue),founder FROM manufacturers GROUP BY founder; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the name and revenue of the company that earns the highest revenue in each city.
SELECT name,max(revenue),Headquarter FROM manufacturers GROUP BY Headquarter; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names and revenues of the companies with the highest revenues in each headquarter city?
SELECT name,max(revenue),Headquarter FROM manufacturers GROUP BY Headquarter; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find the total revenue for each manufacturer.
SELECT sum(revenue),name FROM manufacturers GROUP BY name; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the total revenue of each manufacturer?
SELECT sum(revenue),name FROM manufacturers GROUP BY name; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Select the names of all the products in the store.
SELECT Name FROM Products; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names of all products?
SELECT Name FROM Products; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Select the names and the prices of all the products in the store.
SELECT name,price FROM products; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names and prices of all products in the store?
SELECT name,price FROM products; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Select the name of the products with a price less than or equal to $200.
SELECT name FROM products WHERE price <= 200; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names of products with price at most 200?
SELECT name FROM products WHERE price <= 200; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Find all information of all the products with a price between $60 and $120.
SELECT * FROM products WHERE price BETWEEN 60 AND 120; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is all the information of all the products that have a price between 60 and 120?
SELECT * FROM products WHERE price BETWEEN 60 AND 120; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Compute the average price of all the products.
SELECT avg(price) FROM products; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the average price across all products?
SELECT avg(price) FROM products; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Compute the average price of all products with manufacturer code equal to 2.
SELECT avg(price) FROM products WHERE Manufacturer = 2; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the average price of products with manufacturer codes equal to 2?
SELECT avg(price) FROM products WHERE Manufacturer = 2; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Compute the number of products with a price larger than or equal to $180.
SELECT count(*) FROM products WHERE price >= 180; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### How many products have prices of at least 180?
SELECT count(*) FROM products WHERE price >= 180; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Select the name and price of all products with a price larger than or equal to $180, and sort first by price (in descending order), and then by name (in ascending order).
SELECT name,price FROM products WHERE price >= 180 ORDER BY price DESC,name ASC; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the names and prices of products that cost at least 180, sorted by price decreasing and name ascending?
SELECT name,price FROM products WHERE price >= 180 ORDER BY price DESC,name ASC; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Select the average price of each manufacturer's products, showing only the manufacturer's code.
SELECT AVG(Price),Manufacturer FROM Products GROUP BY Manufacturer; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the average prices of products, grouped by manufacturer code?
SELECT AVG(Price),Manufacturer FROM Products GROUP BY Manufacturer; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Select the name and price of the cheapest product.
SELECT name,price FROM Products ORDER BY price ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What is the name and price of the cheapest product?
SELECT name,price FROM Products ORDER BY price ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### Select the code of the product that is cheapest in each product category.
SELECT code,name,min(price) FROM products GROUP BY name; ###
###Postgre SQL tables, with their properties:
# manufacturers: ["code", "name", "headquarter", "founder", "revenue"]
# products: ["code", "name", "price", "manufacturer"]
### What are the codes and names of the cheapest products in each category?
SELECT code,name,min(price) FROM products GROUP BY name; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### What is the id of the problem log that is created most recently?
SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### Which problem log was created most recently? Give me the log id.
SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### What is the oldest log id and its corresponding problem id?
SELECT problem_log_id,problem_id FROM problem_log ORDER BY log_entry_date LIMIT 1; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### Find the oldest log id and its corresponding problem id.
SELECT problem_log_id,problem_id FROM problem_log ORDER BY log_entry_date LIMIT 1; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### Find all the ids and dates of the logs for the problem whose id is 10.
SELECT problem_log_id,log_entry_date FROM problem_log WHERE problem_id = 10; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### For the problem with id 10, return the ids and dates of its problem logs.
SELECT problem_log_id,log_entry_date FROM problem_log WHERE problem_id = 10; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### List all the log ids and their descriptions from the problem logs.
SELECT problem_log_id,log_entry_description FROM problem_log; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### What are the log id and entry description of each problem?
SELECT problem_log_id,log_entry_description FROM problem_log; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### What are the ids of the problems which are reported after 1978-06-26?
SELECT problem_id FROM problems WHERE date_problem_reported > "1978-06-26"; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### Find the ids of the problems reported after 1978-06-26.
SELECT problem_id FROM problems WHERE date_problem_reported > "1978-06-26"; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### What are the ids of the problems which are reported before 1978-06-26?
SELECT problem_id FROM problems WHERE date_problem_reported < "1978-06-26"; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### Which problems are reported before 1978-06-26? Give me the ids of the problems.
SELECT problem_id FROM problems WHERE date_problem_reported < "1978-06-26"; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### List the names of all the distinct product names in alphabetical order?
SELECT DISTINCT product_name FROM product ORDER BY product_name; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### Sort all the distinct product names in alphabetical order.
SELECT DISTINCT product_name FROM product ORDER BY product_name; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### List all the distinct product names ordered by product id?
SELECT DISTINCT product_name FROM product ORDER BY product_id; ###
###Postgre SQL tables, with their properties:
# problem_category_codes: ["problem_category_code", "problem_category_description"]
# problem_log: ["problem_log_id", "assigned_to_staff_id", "problem_id", "problem_category_code", "problem_status_code", "log_entry_date", "log_entry_description", "log_entry_fix", "other_log_details"]
# problem_status_codes: ["problem_status_code", "problem_status_description"]
# product: ["product_id", "product_name", "product_details"]
# staff: ["staff_id", "staff_first_name", "staff_last_name", "other_staff_details"]
# problems: ["problem_id", "product_id", "closure_authorised_by_staff_id", "reported_by_staff_id", "date_problem_reported", "date_problem_closed", "problem_description", "other_problem_details"]
### What is the list of distinct product names sorted by product id?
SELECT DISTINCT product_name FROM product ORDER BY product_id; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### How many branches where have more than average number of memberships are there?
SELECT count(*) FROM branch WHERE membership_amount > (SELECT avg(membership_amount) FROM branch); ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What is the number of branches that have more than the average number of memberships?
SELECT count(*) FROM branch WHERE membership_amount > (SELECT avg(membership_amount) FROM branch); ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show name, address road, and city for all branches sorted by open year.
SELECT name,address_road,city FROM branch ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the names, address roads, and cities of the branches ordered by opening year?
SELECT name,address_road,city FROM branch ORDER BY open_year; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are names for top three branches with most number of membership?
SELECT name FROM branch ORDER BY membership_amount DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the names for the 3 branches that have the most memberships?
SELECT name FROM branch ORDER BY membership_amount DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show all distinct city where branches with at least 100 memberships are located.
SELECT DISTINCT city FROM branch WHERE membership_amount >= 100; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the different cities that have more than 100 memberships?
SELECT DISTINCT city FROM branch WHERE membership_amount >= 100; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### List all open years when at least two shops are opened.
SELECT open_year FROM branch GROUP BY open_year HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the opening years in which at least two shops opened?
SELECT open_year FROM branch GROUP BY open_year HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show minimum and maximum amount of memberships for all branches opened in 2011 or located at city London.
SELECT min(membership_amount),max(membership_amount) FROM branch WHERE open_year = 2011 OR city = 'London'; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the minimum and maximum membership amounts for all branches that either opened in 2011 or are located in London?
SELECT min(membership_amount),max(membership_amount) FROM branch WHERE open_year = 2011 OR city = 'London'; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show the city and the number of branches opened before 2010 for each city.
SELECT city,count(*) FROM branch WHERE open_year < 2010 GROUP BY city; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### For each city, how many branches opened before 2010?
SELECT city,count(*) FROM branch WHERE open_year < 2010 GROUP BY city; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### How many different levels do members have?
SELECT count(DISTINCT LEVEL) FROM member; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the different membership levels?
SELECT count(DISTINCT LEVEL) FROM member; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show card number, name, and hometown for all members in a descending order of level.
SELECT card_number,name,hometown FROM member ORDER BY LEVEL DESC; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the card numbers, names, and hometowns of every member ordered by descending level?
SELECT card_number,name,hometown FROM member ORDER BY LEVEL DESC; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show the membership level with most number of members.
SELECT LEVEL FROM member GROUP BY LEVEL ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What is the membership level with the most people?
SELECT LEVEL FROM member GROUP BY LEVEL ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show member names without any registered branch.
SELECT name FROM member WHERE member_id NOT IN (SELECT member_id FROM membership_register_branch); ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the names of the members that have never registered at any branch?
SELECT name FROM member WHERE member_id NOT IN (SELECT member_id FROM membership_register_branch); ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### List the branch name and city without any registered members.
SELECT name,city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch); ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the names and cities of the branches that do not have any registered members?
SELECT name,city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch); ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show all city with a branch opened in 2001 and a branch with more than 100 membership.
SELECT city FROM branch WHERE open_year = 2001 AND membership_amount > 100; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the cities that have a branch that opened in 2001 and a branch with more than 100 members?
SELECT city FROM branch WHERE open_year = 2001 AND membership_amount > 100; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### Show all cities without a branch having more than 100 memberships.
SELECT city FROM branch EXCEPT SELECT city FROM branch WHERE membership_amount > 100; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the cities that do not have any branches with more than 100 members?
SELECT city FROM branch EXCEPT SELECT city FROM branch WHERE membership_amount > 100; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### list the card number of all members whose hometown address includes word "Kentucky".
SELECT card_number FROM member WHERE Hometown LIKE "%Kentucky%"; ###
###Postgre SQL tables, with their properties:
# member: ["member_id", "card_number", "name", "hometown", "level"]
# branch: ["branch_id", "name", "open_year", "address_road", "city", "membership_amount"]
# membership_register_branch: ["member_id", "branch_id", "register_year"]
# purchase: ["member_id", "branch_id", "year", "total_pounds"]
### What are the card numbers of members from Kentucky?
SELECT card_number FROM member WHERE Hometown LIKE "%Kentucky%"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the number of students in total.
SELECT count(*) FROM STUDENT; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### How many students are there in total?
SELECT count(*) FROM STUDENT; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the number of voting records in total.
SELECT count(*) FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### How many voting records do we have?
SELECT count(*) FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the distinct number of president votes.
SELECT count(DISTINCT President_Vote) FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### How many distinct president votes are recorded?
SELECT count(DISTINCT President_Vote) FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the maximum age of all the students.
SELECT max(Age) FROM STUDENT; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What is the oldest age among the students?
SELECT max(Age) FROM STUDENT; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the last names of students with major 50.
SELECT LName FROM STUDENT WHERE Major = 50; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the last names of students studying major 50?
SELECT LName FROM STUDENT WHERE Major = 50; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the first names of students with age above 22.
SELECT Fname FROM STUDENT WHERE Age > 22; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the first names of all the students aged above 22?
SELECT Fname FROM STUDENT WHERE Age > 22; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the majors of male (sex is M) students?
SELECT Major FROM STUDENT WHERE Sex = "M"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### List the major of each male student.
SELECT Major FROM STUDENT WHERE Sex = "M"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What is the average age of female (sex is F) students?
SELECT avg(Age) FROM STUDENT WHERE Sex = "F"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the average age of female students.
SELECT avg(Age) FROM STUDENT WHERE Sex = "F"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the maximum and minimum age of students with major 600?
SELECT max(Age),min(Age) FROM STUDENT WHERE Major = 600; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Tell me the ages of the oldest and youngest students studying major 600.
SELECT max(Age),min(Age) FROM STUDENT WHERE Major = 600; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Who are the advisors for students that live in a city with city code "BAL"?
SELECT Advisor FROM STUDENT WHERE city_code = "BAL"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Show the advisors of the students whose city of residence has city code "BAL".
SELECT Advisor FROM STUDENT WHERE city_code = "BAL"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the distinct secretary votes in the fall election cycle?
SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE = "Fall"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Return all the distinct secretary votes made in the fall election cycle.
SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE = "Fall"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the distinct president votes on 08/30/2015?
SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date = "08/30/2015"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Show all the distinct president votes made on 08/30/2015.
SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date = "08/30/2015"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Report the distinct registration date and the election cycle.
SELECT DISTINCT Registration_Date,Election_Cycle FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the distinct registration dates and the election cycles?
SELECT DISTINCT Registration_Date,Election_Cycle FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Report the distinct president vote and the vice president vote.
SELECT DISTINCT President_Vote,VICE_President_Vote FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### List all the distinct president votes and the vice president votes.
SELECT DISTINCT President_Vote,VICE_President_Vote FROM VOTING_RECORD; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### For each advisor, report the total number of students advised by him or her.
SELECT Advisor,count(*) FROM STUDENT GROUP BY Advisor; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### How many students does each advisor have?
SELECT Advisor,count(*) FROM STUDENT GROUP BY Advisor; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Report all advisors that advise more than 2 students.
SELECT Advisor FROM STUDENT GROUP BY Advisor HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Which advisors have more than two students?
SELECT Advisor FROM STUDENT GROUP BY Advisor HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Report all majors that have less than 3 students.
SELECT Major FROM STUDENT GROUP BY Major HAVING COUNT(*) < 3; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What are the majors only less than three students are studying?
SELECT Major FROM STUDENT GROUP BY Major HAVING COUNT(*) < 3; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### For each election cycle, report the number of voting records.
SELECT Election_Cycle,count(*) FROM VOTING_RECORD GROUP BY Election_Cycle; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Count the number of voting records for each election cycle.
SELECT Election_Cycle,count(*) FROM VOTING_RECORD GROUP BY Election_Cycle; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Which major has the most students?
SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the major that is studied by the largest number of students.
SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What is the most common major among female (sex is F) students?
SELECT Major FROM STUDENT WHERE Sex = "F" GROUP BY major ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Find the major that is studied by the most female students.
SELECT Major FROM STUDENT WHERE Sex = "F" GROUP BY major ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### What is the city_code of the city that the most students live in?
SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Return the code of the city that has the most students.
SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Report the distinct advisors who have more than 2 students.
SELECT Advisor FROM STUDENT GROUP BY Advisor HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# voting_record: ["student_id", "registration_date", "election_cycle", "president_vote", "vice_president_vote", "secretary_vote", "treasurer_vote", "class_president_vote", "class_senator_vote"]
### Which advisors are advising more than 2 students?
SELECT Advisor FROM STUDENT GROUP BY Advisor HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### How many products are there?
SELECT count(*) FROM products; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Count the number of products.
SELECT count(*) FROM products; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### How many colors are there?
SELECT count(*) FROM ref_colors; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Count the number of colors.
SELECT count(*) FROM ref_colors; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### How many characteristics are there?
SELECT count(*) FROM CHARACTERISTICS; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Count the number of characteristics.
SELECT count(*) FROM CHARACTERISTICS; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What are the names and buying prices of all the products?
SELECT product_name,typical_buying_price FROM products; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Return the names and typical buying prices for all products.
SELECT product_name,typical_buying_price FROM products; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### List the description of all the colors.
SELECT color_description FROM ref_colors; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What are the descriptions for each color?
SELECT color_description FROM ref_colors; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Find the names of all the product characteristics.
SELECT DISTINCT characteristic_name FROM CHARACTERISTICS; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What are the different names of the product characteristics?
SELECT DISTINCT characteristic_name FROM CHARACTERISTICS; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What are the names of products with category "Spices"?
SELECT product_name FROM products WHERE product_category_code = "Spices"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Return the names of products in the category 'Spices'.
SELECT product_name FROM products WHERE product_category_code = "Spices"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### How many products are there under the category "Seeds"?
SELECT count(*) FROM products WHERE product_category_code = "Seeds"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Count the number of products in the category 'Seeds'.
SELECT count(*) FROM products WHERE product_category_code = "Seeds"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Find the number of products with category "Spices" and typically sold above 1000.
SELECT count(*) FROM products WHERE product_category_code = "Spices" AND typical_buying_price > 1000; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### How many products are in the 'Spices' category and have a typical price of over 1000?
SELECT count(*) FROM products WHERE product_category_code = "Spices" AND typical_buying_price > 1000; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What is the category and typical buying price of the product with name "cumin"?
SELECT product_category_code,typical_buying_price FROM products WHERE product_name = "cumin"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Return the category code and typical price of 'cumin'.
SELECT product_category_code,typical_buying_price FROM products WHERE product_name = "cumin"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Which category does the product named "flax" belong to?
SELECT product_category_code FROM products WHERE product_name = "flax"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What is the code of the category that the product with the name 'flax' belongs to?
SELECT product_category_code FROM products WHERE product_name = "flax"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What is the unit of measuerment of the product category code "Herbs"?
SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code = "Herbs"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Return the unit of measure for 'Herb' products.
SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code = "Herbs"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Find the product category description of the product category with code "Spices".
SELECT product_category_description FROM ref_product_categories WHERE product_category_code = "Spices"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What is the description of the product category with the code 'Spices'?
SELECT product_category_description FROM ref_product_categories WHERE product_category_code = "Spices"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### What is the product category description and unit of measurement of category "Herbs"?
SELECT product_category_description,unit_of_measure FROM ref_product_categories WHERE product_category_code = "Herbs"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Return the description and unit of measurement for products in the 'Herbs' category.
SELECT product_category_description,unit_of_measure FROM ref_product_categories WHERE product_category_code = "Herbs"; ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### How many colors are never used by any product?
SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products ); ###
###Postgre SQL tables, with their properties:
# reference_characteristic_types: ["characteristic_type_code", "characteristic_type_description"]
# reference_colors: ["color_code", "color_description"]
# reference_product_categories: ["product_category_code", "product_category_description", "unit_of_measure"]
# characteristics: ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"]
# products: ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"]
# product_characteristics: ["product_id", "characteristic_id", "product_characteristic_value"]
### Count the number of colors that are not used in any products.
SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products ); ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### How many events are there?
SELECT count(*) FROM event; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### List all the event names by year from the most recent to the oldest.
SELECT name FROM event ORDER BY YEAR DESC; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### What is the name of the event that happened in the most recent year?
SELECT name FROM event ORDER BY YEAR DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### How many stadiums are there?
SELECT count(*) FROM stadium; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find the name of the stadium that has the maximum capacity.
SELECT name FROM stadium ORDER BY capacity DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find the names of stadiums whose capacity is smaller than the average capacity.
SELECT name FROM stadium WHERE capacity < (SELECT avg(capacity) FROM stadium); ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find the country that has the most stadiums.
SELECT country FROM stadium GROUP BY country ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Which country has at most 3 stadiums listed?
SELECT country FROM stadium GROUP BY country HAVING count(*) <= 3; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Which country has both stadiums with capacity greater than 60000 and stadiums with capacity less than 50000?
SELECT country FROM stadium WHERE capacity > 60000 INTERSECT SELECT country FROM stadium WHERE capacity < 50000; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### How many cities have a stadium that was opened before the year of 2006?
SELECT count(DISTINCT city) FROM stadium WHERE opening_year < 2006; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### How many stadiums does each country have?
SELECT country,count(*) FROM stadium GROUP BY country; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Which countries do not have a stadium that was opened after 2006?
SELECT country FROM stadium EXCEPT SELECT country FROM stadium WHERE opening_year > 2006; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### How many stadiums are not in country "Russia"?
SELECT count(*) FROM stadium WHERE country != 'Russia'; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find the names of all swimmers, sorted by their 100 meter scores in ascending order.
SELECT name FROM swimmer ORDER BY meter_100; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### How many different countries are all the swimmers from?
SELECT count(DISTINCT nationality) FROM swimmer; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### List countries that have more than one swimmer.
SELECT nationality,count(*) FROM swimmer GROUP BY nationality HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find all 200 meter and 300 meter results of swimmers with nationality "Australia".
SELECT meter_200,meter_300 FROM swimmer WHERE nationality = 'Australia'; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find the names of stadiums which have never had any event.
SELECT name FROM stadium WHERE id NOT IN (SELECT stadium_id FROM event); ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find the names of the swimmers who have no record.
SELECT name FROM swimmer WHERE id NOT IN (SELECT swimmer_id FROM record); ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### Find all details for each swimmer.
SELECT * FROM swimmer; ###
###Postgre SQL tables, with their properties:
# swimmer: ["id", "name", "nationality", "meter_100", "meter_200", "meter_300", "meter_400", "meter_500", "meter_600", "meter_700", "time"]
# stadium: ["id", "name", "capacity", "city", "country", "opening_year"]
# event: ["id", "name", "stadium_id", "year"]
# record: ["id", "result", "swimmer_id", "event_id"]
### What is the average capacity of the stadiums that were opened in year 2005?
SELECT avg(capacity) FROM stadium WHERE opening_year = 2005; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### How many railways are there?
SELECT count(*) FROM railway; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### List the builders of railways in ascending alphabetical order.
SELECT Builder FROM railway ORDER BY Builder ASC; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### List the wheels and locations of the railways.
SELECT Wheels,LOCATION FROM railway; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### What is the maximum level of managers in countries that are not "Australia"?
SELECT max(LEVEL) FROM manager WHERE Country != "Australia_"; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### What is the average age for all managers?
SELECT avg(Age) FROM manager; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### What are the names of managers in ascending order of level?
SELECT Name FROM manager ORDER BY LEVEL ASC; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### What are the names and arrival times of trains?
SELECT Name,Arrival FROM train; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### What is the name of the oldest manager?
SELECT Name FROM manager ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show different builders of railways, along with the corresponding number of railways using each builder.
SELECT Builder,COUNT(*) FROM railway GROUP BY Builder; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show the most common builder of railways.
SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show different locations of railways along with the corresponding number of railways at each location.
SELECT LOCATION,COUNT(*) FROM railway GROUP BY LOCATION; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show the locations that have more than one railways.
SELECT LOCATION FROM railway GROUP BY LOCATION HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### List the object number of railways that do not have any trains.
SELECT ObjectNumber FROM railway WHERE Railway_ID NOT IN (SELECT Railway_ID FROM train); ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show the countries that have both managers of age above 50 and managers of age below 46.
SELECT Country FROM manager WHERE Age > 50 INTERSECT SELECT Country FROM manager WHERE Age < 46; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show the distinct countries of managers.
SELECT DISTINCT Country FROM manager; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show the working years of managers in descending order of their level.
SELECT Working_year_starts FROM manager ORDER BY LEVEL DESC; ###
###Postgre SQL tables, with their properties:
# railway: ["railway_id", "railway", "builder", "built", "wheels", "location", "objectnumber"]
# train: ["train_id", "train_num", "name", "from", "arrival", "railway_id"]
# manager: ["manager_id", "name", "country", "working_year_starts", "age", "level"]
# railway_manage: ["railway_id", "manager_id", "from_year"]
### Show the countries that have managers of age above 50 or below 46.
SELECT Country FROM manager WHERE Age > 50 OR Age < 46; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### How many addresses are there in country USA?
SELECT count(*) FROM addresses WHERE country = 'USA'; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### Show all distinct cities in the address record.
SELECT DISTINCT city FROM addresses; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### Show each state and the number of addresses in each state.
SELECT state_province_county,count(*) FROM addresses GROUP BY state_province_county; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### Show names and phones of customers who do not have address information.
SELECT customer_name,customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer_address_history); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### Show the product type codes which have at least two products.
SELECT product_type_code FROM products GROUP BY product_type_code HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### Show the name, phone, and payment method code for all customers in descending order of customer number.
SELECT customer_name,customer_phone,payment_method_code FROM customers ORDER BY customer_number DESC; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### Show the minimum, maximum, average price for all products.
SELECT min(product_price),max(product_price),avg(product_price) FROM products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### How many products have a price higher than the average?
SELECT count(*) FROM products WHERE product_price > (SELECT avg(product_price) FROM products); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# products: ["product_id", "product_type_code", "product_name", "product_price"]
# customers: ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"]
# contacts: ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"]
# customer_address_history: ["customer_id", "address_id", "date_from", "date_to"]
# customer_orders: ["order_id", "customer_id", "order_date", "order_status_code"]
# order_items: ["order_item_id", "order_id", "product_id", "order_quantity"]
### Show the product type and name for the products with price higher than 1000 or lower than 500.
SELECT product_type_code,product_name FROM products WHERE product_price > 1000 OR product_price < 500; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the name of dorms only for female (F gender).
SELECT dorm_name FROM dorm WHERE gender = 'F'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the names of the all-female dorms?
SELECT dorm_name FROM dorm WHERE gender = 'F'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the name of dorms that can accommodate more than 300 students.
SELECT dorm_name FROM dorm WHERE student_capacity > 300; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the names of all the dorms that can accomdate more than 300 students?
SELECT dorm_name FROM dorm WHERE student_capacity > 300; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many female students (sex is F) whose age is below 25?
SELECT count(*) FROM student WHERE sex = 'F' AND age < 25; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many girl students who are younger than 25?
SELECT count(*) FROM student WHERE sex = 'F' AND age < 25; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the first name of students who is older than 20.
SELECT fname FROM student WHERE age > 20; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the first names of all students who are older than 20?
SELECT fname FROM student WHERE age > 20; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the first name of students living in city PHL whose age is between 20 and 25.
SELECT fname FROM student WHERE city_code = 'PHL' AND age BETWEEN 20 AND 25; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the first name of the students who are in age 20 to 25 and living in PHL city?
SELECT fname FROM student WHERE city_code = 'PHL' AND age BETWEEN 20 AND 25; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many dorms are there?
SELECT count(*) FROM dorm; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many dorms are in the database?
SELECT count(*) FROM dorm; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number of distinct amenities.
SELECT count(*) FROM dorm_amenity; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many diffrent dorm amenities are there?
SELECT count(*) FROM dorm_amenity; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the total capacity of all dorms.
SELECT sum(student_capacity) FROM dorm; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the total student capacity of all dorms?
SELECT sum(student_capacity) FROM dorm; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many students are there?
SELECT count(*) FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many students exist?
SELECT count(*) FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the average age of all students living in the each city.
SELECT avg(age),city_code FROM student GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the average age for each city and what are those cities?
SELECT avg(age),city_code FROM student GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the average and total capacity of dorms for the students with gender X.
SELECT avg(student_capacity),sum(student_capacity) FROM dorm WHERE gender = 'X'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the average and total capacity for all dorms who are of gender X?
SELECT avg(student_capacity),sum(student_capacity) FROM dorm WHERE gender = 'X'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number of dorms that have some amenity.
SELECT count(DISTINCT dormid) FROM has_amenity; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many dorms have amenities?
SELECT count(DISTINCT dormid) FROM has_amenity; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the name of dorms that do not have any amenity
SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the names of all the dorms that don't have any amenities?
SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number of distinct gender for dorms.
SELECT count(DISTINCT gender) FROM dorm; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many different genders are there in the dorms?
SELECT count(DISTINCT gender) FROM dorm; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the capacity and gender type of the dorm whose name has substring ‘Donor’.
SELECT student_capacity,gender FROM dorm WHERE dorm_name LIKE '%Donor%'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the student capacity and type of gender for the dorm whose name as the phrase Donor in it?
SELECT student_capacity,gender FROM dorm WHERE dorm_name LIKE '%Donor%'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the name and gender type of the dorms whose capacity is greater than 300 or less than 100.
SELECT dorm_name,gender FROM dorm WHERE student_capacity > 300 OR student_capacity < 100; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the names and types of the dorms that have a capacity greater than 300 or less than 100?
SELECT dorm_name,gender FROM dorm WHERE student_capacity > 300 OR student_capacity < 100; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the numbers of different majors and cities.
SELECT count(DISTINCT major),count(DISTINCT city_code) FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many different majors are there and how many different city codes are there for each student?
SELECT count(DISTINCT major),count(DISTINCT city_code) FROM student; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the last name of students who is either female (sex is F) and living in the city of code BAL or male (sex is M) and in age of below 20.
SELECT lname FROM student WHERE sex = 'F' AND city_code = 'BAL' UNION SELECT lname FROM student WHERE sex = 'M' AND age < 20; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?
SELECT lname FROM student WHERE sex = 'F' AND city_code = 'BAL' UNION SELECT lname FROM student WHERE sex = 'M' AND age < 20; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the name of the dorm with the largest capacity.
SELECT dorm_name FROM dorm ORDER BY student_capacity DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the names of the dorm with the largest capacity?
SELECT dorm_name FROM dorm ORDER BY student_capacity DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### List in alphabetic order all different amenities.
SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the different dorm amenity names in alphabetical order?
SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the code of city where most of students are living in.
SELECT city_code FROM student GROUP BY city_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the code of the city with the most students?
SELECT city_code FROM student GROUP BY city_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the first and last name of students whose age is younger than the average age.
SELECT fname,lname FROM student WHERE age < (SELECT avg(age) FROM student); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the first and last name of all students who are younger than average?
SELECT fname,lname FROM student WHERE age < (SELECT avg(age) FROM student); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### List the first and last name of students who are not living in the city with code HKG, and sorted the results by their ages.
SELECT fname,lname FROM student WHERE city_code != 'HKG' ORDER BY age; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What are the first and last names of all students who are not living in the city HKG and order the results by age?
SELECT fname,lname FROM student WHERE city_code != 'HKG' ORDER BY age; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number of dorms and total capacity for each gender.
SELECT count(*),sum(student_capacity),gender FROM dorm GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many dorms are there and what is the total capacity for each gender?
SELECT count(*),sum(student_capacity),gender FROM dorm GROUP BY gender; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the average and oldest age for students with different sex.
SELECT avg(age),max(age),sex FROM student GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the average and oldest age for each gender of student?
SELECT avg(age),max(age),sex FROM student GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number of students in each major.
SELECT count(*),major FROM student GROUP BY major; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many students are there in each major?
SELECT count(*),major FROM student GROUP BY major; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number and average age of students living in each city.
SELECT count(*),avg(age),city_code FROM student GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many students live in each city and what are their average ages?
SELECT count(*),avg(age),city_code FROM student GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the average age and number of male students (with sex M) from each city.
SELECT count(*),avg(age),city_code FROM student WHERE sex = 'M' GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the average age and how many male students are there in each city?
SELECT count(*),avg(age),city_code FROM student WHERE sex = 'M' GROUP BY city_code; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number of students for the cities where have more than one student.
SELECT count(*),city_code FROM student GROUP BY city_code HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many students are from each city, and which cities have more than one cities?
SELECT count(*),city_code FROM student GROUP BY city_code HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the first and last name of students who are not in the largest major.
SELECT fname,lname FROM student WHERE major != (SELECT major FROM student GROUP BY major ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### What is the first and last name of the students who are not in the largest major?
SELECT fname,lname FROM student WHERE major != (SELECT major FROM student GROUP BY major ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### Find the number of students whose age is older than the average age for each gender.
SELECT count(*),sex FROM student WHERE age > (SELECT avg(age) FROM student) GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# dorm: ["dorm_id", "dorm_name", "student_capacity", "gender"]
# dorm_amenity: ["amenity_id", "amenity_name"]
# has_amenity: ["dorm_id", "amenity_id"]
# lives_in: ["student_id", "dorm_id", "room_number"]
### How many students are older than average for each gender?
SELECT count(*),sex FROM student WHERE age > (SELECT avg(age) FROM student) GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### How many customers are there?
SELECT count(*) FROM customers; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Count the number of customers.
SELECT count(*) FROM customers; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the emails and phone numbers of all the customers, ordered by email address and phone number.
SELECT email_address,phone_number FROM customers ORDER BY email_address,phone_number; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What are the emails and phone numbers of all customers, sorted by email address and phone number?
SELECT email_address,phone_number FROM customers ORDER BY email_address,phone_number; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Which city has the least number of customers whose type code is "Good_Credit_Rating"?
SELECT town_city FROM customers WHERE customer_type_code = "Good_Credit_Rating" GROUP BY town_city ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Return the city with the customer type code "Good_Credit_Rating" that had the fewest customers.
SELECT town_city FROM customers WHERE customer_type_code = "Good_Credit_Rating" GROUP BY town_city ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the email and phone number of the customers who have never filed a complaint before.
SELECT email_address,phone_number FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM complaints); ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What are the emails and phone numbers of custoemrs who have never filed a complaint?
SELECT email_address,phone_number FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM complaints); ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the phone number of all the customers and staff.
SELECT phone_number FROM customers UNION SELECT phone_number FROM staff; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What are the phone numbers of all customers and all staff members?
SELECT phone_number FROM customers UNION SELECT phone_number FROM staff; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What is the description of the product named "Chocolate"?
SELECT product_description FROM products WHERE product_name = "Chocolate"; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Return the description of the product called "Chocolate".
SELECT product_description FROM products WHERE product_name = "Chocolate"; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the name and category of the most expensive product.
SELECT product_name,product_category_code FROM products ORDER BY product_price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What is the name and category code of the product with the highest price?
SELECT product_name,product_category_code FROM products ORDER BY product_price DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the prices of products which has never received a single complaint.
SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints); ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What are the prices of products that have never gotten a complaint?
SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints); ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What is the average price of the products for each category?
SELECT avg(product_price),product_category_code FROM products GROUP BY product_category_code; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Return the average price of products that have each category code.
SELECT avg(product_price),product_category_code FROM products GROUP BY product_category_code; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Which complaint status has more than 3 records on file?
SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Return complaint status codes have more than 3 corresponding complaints?
SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the last name of the staff whose email address contains "wrau".
SELECT last_name FROM staff WHERE email_address LIKE "%wrau%"; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What are the last names of staff with email addressed containing the substring "wrau"?
SELECT last_name FROM staff WHERE email_address LIKE "%wrau%"; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### How many customers are there in the customer type with the most customers?
SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Count the number of customers that have the customer type that is most common.
SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### How many distinct complaint type codes are there in the database?
SELECT count(DISTINCT complaint_type_code) FROM complaints; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Count the number of different complaint type codes.
SELECT count(DISTINCT complaint_type_code) FROM complaints; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the address line 1 and 2 of the customer with email "vbogisich@example.org".
SELECT address_line_1,address_line_2 FROM customers WHERE email_address = "vbogisich@example.org"; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### What are lines 1 and 2 of the addressed of the customer with the email "vbogisich@example.org"?
SELECT address_line_1,address_line_2 FROM customers WHERE email_address = "vbogisich@example.org"; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Find the number of complaints with Product Failure type for each complaint status.
SELECT complaint_status_code,count(*) FROM complaints WHERE complaint_type_code = "Product_Failure" GROUP BY complaint_status_code; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Of complaints with the type code "Product_Failure", how many had each different status code?
SELECT complaint_status_code,count(*) FROM complaints WHERE complaint_type_code = "Product_Failure" GROUP BY complaint_status_code; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Which state has the most customers?
SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# staff: ["staff_id", "gender", "first_name", "last_name", "email_address", "phone_number"]
# customers: ["customer_id", "customer_type_code", "address_line_1", "address_line_2", "town_city", "state", "email_address", "phone_number"]
# products: ["product_id", "parent_product_id", "product_category_code", "date_product_first_available", "date_product_discontinued", "product_name", "product_description", "product_price"]
# complaints: ["complaint_id", "product_id", "customer_id", "complaint_outcome_code", "complaint_status_code", "complaint_type_code", "date_complaint_raised", "date_complaint_closed", "staff_id"]
### Give the state that has the most customers.
SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### How many submissions are there?
SELECT count(*) FROM submission; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Count the number of submissions.
SELECT count(*) FROM submission; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### List the authors of submissions in ascending order of scores.
SELECT Author FROM submission ORDER BY Scores ASC; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Find the author for each submission and list them in ascending order of submission score.
SELECT Author FROM submission ORDER BY Scores ASC; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### What are the authors of submissions and their colleges?
SELECT Author,College FROM submission; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### For each submission, show the author and their affiliated college.
SELECT Author,College FROM submission; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Show the names of authors from college "Florida" or "Temple"
SELECT Author FROM submission WHERE College = "Florida" OR College = "Temple"; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Which authors with submissions are from college "Florida" or "Temple"?
SELECT Author FROM submission WHERE College = "Florida" OR College = "Temple"; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### What is the average score of submissions?
SELECT avg(Scores) FROM submission; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Compute the average score of submissions.
SELECT avg(Scores) FROM submission; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### What is the author of the submission with the highest score?
SELECT Author FROM submission ORDER BY Scores DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Find the author who achieved the highest score in a submission.
SELECT Author FROM submission ORDER BY Scores DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Show different colleges along with the number of authors of submission from each college.
SELECT College,COUNT(*) FROM submission GROUP BY College; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### For each college, return the college name and the count of authors with submissions from that college.
SELECT College,COUNT(*) FROM submission GROUP BY College; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Show the most common college of authors of submissions.
SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Which college has the most authors with submissions?
SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Show the colleges that have both authors with submission score larger than 90 and authors with submission score smaller than 80.
SELECT College FROM submission WHERE Scores > 90 INTERSECT SELECT College FROM submission WHERE Scores < 80; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Which colleges have both authors with submission score above 90 and authors with submission score below 80?
SELECT College FROM submission WHERE Scores > 90 INTERSECT SELECT College FROM submission WHERE Scores < 80; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Show the date and venue of each workshop in ascending alphabetical order of the venue.
SELECT Date,Venue FROM workshop ORDER BY Venue; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Sort the each workshop in alphabetical order of the venue. Return the date and venue of each workshop.
SELECT Date,Venue FROM workshop ORDER BY Venue; ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### List the authors who do not have submission to any workshop.
SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance); ###
###Postgre SQL tables, with their properties:
# workshop: ["workshop_id", "date", "venue", "name"]
# submission: ["submission_id", "scores", "author", "college"]
# acceptance: ["submission_id", "workshop_id", "result"]
### Which authors did not submit to any workshop?
SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance); ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Find the number of investors in total.
SELECT count(*) FROM INVESTORS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show all investor details.
SELECT Investor_details FROM INVESTORS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show all distinct lot details.
SELECT DISTINCT lot_details FROM LOTS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the maximum amount of transaction.
SELECT max(amount_of_transaction) FROM TRANSACTIONS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show all date and share count of transactions.
SELECT date_of_transaction,share_count FROM TRANSACTIONS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### What is the total share of transactions?
SELECT sum(share_count) FROM TRANSACTIONS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show all transaction ids with transaction code 'PUR'.
SELECT transaction_id FROM TRANSACTIONS WHERE transaction_type_code = 'PUR'; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show all dates of transactions whose type code is "SALE".
SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code = "SALE"; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the average amount of transactions with type code "SALE".
SELECT avg(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code = "SALE"; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the description of transaction type with code "PUR".
SELECT transaction_type_description FROM Ref_Transaction_Types WHERE transaction_type_code	 = "PUR"; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the minimum amount of transactions whose type code is "PUR" and whose share count is bigger than 50.
SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code = "PUR" AND share_count > 50; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the maximum share count of transactions where the amount is smaller than 10000
SELECT max(share_count) FROM TRANSACTIONS WHERE amount_of_transaction < 10000; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the dates of transactions if the share count is bigger than 100 or the amount is bigger than 1000.
SELECT date_of_transaction FROM TRANSACTIONS WHERE share_count > 100 OR amount_of_transaction > 1000; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### How many distinct transaction types are used in the transactions?
SELECT COUNT(DISTINCT transaction_type_code) FROM TRANSACTIONS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Return the lot details and investor ids.
SELECT lot_details,investor_id FROM LOTS; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the average transaction amount for different transaction types.
SELECT transaction_type_code,avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the maximum and minimum share count of different transaction types.
SELECT transaction_type_code,max(share_count),min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the average share count of transactions for different investors.
SELECT investor_id,avg(share_count) FROM TRANSACTIONS GROUP BY investor_id; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the average share count of transactions each each investor, ordered by average share count.
SELECT investor_id,avg(share_count) FROM TRANSACTIONS GROUP BY investor_id ORDER BY avg(share_count); ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the average amount of transactions for different investors.
SELECT investor_id,avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY investor_id; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the number of transactions with transaction type code "SALE" for different investors if it is larger than 0.
SELECT investor_id,COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code = "SALE" GROUP BY investor_id; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the number of transactions for different investors.
SELECT investor_id,COUNT(*) FROM TRANSACTIONS GROUP BY investor_id; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the transaction type code that occurs the fewest times.
SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### Show the transaction type code that occurs the most frequently.
SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### What are the dates of transactions with at least 100 share count or amount bigger than 100?
SELECT date_of_transaction FROM TRANSACTIONS WHERE share_count >= 100 OR amount_of_transaction >= 100; ###
###Postgre SQL tables, with their properties:
# investors: ["investor_id", "investor_details"]
# lots: ["lot_id", "investor_id", "lot_details"]
# reference_transaction_types: ["transaction_type_code", "transaction_type_description"]
# transactions: ["transaction_id", "investor_id", "transaction_type_code", "date_of_transaction", "amount_of_transaction", "share_count", "other_details"]
# sales: ["sales_transaction_id", "sales_details"]
# purchases: ["purchase_transaction_id", "purchase_details"]
# transactions_lots: ["transaction_id", "lot_id"]
### What are the details of all sales and purchases?
SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### How many available hotels are there in total?
SELECT count(*) FROM HOTELS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Find the total number of available hotels.
SELECT count(*) FROM HOTELS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the price ranges of hotels?
SELECT price_range FROM HOTELS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Tell me the price ranges for all the hotels.
SELECT price_range FROM HOTELS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show all distinct location names.
SELECT DISTINCT Location_Name FROM LOCATIONS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the distinct location names?
SELECT DISTINCT Location_Name FROM LOCATIONS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the names and details of all the staff members.
SELECT Name,Other_Details FROM Staff; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What is the name and detail of each staff member?
SELECT Name,Other_Details FROM Staff; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show details of all visitors.
SELECT Tourist_Details FROM VISITORS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What is the detail of each visitor?
SELECT Tourist_Details FROM VISITORS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the price ranges of hotels with 5 star ratings.
SELECT price_range FROM HOTELS WHERE star_rating_code = "5"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the price ranges of five star hotels?
SELECT price_range FROM HOTELS WHERE star_rating_code = "5"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the average price range of hotels that have 5 star ratings and allow pets.
SELECT avg(price_range) FROM HOTELS WHERE star_rating_code = "5" AND pets_allowed_yn = 1; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What is the average price range of five star hotels that allow pets?
SELECT avg(price_range) FROM HOTELS WHERE star_rating_code = "5" AND pets_allowed_yn = 1; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What is the address of the location "UK_Gallery"?
SELECT Address FROM LOCATIONS WHERE Location_Name = "UK_Gallery"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Find the address of the location named "UK_Gallery".
SELECT Address FROM LOCATIONS WHERE Location_Name = "UK_Gallery"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What is the detail of the location UK Gallery?
SELECT Other_Details FROM LOCATIONS WHERE Location_Name = "UK_Gallery"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Return the detail of the location named "UK_Gallery".
SELECT Other_Details FROM LOCATIONS WHERE Location_Name = "UK_Gallery"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Which location names contain the word "film"?
SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE "%film%"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Find all the locations whose names contain the word "film".
SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE "%film%"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### How many distinct names are associated with all the photos?
SELECT count(DISTINCT Name) FROM PHOTOS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Count the number of distinct names associated with the photos.
SELECT count(DISTINCT Name) FROM PHOTOS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the distinct visit dates?
SELECT DISTINCT Visit_Date FROM VISITS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Find all the distinct visit dates.
SELECT DISTINCT Visit_Date FROM VISITS; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the names of the tourist attractions that can be accessed by bus?
SELECT Name FROM TOURIST_ATTRACTIONS WHERE How_to_Get_There = "bus"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Which tourist attractions can we get to by bus? Tell me the names of the attractions.
SELECT Name FROM TOURIST_ATTRACTIONS WHERE How_to_Get_There = "bus"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the names and opening hours of the tourist attractions that can be accessed by bus or walk?
SELECT Name,Opening_Hours FROM TOURIST_ATTRACTIONS WHERE How_to_Get_There = "bus" OR How_to_Get_There = "walk"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Find the names and opening hours of the tourist attractions that we get to by bus or walk.
SELECT Name,Opening_Hours FROM TOURIST_ATTRACTIONS WHERE How_to_Get_There = "bus" OR How_to_Get_There = "walk"; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the average price of hotels for each star rating code.
SELECT star_rating_code,avg(price_range) FROM HOTELS GROUP BY star_rating_code; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What is the average price range of hotels for each each star rating code?
SELECT star_rating_code,avg(price_range) FROM HOTELS GROUP BY star_rating_code; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the average price of hotels for different pet policy.
SELECT pets_allowed_yn,avg(price_range) FROM HOTELS GROUP BY pets_allowed_yn; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the average prices of hotels grouped by their pet policy.
SELECT pets_allowed_yn,avg(price_range) FROM HOTELS GROUP BY pets_allowed_yn; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the id and star rating of each hotel, ordered by its price from low to high.
SELECT hotel_id,star_rating_code FROM HOTELS ORDER BY price_range ASC; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Find the id and star rating of each hotel and sort them in increasing order of price.
SELECT hotel_id,star_rating_code FROM HOTELS ORDER BY price_range ASC; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the details of the top 3 most expensive hotels.
SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the details of the three most expensive hotels?
SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the details and star ratings of the 3 least expensive hotels.
SELECT other_hotel_details,star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### What are the details and star ratings of the three hotels with the lowest price ranges?
SELECT other_hotel_details,star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show the transportation method most people choose to get to tourist attractions.
SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Which transportation method is used the most often to get to tourist attractions?
SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Show different ways to get to attractions and the number of attractions that can be accessed in the corresponding way.
SELECT How_to_Get_There,COUNT(*) FROM Tourist_Attractions GROUP BY How_to_Get_There; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### List all the possible ways to get to attractions, together with the number of attractions accessible by these methods.
SELECT How_to_Get_There,COUNT(*) FROM Tourist_Attractions GROUP BY How_to_Get_There; ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### How many tourists did not make any visit?
SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits ); ###
###Postgre SQL tables, with their properties:
# ref_hotel_star_ratings: ["star_rating_code", "star_rating_description"]
# locations: ["location_id", "location_name", "address", "other_details"]
# ref_attraction_types: ["attraction_type_code", "attraction_type_description"]
# visitors: ["tourist_id", "tourist_details"]
# features: ["feature_id", "feature_details"]
# hotels: ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"]
# tourist_attractions: ["tourist_attraction_id", "attraction_type_code", "location_id", "how_to_get_there", "name", "description", "opening_hours", "other_details"]
# street_markets: ["market_id", "market_details"]
# shops: ["shop_id", "shop_details"]
# museums: ["museum_id", "museum_details"]
# royal_family: ["royal_family_id", "royal_family_details"]
# theme_parks: ["theme_park_id", "theme_park_details"]
# visits: ["visit_id", "tourist_attraction_id", "tourist_id", "visit_date", "visit_details"]
# photos: ["photo_id", "tourist_attraction_id", "name", "description", "filename", "other_details"]
# staff: ["staff_id", "tourist_attraction_id", "name", "other_details"]
# tourist_attraction_features: ["tourist_attraction_id", "feature_id"]
### Count the number of tourists who did not visit any place.
SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits ); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many video games exist?
SELECT count(*) FROM Video_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many video games do you have?
SELECT count(*) FROM Video_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many video game types exist?
SELECT count(DISTINCT gtype) FROM Video_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What is the count of different game types?
SELECT count(DISTINCT gtype) FROM Video_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all video game types.
SELECT DISTINCT gtype FROM Video_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the different types of video games?
SELECT DISTINCT gtype FROM Video_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all video games and their types in the order of their names.
SELECT gname,gtype FROM Video_games ORDER BY gname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the names of all the video games and their types in alphabetical order?
SELECT gname,gtype FROM Video_games ORDER BY gname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all video games with type Collectible card game.
SELECT gname FROM Video_games WHERE gtype = "Collectible_card_game"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the names of all video games that are collectible cards?
SELECT gname FROM Video_games WHERE gtype = "Collectible_card_game"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What is the type of video game Call of Destiny.
SELECT gtype FROM Video_games WHERE gname = "Call_of_Destiny"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What type of game is Call of Destiny?
SELECT gtype FROM Video_games WHERE gname = "Call_of_Destiny"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many video games have type Massively multiplayer online game?
SELECT count(*) FROM Video_games WHERE gtype = "Massively_multiplayer_online_game"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Count the number of video games with Massively multiplayer online game type .
SELECT count(*) FROM Video_games WHERE gtype = "Massively_multiplayer_online_game"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all video game types and the number of video games in each type.
SELECT gtype,count(*) FROM Video_games GROUP BY gtype; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the types of video games and how many are in each type?
SELECT gtype,count(*) FROM Video_games GROUP BY gtype; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Which game type has most number of games?
SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What type has the most games?
SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Which game type has least number of games?
SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What is the type with the fewest games?
SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show ids for all students who live in CHI.
SELECT StuID FROM Student WHERE city_code = "CHI"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all students who live in CHI?
SELECT StuID FROM Student WHERE city_code = "CHI"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show ids for all students who have advisor 1121.
SELECT StuID FROM Student WHERE Advisor = 1121; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all students who have advisor number 1121?
SELECT StuID FROM Student WHERE Advisor = 1121; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show first name for all students with major 600.
SELECT Fname FROM Student WHERE Major = 600; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the first names for all students who are from the major numbered 600?
SELECT Fname FROM Student WHERE Major = 600; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show the average, minimum, and maximum age for different majors.
SELECT major,avg(age),min(age),max(age) FROM Student GROUP BY major; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the average, minimum, and max ages for each of the different majors?
SELECT major,avg(age),min(age),max(age) FROM Student GROUP BY major; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all advisors who have at least two students.
SELECT advisor FROM Student GROUP BY advisor HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the advisors
SELECT advisor FROM Student GROUP BY advisor HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many sports do we have?
SELECT count(DISTINCT sportname) FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many different types of sports do we offer?
SELECT count(DISTINCT sportname) FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many students play sports?
SELECT count(DISTINCT StuID) FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many different students are involved in sports?
SELECT count(DISTINCT StuID) FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### List ids for all student who are on scholarship.
SELECT StuID FROM Sportsinfo WHERE onscholarship = 'Y'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids for all sporty students who are on scholarship?
SELECT StuID FROM Sportsinfo WHERE onscholarship = 'Y'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many games are played for all students?
SELECT sum(gamesplayed) FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What is the total number of games played?
SELECT sum(gamesplayed) FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many games are played for all football games by students on scholarship?
SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname = "Football" AND onscholarship = 'Y'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What is the total number of all football games played by scholarship students?
SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname = "Football" AND onscholarship = 'Y'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all sport name and the number of students.
SELECT sportname,count(*) FROM Sportsinfo GROUP BY sportname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many students play each sport?
SELECT sportname,count(*) FROM Sportsinfo GROUP BY sportname; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all student IDs with the number of sports and total number of games played
SELECT StuID,count(*),sum(gamesplayed) FROM Sportsinfo GROUP BY StuID; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all students along with how many sports and games did they play?
SELECT StuID,count(*),sum(gamesplayed) FROM Sportsinfo GROUP BY StuID; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all student IDs with more than total 10 hours per week on all sports played.
SELECT StuID FROM Sportsinfo GROUP BY StuID HAVING sum(hoursperweek) > 10; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the student IDs for everybody who worked for more than 10 hours per week on all sports?
SELECT StuID FROM Sportsinfo GROUP BY StuID HAVING sum(hoursperweek) > 10; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Which sport has most number of students on scholarship?
SELECT sportname FROM Sportsinfo WHERE onscholarship = 'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What is the sport with the most scholarship students?
SELECT sportname FROM Sportsinfo WHERE onscholarship = 'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show student ids who don't have any sports.
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all students who don't play sports?
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Sportsinfo; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show student ids who are on scholarship and have major 600.
SELECT StuID FROM Student WHERE major = 600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship = 'Y'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the student ids for those on scholarship in major number 600?
SELECT StuID FROM Student WHERE major = 600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship = 'Y'; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show student ids who are female and play football.
SELECT StuID FROM Student WHERE sex = 'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname = "Football"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all female students who play football?
SELECT StuID FROM Student WHERE sex = 'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname = "Football"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all male student ids who don't play football.
SELECT StuID FROM Student WHERE sex = 'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname = "Football"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all male students who do not play football?
SELECT StuID FROM Student WHERE sex = 'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname = "Football"; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many students play video games?
SELECT count(DISTINCT StuID) FROM Plays_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### How many different students play games?
SELECT count(DISTINCT StuID) FROM Plays_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show ids of students who don't play video game.
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Plays_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all students who are not video game players?
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Plays_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show ids of students who play video game and play sports.
SELECT StuID FROM Sportsinfo INTERSECT SELECT StuID FROM Plays_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all students who played video games and sports?
SELECT StuID FROM Sportsinfo INTERSECT SELECT StuID FROM Plays_games; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all game ids and the number of hours played.
SELECT gameid,sum(hours_played) FROM Plays_games GROUP BY gameid; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are ids and total number of hours played for each game?
SELECT gameid,sum(hours_played) FROM Plays_games GROUP BY gameid; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Show all student ids and the number of hours played.
SELECT Stuid,sum(hours_played) FROM Plays_games GROUP BY Stuid; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the ids of all students and number of hours played?
SELECT Stuid,sum(hours_played) FROM Plays_games GROUP BY Stuid; ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### Find the first name and age of the students who are playing both Football and Lacrosse.
SELECT fname,age FROM Student WHERE StuID IN (SELECT StuID FROM Sportsinfo WHERE SportName = "Football" INTERSECT SELECT StuID FROM Sportsinfo WHERE SportName = "Lacrosse"); ###
###Postgre SQL tables, with their properties:
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# video_games: ["game_id", "game_name", "game_type"]
# plays_games: ["student_id", "game_id", "hours_played"]
# sports_info: ["student_id", "sport_name", "hours_per_week", "games_played", "on_scholarship"]
### What are the first names and ages of all students who are playing both Football and Lacrosse?
SELECT fname,age FROM Student WHERE StuID IN (SELECT StuID FROM Sportsinfo WHERE SportName = "Football" INTERSECT SELECT StuID FROM Sportsinfo WHERE SportName = "Lacrosse"); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the name of all customers.
SELECT customer_name FROM customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are the names of all the customers?
SELECT customer_name FROM customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### How many customers are there?
SELECT count(*) FROM customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Return the total number of distinct customers.
SELECT count(*) FROM customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What is the average amount of items ordered in each order?
SELECT avg(order_quantity) FROM order_items; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the average order quantity per order.
SELECT avg(order_quantity) FROM order_items; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are the names of customers who use payment method "Cash"?
SELECT customer_name FROM customers WHERE payment_method = "Cash"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Which customers use "Cash" for payment method? Return the customer names.
SELECT customer_name FROM customers WHERE payment_method = "Cash"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the "date_became_customers" of the customers whose ID is between 10 and 20.
SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are the dates when customers with ids between 10 and 20 became customers?
SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Which payment method is used by most customers?
SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the payment method that is used most frequently.
SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are the names of customers using the most popular payment method?
SELECT customer_name FROM customers WHERE payment_method = (SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the name of the customers who use the most frequently used payment method.
SELECT customer_name FROM customers WHERE payment_method = (SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are all the payment methods?
SELECT DISTINCT payment_method FROM customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Return all the distinct payment methods used by customers.
SELECT DISTINCT payment_method FROM customers; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are the details of all products?
SELECT DISTINCT product_details FROM products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Return the the details of all products.
SELECT DISTINCT product_details FROM products; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the name of all customers whose name contains "Alex".
SELECT customer_name FROM customers WHERE customer_name LIKE "%Alex%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Which customer's name contains "Alex"? Find the full name.
SELECT customer_name FROM customers WHERE customer_name LIKE "%Alex%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the detail of products whose detail contains the word "Latte" or the word "Americano"
SELECT product_details FROM products WHERE product_details LIKE "%Latte%" OR product_details LIKE "%Americano%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Which product's detail contains the word "Latte" or "Americano"? Return the full detail.
SELECT product_details FROM products WHERE product_details LIKE "%Latte%" OR product_details LIKE "%Americano%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Retrieve the list of all cities.
SELECT DISTINCT city FROM addresses; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### List all the distinct cities
SELECT DISTINCT city FROM addresses; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the city with post code 255.
SELECT city FROM addresses WHERE zip_postcode = 255; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Which city is post code 255 located in?
SELECT city FROM addresses WHERE zip_postcode = 255; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the state and country of all cities with post code starting with 4.
SELECT state_province_county,country FROM addresses WHERE zip_postcode LIKE "4%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are the state and country of all the cities that have post codes starting with 4.\
SELECT state_province_county,country FROM addresses WHERE zip_postcode LIKE "4%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### List the countries having more than 4 addresses listed.
SELECT country FROM addresses GROUP BY country HAVING count(address_id) > 4; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### For which countries are there more than four distinct addresses listed?
SELECT country FROM addresses GROUP BY country HAVING count(address_id) > 4; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### List all the contact channel codes that were used less than 5 times.
SELECT channel_code FROM customer_contact_channels GROUP BY channel_code HAVING count(customer_id) < 5; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Which contact channel codes were used less than 5 times?
SELECT channel_code FROM customer_contact_channels GROUP BY channel_code HAVING count(customer_id) < 5; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What is the average time span of contact channels in the database?
SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Compute the average active time span of contact channels.
SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What is the channel code and contact number of the customer contact channel that was active for the longest time?
SELECT channel_code,contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date = (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Return the channel code and contact number of the customer contact channel whose active duration was the longest.
SELECT channel_code,contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date = (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1); ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### How many customers have at least one order with status "Cancelled"?
SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status = "Cancelled"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Return the number of customers who have at least one order with "Cancelled" status.
SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status = "Cancelled"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### How many orders have detail "Second_time"?
SELECT count(*) FROM customer_orders WHERE order_details = "Second_time"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Tell me the number of orders with "Second_time" as order detail.
SELECT count(*) FROM customer_orders WHERE order_details = "Second_time"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.
SELECT address_content FROM addresses WHERE city = "East_Julianaside" AND state_province_county = "Texas" UNION SELECT address_content FROM addresses WHERE city = "Gleasonmouth" AND state_province_county = "Arizona"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.
SELECT address_content FROM addresses WHERE city = "East_Julianaside" AND state_province_county = "Texas" UNION SELECT address_content FROM addresses WHERE city = "Gleasonmouth" AND state_province_county = "Arizona"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### Find the name of customers who did not pay with Cash.
SELECT customer_name FROM customers WHERE payment_method != 'Cash'; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"]
# products: ["product_id", "product_details"]
# customers: ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"]
# customer_addresses: ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"]
# customer_contact_channels: ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"]
# customer_orders: ["order_id", "customer_id", "order_status", "order_date", "order_details"]
# order_items: ["order_id", "product_id", "order_quantity"]
### What is the name of customers who do not use Cash as payment method.
SELECT customer_name FROM customers WHERE payment_method != 'Cash'; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### How many artists are there?
SELECT count(*) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Count the number of artists.
SELECT count(*) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### List the age of all music artists.
SELECT Age FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the ages of all music artists?
SELECT Age FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What is the average age of all artists?
SELECT avg(Age) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the average age across all artists.
SELECT avg(Age) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the famous titles of the artist "Triumfall"?
SELECT Famous_Title FROM artist WHERE Artist = "Triumfall"; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the famous titles of the artist called "Triumfall".
SELECT Famous_Title FROM artist WHERE Artist = "Triumfall"; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the distinct Famous release dates?
SELECT distinct(Famous_Release_date) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Give the distinct famous release dates for all artists.
SELECT distinct(Famous_Release_date) FROM artist; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the dates of ceremony and the results of all music festivals
SELECT Date_of_ceremony,RESULT FROM music_festival; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the dates of ceremony and results for each music festival?
SELECT Date_of_ceremony,RESULT FROM music_festival; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the category of music festivals with result "Awarded"?
SELECT Category FROM music_festival WHERE RESULT = "Awarded"; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the categories of music festivals that have the result "Awarded".
SELECT Category FROM music_festival WHERE RESULT = "Awarded"; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the maximum and minimum week on top of all volumes?
SELECT max(Weeks_on_Top),min(Weeks_on_Top) FROM volume; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Give the maximum and minimum weeks on top across all volumes.
SELECT max(Weeks_on_Top),min(Weeks_on_Top) FROM volume; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the songs in volumes with more than 1 week on top?
SELECT Song FROM volume WHERE Weeks_on_Top > 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Give the songs included in volumes that have more than 1 week on top.
SELECT Song FROM volume WHERE Weeks_on_Top > 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Please list all songs in volumes in ascending alphabetical order.
SELECT Song FROM volume ORDER BY Song; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the the songs in volumes, listed in ascending order?
SELECT Song FROM volume ORDER BY Song; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### How many distinct artists do the volumes associate to?
SELECT COUNT(DISTINCT Artist_ID) FROM volume; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Count the number of distinct artists who have volumes.
SELECT COUNT(DISTINCT Artist_ID) FROM volume; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Please list the age and famous title of artists in descending order of age.
SELECT Famous_Title,Age FROM artist ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the famous titles and ages of each artist, listed in descending order by age?
SELECT Famous_Title,Age FROM artist ORDER BY Age DESC; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What is the famous release date of the artist with the oldest age?
SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the famous release date for the oldest artist.
SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Please show the categories of the music festivals and the count.
SELECT Category,COUNT(*) FROM music_festival GROUP BY Category; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the number of music festivals of each category.
SELECT Category,COUNT(*) FROM music_festival GROUP BY Category; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What is the most common result of the music festival?
SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the result that is most frequent at music festivals.
SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Please show the categories of the music festivals with count more than 1.
SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the categories of music festivals for which there have been more than 1 music festival?
SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What is the song in the volume with the maximum weeks on top?
SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the song in the volume that has spent the most weeks on top?
SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Find the famous titles of artists that do not have any volume.
SELECT Famous_Title FROM artist WHERE Artist_ID NOT IN(SELECT Artist_ID FROM volume); ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the famous titles of artists who do not have any volumes?
SELECT Famous_Title FROM artist WHERE Artist_ID NOT IN(SELECT Artist_ID FROM volume); ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What are the date of ceremony of music festivals with category "Best_Song" and result "Awarded"?
SELECT Date_of_ceremony FROM music_festival WHERE Category = "Best_Song" AND RESULT = "Awarded"; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the dates of ceremony corresponding to music festivals that had the category "Best_Song" and result "Awarded".
SELECT Date_of_ceremony FROM music_festival WHERE Category = "Best_Song" AND RESULT = "Awarded"; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### What is the issue date of the volume with the minimum weeks on top?
SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Return the issue date of the volume that has spent the fewest weeks on top.
SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### How many distinct artists have volumes?
SELECT COUNT(DISTINCT Artist_ID) FROM volume; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Count the number of artists who have had volumes.
SELECT COUNT(DISTINCT Artist_ID) FROM volume; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### Please show the results of music festivals and the number of music festivals that have had each, ordered by this count.
SELECT RESULT,COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# artist: ["artist_id", "artist", "age", "famous_title", "famous_release_date"]
# volume: ["volume_id", "volume_issue", "issue_date", "weeks_on_top", "song", "artist_id"]
# music_festival: ["id", "music_festival", "date_of_ceremony", "category", "volume", "result"]
### How many music festivals have had each kind of result, ordered descending by count?
SELECT RESULT,COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### How many roller coasters are there?
SELECT count(*) FROM roller_coaster; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### List the names of roller coasters by ascending order of length.
SELECT Name FROM roller_coaster ORDER BY LENGTH ASC; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### What are the lengths and heights of roller coasters?
SELECT LENGTH,Height FROM roller_coaster; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### List the names of countries whose language is not "German".
SELECT Name FROM country WHERE Languages != "German"; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### Show the statuses of roller coasters longer than 3300 or higher than 100.
SELECT Status FROM roller_coaster WHERE LENGTH > 3300 OR Height > 100; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### What are the speeds of the longest roller coaster?
SELECT Speed FROM roller_coaster ORDER BY LENGTH DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### What is the average speed of roller coasters?
SELECT avg(Speed) FROM roller_coaster; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### Show the different statuses and the numbers of roller coasters for each status.
SELECT Status,COUNT(*) FROM roller_coaster GROUP BY Status; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### Please show the most common status of roller coasters.
SELECT Status FROM roller_coaster GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### List the status shared by more than two roller coaster.
SELECT Status FROM roller_coaster GROUP BY Status HAVING COUNT(*) > 2; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### Show the park of the roller coaster with the highest speed.
SELECT Park FROM roller_coaster ORDER BY Speed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# roller_coaster: ["roller_coaster_id", "name", "park", "country_id", "length", "height", "speed", "opened", "status"]
# country: ["country_id", "name", "population", "area", "languages"]
### How many countries do not have an roller coaster longer than 3000?
SELECT count(*) FROM country WHERE country_id NOT IN ( SELECT country_id FROM roller_coaster WHERE LENGTH > 3000 ); ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### How many different captain ranks are there?
SELECT count(DISTINCT rank) FROM captain; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Count the number of different ranks of captain.
SELECT count(DISTINCT rank) FROM captain; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### How many captains are in each rank?
SELECT count(*),rank FROM captain GROUP BY rank; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Count the number of captains that have each rank.
SELECT count(*),rank FROM captain GROUP BY rank; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### How many captains with younger than 50 are in each rank?
SELECT count(*),rank FROM captain WHERE age < 50 GROUP BY rank; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Count the number of captains younger than 50 of each rank.
SELECT count(*),rank FROM captain WHERE age < 50 GROUP BY rank; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Sort all captain names by their ages from old to young.
SELECT name FROM captain ORDER BY age DESC; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the names of captains, sorted by age descending?
SELECT name FROM captain ORDER BY age DESC; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Find the name, class and rank of all captains.
SELECT name,CLASS,rank FROM captain; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the names, classes, and ranks of all captains?
SELECT name,CLASS,rank FROM captain; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Which rank is the most common among captains?
SELECT rank FROM captain GROUP BY rank ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Return the rank for which there are the fewest captains.
SELECT rank FROM captain GROUP BY rank ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Which classes have more than two captains?
SELECT CLASS FROM captain GROUP BY CLASS HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Give the classes that have more than two captains.
SELECT CLASS FROM captain GROUP BY CLASS HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Find the name of captains whose rank are either Midshipman or Lieutenant.
SELECT name FROM captain WHERE rank = 'Midshipman' OR rank = 'Lieutenant'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the names of captains that have either the rank Midshipman or Lieutenant?
SELECT name FROM captain WHERE rank = 'Midshipman' OR rank = 'Lieutenant'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the average and minimum age of captains in different class?
SELECT avg(age),min(age),CLASS FROM captain GROUP BY CLASS; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Return the average and minimum age of captains in each class.
SELECT avg(age),min(age),CLASS FROM captain GROUP BY CLASS; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Find the captain rank that has some captains in both Cutter and Armed schooner classes.
SELECT rank FROM captain WHERE CLASS = 'Cutter' INTERSECT SELECT rank FROM captain WHERE CLASS = 'Armed schooner'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the ranks of captains that are both in the Cutter and Armed schooner classes?
SELECT rank FROM captain WHERE CLASS = 'Cutter' INTERSECT SELECT rank FROM captain WHERE CLASS = 'Armed schooner'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Find the captain rank that has no captain in Third-rate ship of the line class.
SELECT rank FROM captain EXCEPT SELECT rank FROM captain WHERE CLASS = 'Third-rate ship of the line'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the ranks of captains that have no captain that are in the Third-rate ship of the line class?
SELECT rank FROM captain EXCEPT SELECT rank FROM captain WHERE CLASS = 'Third-rate ship of the line'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What is the name of the youngest captain?
SELECT name FROM captain ORDER BY age LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Return the name of the youngest captain.
SELECT name FROM captain ORDER BY age LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### how many ships are there?
SELECT count(*) FROM ship; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Count the number of ships.
SELECT count(*) FROM ship; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Find the name, type, and flag of the ship that is built in the most recent year.
SELECT name,TYPE,flag FROM ship ORDER BY built_year DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What is the name, type, and flag of the ship that was built in the most recent year?
SELECT name,TYPE,flag FROM ship ORDER BY built_year DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Group by ships by flag, and return number of ships that have each flag.
SELECT count(*),flag FROM ship GROUP BY flag; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the different ship flags, and how many ships have each?
SELECT count(*),flag FROM ship GROUP BY flag; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Which flag is most widely used among all ships?
SELECT flag FROM ship GROUP BY flag ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Return the flag that is most common among all ships.
SELECT flag FROM ship GROUP BY flag ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### List all ship names in the order of built year and class.
SELECT name FROM ship ORDER BY built_year,CLASS; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the names of ships, ordered by year they were built and their class?
SELECT name FROM ship ORDER BY built_year,CLASS; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Find the ship type that are used by both ships with Panama and Malta flags.
SELECT TYPE FROM ship WHERE flag = 'Panama' INTERSECT SELECT TYPE FROM ship WHERE flag = 'Malta'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What types of ships have both ships that have Panama Flags and Malta flags?
SELECT TYPE FROM ship WHERE flag = 'Panama' INTERSECT SELECT TYPE FROM ship WHERE flag = 'Malta'; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### In which year were most of ships built?
SELECT built_year FROM ship GROUP BY built_year ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What is the year in which most ships were built?
SELECT built_year FROM ship GROUP BY built_year ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### what are the names and classes of the ships that do not have any captain yet?
SELECT name,CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain); ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Return the names and classes of ships that do not have a captain?
SELECT name,CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain); ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### Find the name and flag of ships that are not steered by any captain with Midshipman rank.
SELECT name,flag FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain WHERE rank = 'Midshipman'); ###
###Postgre SQL tables, with their properties:
# captain: ["captain_id", "name", "ship_id", "age", "class", "rank"]
# ship: ["ship_id", "name", "type", "built_year", "class", "flag"]
### What are the names and flags of ships that do not have a captain with the rank of Midshipman?
SELECT name,flag FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain WHERE rank = 'Midshipman'); ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### What is id of the city that hosted events in the most recent year?
SELECT host_city FROM hosting_city ORDER BY YEAR DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Find the city that hosted some events in the most recent year. What is the id of this city?
SELECT host_city FROM hosting_city ORDER BY YEAR DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Find the match ids of the cities that hosted competition "1994_FIFA_World_Cup_qualification"?
SELECT match_id FROM MATCH WHERE competition = "1994_FIFA_World_Cup_qualification"; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### What is the match id of the competition called "1994_FIFA_World_Cup_qualification"?
SELECT match_id FROM MATCH WHERE competition = "1994_FIFA_World_Cup_qualification"; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Which three cities have the largest regional population?
SELECT city FROM city ORDER BY regional_population DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### What are the three largest cities in terms of regional population?
SELECT city FROM city ORDER BY regional_population DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Which city has the lowest GDP? Please list the city name and its GDP.
SELECT city,GDP FROM city ORDER BY GDP LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### What is the city with the smallest GDP? Return the city and its GDP.
SELECT city,GDP FROM city ORDER BY GDP LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Please give me a list of cities whose regional population is over 10000000.
SELECT city FROM city WHERE regional_population > 10000000; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Which cities have regional population above 10000000?
SELECT city FROM city WHERE regional_population > 10000000; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Please give me a list of cities whose regional population is over 8000000 or under 5000000.
SELECT city FROM city WHERE regional_population > 10000000 UNION SELECT city FROM city WHERE regional_population < 5000000; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Which cities have regional population above 8000000 or below 5000000?
SELECT city FROM city WHERE regional_population > 10000000 UNION SELECT city FROM city WHERE regional_population < 5000000; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Find the number of matches in different competitions.
SELECT count(*),Competition FROM MATCH GROUP BY Competition; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### For each competition, count the number of matches.
SELECT count(*),Competition FROM MATCH GROUP BY Competition; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### List venues of all matches in the order of their dates starting from the most recent one.
SELECT venue FROM MATCH ORDER BY date DESC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### What are the venues of all the matches? Sort them in the descending order of match date.
SELECT venue FROM MATCH ORDER BY date DESC; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### what is the GDP of the city with the largest population.
SELECT gdp FROM city ORDER BY Regional_Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# city: ["city_id", "city", "hanzi", "hanyu_pinyin", "regional_population", "gdp"]
# match: ["match_id", "date", "venue", "score", "result", "competition"]
# temperature: ["city_id", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
# hosting_city: ["year", "match_id", "host_city"]
### Find the GDP of the city with the largest regional population.
SELECT gdp FROM city ORDER BY Regional_Population DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### List every individual's first name, middle name and last name in alphabetical order by last name.
SELECT individual_first_name,individual_middle_name,individual_last_name FROM individuals ORDER BY individual_last_name; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What are the first, middle, and last names of all individuals, ordered by last name?
SELECT individual_first_name,individual_middle_name,individual_last_name FROM individuals ORDER BY individual_last_name; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### List all the types of forms.
SELECT DISTINCT form_type_code FROM forms; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What are the different types of forms?
SELECT DISTINCT form_type_code FROM forms; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Find the payment method and phone of the party with email "enrico09@example.com".
SELECT payment_method_code,party_phone FROM parties WHERE party_email = "enrico09@example.com"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What is the payment method code and party phone of the party with the email 'enrico09@example.com'?
SELECT payment_method_code,party_phone FROM parties WHERE party_email = "enrico09@example.com"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### List all the name of organizations in order of the date formed.
SELECT organization_name FROM organizations ORDER BY date_formed ASC; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What are the names of organizations, ordered by the date they were formed, ascending?
SELECT organization_name FROM organizations ORDER BY date_formed ASC; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Find the name of the youngest organization.
SELECT organization_name FROM organizations ORDER BY date_formed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What is the name of the organization that was formed most recently?
SELECT organization_name FROM organizations ORDER BY date_formed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### How many services are there?
SELECT count(*) FROM services; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Count the number of services.
SELECT count(*) FROM services; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Find the name of all the cities and states.
SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What are the names of all cities and states?
SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### How many cities are there in state "Colorado"?
SELECT count(*) FROM addresses WHERE state_province_county = "Colorado"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Count the number of cities in the state of Colorado.
SELECT count(*) FROM addresses WHERE state_province_county = "Colorado"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Find the payment method code used by more than 3 parties.
SELECT payment_method_code FROM parties GROUP BY payment_method_code HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What are the payment method codes that have been used by more than 3 parties?
SELECT payment_method_code FROM parties GROUP BY payment_method_code HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Find the name of organizations whose names contain "Party".
SELECT organization_name FROM organizations WHERE organization_name LIKE "%Party%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### What are the names of organizations that contain the word "Party"?
SELECT organization_name FROM organizations WHERE organization_name LIKE "%Party%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### How many distinct payment methods are used by parties?
SELECT count(DISTINCT payment_method_code) FROM parties; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Count the number of different payment method codes used by parties.
SELECT count(DISTINCT payment_method_code) FROM parties; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Which state can address "6862_Kaitlyn_Knolls" possibly be in?
SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE "%6862_Kaitlyn_Knolls%"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "town_city", "zip_postcode", "state_province_county", "country"]
# services: ["service_id", "service_type_code", "service_name", "service_descriptio"]
# forms: ["form_id", "form_type_code", "service_id", "form_number", "form_name", "form_description"]
# individuals: ["individual_id", "individual_first_name", "individual_middle_name", "inidividual_phone", "individual_email", "individual_address", "individual_last_name"]
# organizations: ["organization_id", "date_formed", "organization_name", "uk_vat_number"]
# parties: ["party_id", "payment_method_code", "party_phone", "party_email"]
# organization_contact_individuals: ["individual_id", "organization_id", "date_contact_from", "date_contact_to"]
# party_addresses: ["party_id", "address_id", "date_address_from", "address_type_code", "date_address_to"]
# party_forms: ["party_id", "form_id", "date_completion_started", "form_status_code", "date_fully_completed"]
# party_services: ["booking_id", "customer_id", "service_id", "service_datetime", "booking_made_date"]
### Give the state corresponding to the line number building "6862_Kaitlyn_Knolls".
SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE "%6862_Kaitlyn_Knolls%"; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### How many drivers are there?
SELECT count(*) FROM driver; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the name, home city, and age for all drivers.
SELECT name,home_city,age FROM driver; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the party and the number of drivers in each party.
SELECT party,count(*) FROM driver GROUP BY party; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the name of drivers in descending order of age.
SELECT name FROM driver ORDER BY age DESC; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show all different home cities.
SELECT DISTINCT home_city FROM driver; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the home city with the most number of drivers.
SELECT home_city FROM driver GROUP BY home_city ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the party with drivers from Hartford and drivers older than 40.
SELECT party FROM driver WHERE home_city = 'Hartford' AND age > 40; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show home city where at least two drivers older than 40 are from.
SELECT home_city FROM driver WHERE age > 40 GROUP BY home_city HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show all home cities except for those having a driver older than 40.
SELECT home_city FROM driver EXCEPT SELECT home_city FROM driver WHERE age > 40; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the names of the drivers without a school bus.
SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus); ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the types of schools that have two schools.
SELECT TYPE FROM school GROUP BY TYPE HAVING count(*) = 2; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### What is the maximum, minimum and average years spent working on a school bus?
SELECT max(years_working),min(years_working),avg(years_working) FROM school_bus; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### Show the school name and type for schools without a school bus.
SELECT school,TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus); ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### How many drivers are from Hartford city or younger than 40?
SELECT count(*) FROM driver WHERE home_city = 'Hartford' OR age < 40; ###
###Postgre SQL tables, with their properties:
# driver: ["driver_id", "name", "party", "home_city", "age"]
# school: ["school_id", "grade", "school", "location", "type"]
# school_bus: ["school_id", "driver_id", "years_working", "if_full_time"]
### List names for drivers from Hartford city and younger than 40.
SELECT name FROM driver WHERE home_city = 'Hartford' AND age < 40; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### How many flights have a velocity larger than 200?
SELECT count(*) FROM flight WHERE velocity > 200; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### List the vehicle flight number, date and pilot of all the flights, ordered by altitude.
SELECT vehicle_flight_number,date,pilot FROM flight ORDER BY altitude ASC; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### List the id, country, city and name of the airports ordered alphabetically by the name.
SELECT id,country,city,name FROM airport ORDER BY name; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### What is maximum group equity shareholding of the companies?
SELECT max(group_equity_shareholding) FROM operate_company; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### What is the velocity of the pilot named 'Thompson'?
SELECT avg(velocity) FROM flight WHERE pilot = 'Thompson'; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### What are the names of the airports which are not in the country 'Iceland'?
SELECT name FROM airport WHERE country != 'Iceland'; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### What is the most common company type, and how many are there?
SELECT TYPE,count(*) FROM operate_company GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### How many airports haven't the pilot 'Thompson' driven an aircraft?
SELECT count(*) FROM airport WHERE id NOT IN ( SELECT airport_id FROM flight WHERE pilot = 'Thompson' );; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### Which of the airport names contains the word 'international'?
SELECT name FROM airport WHERE name LIKE '%international%'; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### how many airports are there in each country?
SELECT count(*),country FROM airport GROUP BY country; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### which countries have more than 2 airports?
SELECT country FROM airport GROUP BY country HAVING count(*) > 2; ###
###Postgre SQL tables, with their properties:
# airport: ["id", "city", "country", "iata", "icao", "name"]
# operate_company: ["id", "name", "type", "principal_activities", "incorporated_in", "group_equity_shareholding"]
# flight: ["id", "vehicle_flight_number", "date", "pilot", "velocity", "altitude", "airport_id", "company_id"]
### which pilot is in charge of the most number of flights?
SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many accounts do we have?
SELECT count(*) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Count the number of accounts.
SELECT count(*) FROM Accounts; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show all account ids and account details.
SELECT account_id,account_details FROM Accounts; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the ids and details of all accounts?
SELECT account_id,account_details FROM Accounts; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many statements do we have?
SELECT count(*) FROM Statements; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Count the number of statements.
SELECT count(*) FROM Statements; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### List all statement ids and statement details.
SELECT STATEMENT_ID,statement_details FROM Statements; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the ids and details of all statements?
SELECT STATEMENT_ID,statement_details FROM Statements; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show all statement id and the number of accounts for each statement.
SELECT STATEMENT_ID,count(*) FROM Accounts GROUP BY STATEMENT_ID; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the different statement ids on accounts, and the number of accounts for each?
SELECT STATEMENT_ID,count(*) FROM Accounts GROUP BY STATEMENT_ID; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show the number of documents.
SELECT count(*) FROM Documents; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Count the number of documents.
SELECT count(*) FROM Documents; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### List the document type code, document name, and document description for the document with name 'Noel CV' or name 'King Book'.
SELECT document_type_code,document_name,document_description FROM Documents WHERE document_name = 'Noel CV' OR document_name = 'King Book'; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the type come, name, and description of the document that has either the name 'Noel CV' or 'King Book'?
SELECT document_type_code,document_name,document_description FROM Documents WHERE document_name = 'Noel CV' OR document_name = 'King Book'; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show the ids and names of all documents.
SELECT document_id,document_name FROM Documents; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the ids and names for each of the documents?
SELECT document_id,document_name FROM Documents; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Find names and ids of all documents with document type code BK.
SELECT document_name,document_id FROM Documents WHERE document_type_code = "BK"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the names and ids of documents that have the type code BK?
SELECT document_name,document_id FROM Documents WHERE document_type_code = "BK"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many documents are with document type code BK for each product id?
SELECT count(*),project_id FROM Documents WHERE document_type_code = "BK" GROUP BY project_id; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Count the number of documents with the type code BK that correspond to each product id.
SELECT count(*),project_id FROM Documents WHERE document_type_code = "BK" GROUP BY project_id; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show project ids and the number of documents in each project.
SELECT project_id,count(*) FROM Documents GROUP BY project_id; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many documents correspond with each project id?
SELECT project_id,count(*) FROM Documents GROUP BY project_id; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What is the id of the project with least number of documents?
SELECT project_id FROM Documents GROUP BY project_id ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Return the id of the project that has the fewest corresponding documents.
SELECT project_id FROM Documents GROUP BY project_id ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show the ids for projects with at least 2 documents.
SELECT project_id FROM Documents GROUP BY project_id HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are project ids of projects that have 2 or more corresponding documents?
SELECT project_id FROM Documents GROUP BY project_id HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### List document type codes and the number of documents in each code.
SELECT document_type_code,count(*) FROM Documents GROUP BY document_type_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many documents are there of each type?
SELECT document_type_code,count(*) FROM Documents GROUP BY document_type_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What is the document type code with most number of documents?
SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Return the code of the document type that is most common.
SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show the document type code with fewer than 3 documents.
SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING count(*) < 3; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the codes corresponding to document types for which there are less than 3 documents?
SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING count(*) < 3; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show all document type codes, document type names, document type descriptions.
SELECT document_type_code,document_type_name,document_type_description FROM Ref_document_types; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the codes, names, and descriptions of the different document types?
SELECT document_type_code,document_type_name,document_type_description FROM Ref_document_types; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What is the document type description for document type named Film?
SELECT document_type_description FROM Ref_document_types WHERE document_type_name = "Film"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Return the description of the document type name 'Film'.
SELECT document_type_description FROM Ref_document_types WHERE document_type_name = "Film"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show the number of projects.
SELECT count(*) FROM Projects; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many projects are there?
SELECT count(*) FROM Projects; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### List ids and details for all projects.
SELECT project_id,project_details FROM Projects; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the ids and details for each project?
SELECT project_id,project_details FROM Projects; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many budget types do we have?
SELECT count(*) FROM Ref_budget_codes; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Count the number of budget codes.
SELECT count(*) FROM Ref_budget_codes; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### List all budget type codes and descriptions.
SELECT budget_type_code,budget_type_description FROM Ref_budget_codes; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the type codes and descriptions of each budget type?
SELECT budget_type_code,budget_type_description FROM Ref_budget_codes; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What is the description for the budget type with code ORG?
SELECT budget_type_description FROM Ref_budget_codes WHERE budget_type_code = "ORG"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Return the description of the budget type that has the code ORG.
SELECT budget_type_description FROM Ref_budget_codes WHERE budget_type_code = "ORG"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many documents have expenses?
SELECT count(*) FROM Documents_with_expenses; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Count the number of documents with expenses.
SELECT count(*) FROM Documents_with_expenses; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the document ids for the budget type code 'SF'?
SELECT document_id FROM Documents_with_expenses WHERE budget_type_code = 'SF'; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Give the ids of documents with expenses that have the budget code 'SF'.
SELECT document_id FROM Documents_with_expenses WHERE budget_type_code = 'SF'; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show budget type codes and the number of documents in each budget type.
SELECT budget_type_code,count(*) FROM Documents_with_expenses GROUP BY budget_type_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the different budget type codes, and how many documents are there for each?
SELECT budget_type_code,count(*) FROM Documents_with_expenses GROUP BY budget_type_code; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What is the budget type code with most number of documents.
SELECT budget_type_code FROM Documents_with_expenses GROUP BY budget_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Give the budget type code that is most common among documents with expenses.
SELECT budget_type_code FROM Documents_with_expenses GROUP BY budget_type_code ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the ids of documents which don't have expense budgets?
SELECT document_id FROM Documents EXCEPT SELECT document_id FROM Documents_with_expenses; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Return the ids of documents that do not have expenses.
SELECT document_id FROM Documents EXCEPT SELECT document_id FROM Documents_with_expenses; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Show ids for all documents in type CV without expense budgets.
SELECT document_id FROM Documents WHERE document_type_code = "CV" EXCEPT SELECT document_id FROM Documents_with_expenses; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the ids of documents with the type code CV that do not have expenses.
SELECT document_id FROM Documents WHERE document_type_code = "CV" EXCEPT SELECT document_id FROM Documents_with_expenses; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### How many documents do not have any expense?
SELECT count(*) FROM Documents WHERE document_id NOT IN ( SELECT document_id FROM Documents_with_expenses ); ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Count the number of documents that do not have expenses.
SELECT count(*) FROM Documents WHERE document_id NOT IN ( SELECT document_id FROM Documents_with_expenses ); ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### What are the account details with the largest value or with value having char '5' in it?
SELECT max(Account_details) FROM Accounts UNION SELECT Account_details FROM Accounts WHERE Account_details LIKE "%5%"; ###
###Postgre SQL tables, with their properties:
# reference_document_types: ["document_type_code", "document_type_name", "document_type_description"]
# reference_budget_codes: ["budget_type_code", "budget_type_description"]
# projects: ["project_id", "project_details"]
# documents: ["document_id", "document_type_code", "project_id", "document_date", "document_name", "document_description", "other_details"]
# statements: ["statement_id", "statement_details"]
# documents_with_expenses: ["document_id", "budget_type_code", "document_details"]
# accounts: ["account_id", "statement_id", "account_details"]
### Return the account details with the greatest value, as well as those that include the character 5.
SELECT max(Account_details) FROM Accounts UNION SELECT Account_details FROM Accounts WHERE Account_details LIKE "%5%"; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the total number of scientists.
SELECT count(*) FROM scientists; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### How many scientists are there?
SELECT count(*) FROM scientists; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the total hours of all projects.
SELECT sum(hours) FROM projects; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What is the total number of hours for all projects?
SELECT sum(hours) FROM projects; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### How many different scientists are assigned to any project?
SELECT count(DISTINCT scientist) FROM assignedto; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Count the number of different scientists assigned to any project.
SELECT count(DISTINCT scientist) FROM assignedto; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the number of distinct projects.
SELECT count(DISTINCT name) FROM projects; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### How many different projects are there?
SELECT count(DISTINCT name) FROM projects; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the average hours of all projects.
SELECT avg(hours) FROM projects; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What is the average hours across all projects?
SELECT avg(hours) FROM projects; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the name of project that continues for the longest time.
SELECT name FROM projects ORDER BY hours DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What is the name of the project with the most hours?
SELECT name FROM projects ORDER BY hours DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### List the name of all projects that are operated longer than the average working hours of all projects.
SELECT name FROM projects WHERE hours > (SELECT avg(hours) FROM projects); ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What are the names of projects that have taken longer than the average number of hours for all projects?
SELECT name FROM projects WHERE hours > (SELECT avg(hours) FROM projects); ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the name of projects that require between 100 and 300 hours of work.
SELECT name FROM projects WHERE hours BETWEEN 100 AND 300; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What are the names of projects that require between 100 and 300 hours?
SELECT name FROM projects WHERE hours BETWEEN 100 AND 300; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### List the names of all scientists sorted in alphabetical order.
SELECT name FROM scientists ORDER BY name; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What are the names of all the scientists in alphabetical order?
SELECT name FROM scientists ORDER BY name; ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Select the project names which are not assigned yet.
SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo); ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What are the names of projects that have not been assigned?
SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo); ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the name of scientists who are not assigned to any project.
SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo); ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### What are the names of scientists who have not been assigned a project?
SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo); ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### Find the number of scientists who are not assigned to any project.
SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo); ###
###Postgre SQL tables, with their properties:
# scientists: ["ssn", "name"]
# projects: ["code", "name", "hours"]
# assigned_to: ["scientist", "project"]
### How many scientists do not have any projects assigned to them?
SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo); ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What is the name of the highest rated wine?
SELECT Name FROM WINE ORDER BY Score LIMIT 1; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Give the name of the wine with the highest score.
SELECT Name FROM WINE ORDER BY Score LIMIT 1; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Which winery is the wine that has the highest score from?
SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What is the winery at which the wine with the highest score was made?
SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Find the names of all wines produced in 2008.
SELECT Name FROM WINE WHERE YEAR = "2008"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names of all wines produced in 2008?
SELECT Name FROM WINE WHERE YEAR = "2008"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the grapes and appelations of all wines.
SELECT Grape,Appelation FROM WINE; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the grapes and appelations of each wine?
SELECT Grape,Appelation FROM WINE; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the names and scores of all wines.
SELECT Name,Score FROM WINE; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names and scores of all wines?
SELECT Name,Score FROM WINE; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the area and county of all appelations.
SELECT Area,County FROM APPELLATIONS; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the areas and counties for all appelations?
SELECT Area,County FROM APPELLATIONS; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the prices of wines produced before the year of 2010?
SELECT Price FROM WINE WHERE YEAR < 2010; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Return the prices of wines produced before 2010.
SELECT Price FROM WINE WHERE YEAR < 2010; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the names of all distinct wines that have scores higher than 90.
SELECT Name FROM WINE WHERE score > 90; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names of wines with scores higher than 90?
SELECT Name FROM WINE WHERE score > 90; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### How many wines are produced at Robert Biale winery?
SELECT count(*) FROM WINE WHERE Winery = "Robert_Biale"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Count the number of wines produced at Robert Biale winery.
SELECT count(*) FROM WINE WHERE Winery = "Robert_Biale"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### How many appelations are in Napa Country?
SELECT count(*) FROM APPELLATIONS WHERE County = "Napa"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Count the number of appelations in Napa County.
SELECT count(*) FROM APPELLATIONS WHERE County = "Napa"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the numbers of wines for different grapes?
SELECT count(*),Grape FROM WINE GROUP BY Grape; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### How many wines are there for each grape?
SELECT count(*),Grape FROM WINE GROUP BY Grape; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the average prices of wines for different years?
SELECT avg(Price),YEAR FROM WINE GROUP BY YEAR; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What is the average prices of wines for each each?
SELECT avg(Price),YEAR FROM WINE GROUP BY YEAR; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Find the distinct names of all wines that have prices higher than some wines from John Anthony winery.
SELECT DISTINCT Name FROM WINE WHERE Price > (SELECT min(Price) FROM wine WHERE Winery = "John_Anthony"); ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the distinct names of wines with prices higher than any wine from John Anthony winery.
SELECT DISTINCT Name FROM WINE WHERE Price > (SELECT min(Price) FROM wine WHERE Winery = "John_Anthony"); ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the names of all distinct wines in alphabetical order.
SELECT DISTINCT Name FROM WINE ORDER BY Name; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names of wines, sorted in alphabetical order?
SELECT DISTINCT Name FROM WINE ORDER BY Name; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the names of all distinct wines ordered by price.
SELECT DISTINCT Name FROM WINE ORDER BY price; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names of wines, sorted by price ascending?
SELECT DISTINCT Name FROM WINE ORDER BY price; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Find the distinct names of wines produced before the year of 2000 or after the year of 2010.
SELECT DISTINCT Name FROM WINE WHERE YEAR < 2000 OR YEAR > 2010; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Give the distinct names of wines made before 2000 or after 2010.
SELECT DISTINCT Name FROM WINE WHERE YEAR < 2000 OR YEAR > 2010; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Find the distinct winery of wines having price between 50 and 100.
SELECT DISTINCT Winery FROM WINE WHERE Price BETWEEN 50 AND 100; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the distinct wineries which produce wines costing between 50 and 100?
SELECT DISTINCT Winery FROM WINE WHERE Price BETWEEN 50 AND 100; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the average prices and cases of wines produced in the year of 2009 and made of Zinfandel grape?
SELECT AVG(Price),AVG(Cases) FROM WINE WHERE YEAR = 2009 AND Grape = "Zinfandel"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Give the average price and case of wines made from Zinfandel grapes in the year 2009.
SELECT AVG(Price),AVG(Cases) FROM WINE WHERE YEAR = 2009 AND Grape = "Zinfandel"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the maximum price and score of wines produced by St. Helena appelation?
SELECT max(Price),max(Score) FROM WINE WHERE Appelation = "St._Helena"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Give the maximum price and score for wines produced in the appelation St. Helena.
SELECT max(Price),max(Score) FROM WINE WHERE Appelation = "St._Helena"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the maximum price and score of wines in each year?
SELECT max(Price),max(Score),YEAR FROM WINE GROUP BY YEAR; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the maximum price and score of wines for each year?
SELECT max(Price),max(Score),YEAR FROM WINE GROUP BY YEAR; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the average price and score of wines grouped by appelation?
SELECT avg(Price),avg(Score),Appelation FROM WINE GROUP BY Appelation; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the average price and score of wines for each appelation?
SELECT avg(Price),avg(Score),Appelation FROM WINE GROUP BY Appelation; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Find the wineries that have at least four wines.
SELECT Winery FROM WINE GROUP BY Winery HAVING count(*) >= 4; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Which wineries produce at least four wines?
SELECT Winery FROM WINE GROUP BY Winery HAVING count(*) >= 4; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names of wines whose production year are before the year of all wines by Brander winery?
SELECT Name FROM WINE WHERE YEAR < (SELECT min(YEAR) FROM WINE WHERE Winery = "Brander"); ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names of wines produced before any wine from the Brander winery?
SELECT Name FROM WINE WHERE YEAR < (SELECT min(YEAR) FROM WINE WHERE Winery = "Brander"); ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the names of wines that are more expensive then all wines made in the year 2006?
SELECT Name FROM WINE WHERE Price > (SELECT max(Price) FROM WINE WHERE YEAR = 2006); ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Give the names of wines with prices above any wine produced in 2006.
SELECT Name FROM WINE WHERE Price > (SELECT max(Price) FROM WINE WHERE YEAR = 2006); ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the grape, winery and year of the wines whose price is bigger than 100 ordered by year.
SELECT Grape,Winery,YEAR FROM WINE WHERE Price > 100 ORDER BY YEAR; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the grapes, wineries and years for wines with price higher than 100, sorted by year?
SELECT Grape,Winery,YEAR FROM WINE WHERE Price > 100 ORDER BY YEAR; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### List the grape, appelation and name of wines whose score is higher than 93 ordered by Name.
SELECT Grape,Appelation,Name FROM WINE WHERE Score > 93 ORDER BY Name; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the grapes, appelations, and wines with scores above 93, sorted by Name?
SELECT Grape,Appelation,Name FROM WINE WHERE Score > 93 ORDER BY Name; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### Find the appelations that produce wines after the year of 2008 but not in Central Coast area.
SELECT Appelation FROM WINE WHERE YEAR > 2008 EXCEPT SELECT Appelation FROM APPELLATIONS WHERE Area = "Central_Coast"; ###
###Postgre SQL tables, with their properties:
# grapes: ["id", "grape", "color"]
# appellations: ["no", "appelation", "county", "state", "area", "isava"]
# wine: ["no", "grape", "winery", "appelation", "state", "name", "year", "price", "score", "cases", "drink"]
### What are the appelations for wines produced after 2008 but not in the Central Coast area?
SELECT Appelation FROM WINE WHERE YEAR > 2008 EXCEPT SELECT Appelation FROM APPELLATIONS WHERE Area = "Central_Coast"; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### How many train stations are there?
SELECT count(*) FROM station; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show the name, location, and number of platforms for all stations.
SELECT name,LOCATION,number_of_platforms FROM station; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### What are all locations of train stations?
SELECT DISTINCT LOCATION FROM station; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show the names and total passengers for all train stations not in London.
SELECT name,total_passengers FROM station WHERE LOCATION != 'London'; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show the names and main services for train stations that have the top three total number of passengers.
SELECT name,main_services FROM station ORDER BY total_passengers DESC LIMIT 3; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### What is the average and maximum number of total passengers for train stations in London or Glasgow?
SELECT avg(total_passengers),max(total_passengers) FROM station WHERE LOCATION = 'London' OR LOCATION = 'Glasgow'; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show all locations and the total number of platforms and passengers for all train stations in each location.
SELECT LOCATION,sum(number_of_platforms),sum(total_passengers) FROM station GROUP BY LOCATION; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show all locations that have train stations with at least 15 platforms and train stations with more than 25 total passengers.
SELECT DISTINCT LOCATION FROM station WHERE number_of_platforms >= 15 AND total_passengers > 25; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show all locations which don't have a train station with at least 15 platforms.
SELECT LOCATION FROM station EXCEPT SELECT LOCATION FROM station WHERE number_of_platforms >= 15; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show the location with most number of train stations.
SELECT LOCATION FROM station GROUP BY LOCATION ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show the name, time, and service for all trains.
SELECT name,TIME,service FROM train; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show the number of trains
SELECT count(*) FROM train; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show the name and service for all trains in order by time.
SELECT name,service FROM train ORDER BY TIME; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show all locations with only 1 station.
SELECT LOCATION FROM station GROUP BY LOCATION HAVING count(*) = 1; ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### Show station names without any trains.
SELECT name FROM station WHERE station_id NOT IN (SELECT station_id FROM train_station); ###
###Postgre SQL tables, with their properties:
# station: ["station_id", "name", "annual_entry_exit", "annual_interchanges", "total_passengers", "location", "main_services", "number_of_platforms"]
# train: ["train_id", "name", "time", "service"]
# train_station: ["train_id", "station_id"]
### List the names and locations of all stations ordered by their yearly entry exit and interchange amounts.
SELECT name,LOCATION FROM station ORDER BY Annual_entry_exit,Annual_interchanges; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List all vehicle id
SELECT vehicle_id FROM Vehicles;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the ids of all vehicles?
SELECT vehicle_id FROM Vehicles;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many vehicle in total?
SELECT count(*) FROM Vehicles;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many vehicles exist?
SELECT count(*) FROM Vehicles;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### Show the detail of vehicle with id 1.
SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the details of the car with id 1?
SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List the first name middle name and last name of all staff.
SELECT first_name,middle_name,last_name FROM Staff;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the first, middle, and last names of all staff?
SELECT first_name,middle_name,last_name FROM Staff;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the birthday of the staff member with first name as Janessa and last name as Sawayn?
SELECT date_of_birth FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the date of birth for the staff member named Janessa Sawayn?
SELECT date_of_birth FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### When did the staff member with first name as Janessa and last name as Sawayn join the company?
SELECT date_joined_staff FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### When did the staff member named Janessa Sawayn join the company?
SELECT date_joined_staff FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### When did the staff member with first name as Janessa and last name as Sawayn leave the company?
SELECT date_left_staff FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### When did the staff member Janessa Sawayn leave the company?
SELECT date_left_staff FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many staff have the first name Ludie?
SELECT count(*) FROM Staff WHERE first_name = "Ludie";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many employees have a first name of Ludie?
SELECT count(*) FROM Staff WHERE first_name = "Ludie";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the nickname of staff with first name as Janessa and last name as Sawayn?
SELECT nickname FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the nickname of the employee named Janessa Sawayn?
SELECT nickname FROM Staff WHERE first_name = "Janessa" AND last_name = "Sawayn";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many staff in total?
SELECT count(*) FROM Staff;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many employees are there?
SELECT count(*) FROM Staff;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many staff live in state Georgia?
SELECT count(*) FROM Addresses WHERE state_province_county = "Georgia";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many employees live in Georgia?
SELECT count(*) FROM Addresses WHERE state_province_county = "Georgia";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List the first name and last name of all customers.
SELECT first_name,last_name FROM Customers;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the first and last names for all customers?
SELECT first_name,last_name FROM Customers;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List email address and birthday of customer whose first name as Carole.
SELECT email_address,date_of_birth FROM Customers WHERE first_name = "Carole"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the email addresses and date of births for all customers who have a first name of Carole?
SELECT email_address,date_of_birth FROM Customers WHERE first_name = "Carole"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List phone number and email address of customer with more than 2000 outstanding balance.
SELECT phone_number,email_address FROM Customers WHERE amount_outstanding > 2000;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the phone numbers and email addresses of all customers who have an outstanding balance of more than 2000?
SELECT phone_number,email_address FROM Customers WHERE amount_outstanding > 2000;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the status code, mobile phone number and email address of customer with last name as Kohler or first name as Marina?
SELECT customer_status_code,cell_mobile_phone_number,email_address FROM Customers WHERE first_name = "Marina" OR last_name = "Kohler"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?
SELECT customer_status_code,cell_mobile_phone_number,email_address FROM Customers WHERE first_name = "Marina" OR last_name = "Kohler"; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### When are the birthdays of customer who are classified as 'Good Customer' status?
SELECT date_of_birth FROM Customers WHERE customer_status_code = 'Good Customer'; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the date of birth of every customer whose status code is 'Good Customer'?
SELECT date_of_birth FROM Customers WHERE customer_status_code = 'Good Customer'; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### When did customer with first name as Carole and last name as Bernhard became a customer?
SELECT date_became_customer FROM Customers WHERE first_name = "Carole" AND last_name = "Bernhard";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### When did Carole Bernhard first become a customer?
SELECT date_became_customer FROM Customers WHERE first_name = "Carole" AND last_name = "Bernhard";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many customers in total?
SELECT count(*) FROM Customers;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many customers are there?
SELECT count(*) FROM Customers;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List all customer status codes and the number of customers having each status code.
SELECT customer_status_code,count(*) FROM Customers GROUP BY customer_status_code;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### For each customer status code, how many customers are classified that way?
SELECT customer_status_code,count(*) FROM Customers GROUP BY customer_status_code;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### Which customer status code has least number of customers?
SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY count(*) ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the status code with the least number of customers?
SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY count(*) ASC LIMIT 1;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is maximum, minimum and average amount of outstanding of customer?
SELECT max(amount_outstanding),min(amount_outstanding),avg(amount_outstanding) FROM Customers;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What is the maximum, minimum, and average amount of money outsanding for all customers?
SELECT max(amount_outstanding),min(amount_outstanding),avg(amount_outstanding) FROM Customers;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List the first name and last name of customers have the amount of outstanding between 1000 and 3000.
SELECT first_name,last_name FROM Customers WHERE amount_outstanding BETWEEN 1000 AND 3000;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the first and last names of all customers with between 1000 and 3000 dollars outstanding?
SELECT first_name,last_name FROM Customers WHERE amount_outstanding BETWEEN 1000 AND 3000;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List the number of customers that did not have any payment history.
SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payments );; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many customers have no payment histories?
SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payments );; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### List all payment methods and number of payments using each payment methods.
SELECT payment_method_code,count(*) FROM Customer_Payments GROUP BY payment_method_code;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### For each payment method, how many payments were made?
SELECT payment_method_code,count(*) FROM Customer_Payments GROUP BY payment_method_code;; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many lessons were in cancelled state?
SELECT count(*) FROM Lessons WHERE lesson_status_code = "Cancelled";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### How many lessons have been cancelled?
SELECT count(*) FROM Lessons WHERE lesson_status_code = "Cancelled";; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### Which last names are both used by customers and by staff?
SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff; ###
###Postgre SQL tables, with their properties:
# addresses: ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"]
# staff: ["staff_id", "staff_address_id", "nickname", "first_name", "middle_name", "last_name", "date_of_birth", "date_joined_staff", "date_left_staff"]
# vehicles: ["vehicle_id", "vehicle_details"]
# customers: ["customer_id", "customer_address_id", "customer_status_code", "date_became_customer", "date_of_birth", "first_name", "last_name", "amount_outstanding", "email_address", "phone_number", "cell_mobile_phone_number"]
# customer_payments: ["customer_id", "datetime_payment", "payment_method_code", "amount_payment"]
# lessons: ["lesson_id", "customer_id", "lesson_status_code", "staff_id", "vehicle_id", "lesson_date", "lesson_time", "price"]
### What are the last names that are used by customers and staff?
SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many faculty do we have?
SELECT count(*) FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What is the total number of faculty members?
SELECT count(*) FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What ranks do we have for faculty?
SELECT DISTINCT rank FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Find the list of distinct ranks for faculty.
SELECT DISTINCT rank FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show all the distinct buildings that have faculty rooms.
SELECT DISTINCT building FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What buildings have faculty offices?
SELECT DISTINCT building FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the rank, first name, and last name for all the faculty.
SELECT rank,Fname,Lname FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the rank, first name, and last name of the faculty members?
SELECT rank,Fname,Lname FROM Faculty; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the first name, last name, and phone number for all female faculty members.
SELECT Fname,Lname,phone FROM Faculty WHERE Sex = 'F'; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the first name, last name, and phone number of all the female faculty members?
SELECT Fname,Lname,phone FROM Faculty WHERE Sex = 'F'; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show ids for all the male faculty.
SELECT FacID FROM Faculty WHERE Sex = 'M'; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the faculty ids of all the male faculty members?
SELECT FacID FROM Faculty WHERE Sex = 'M'; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many female Professors do we have?
SELECT count(*) FROM Faculty WHERE Sex = 'F' AND Rank = "Professor"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Count the number of female Professors we have.
SELECT count(*) FROM Faculty WHERE Sex = 'F' AND Rank = "Professor"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the phone, room, and building for the faculty named Jerry Prince.
SELECT phone,room,building FROM Faculty WHERE Fname = "Jerry" AND Lname = "Prince"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the phone, room, and building of the faculty member called Jerry Prince?
SELECT phone,room,building FROM Faculty WHERE Fname = "Jerry" AND Lname = "Prince"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many Professors are in building NEB?
SELECT count(*) FROM Faculty WHERE Rank = "Professor" AND building = "NEB"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Count the number of Professors who have office in building NEB.
SELECT count(*) FROM Faculty WHERE Rank = "Professor" AND building = "NEB"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the first name and last name for all the instructors.
SELECT fname,lname FROM Faculty WHERE Rank = "Instructor"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the first name and last name of all the instructors?
SELECT fname,lname FROM Faculty WHERE Rank = "Instructor"; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show all the buildings along with the number of faculty members the buildings have.
SELECT building,count(*) FROM Faculty GROUP BY building; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many faculty members does each building have? List the result with the name of the building.
SELECT building,count(*) FROM Faculty GROUP BY building; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Which building has most faculty members?
SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Find the building that has the largest number of faculty members.
SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show all the buildings that have at least 10 professors.
SELECT building FROM Faculty WHERE rank = "Professor" GROUP BY building HAVING count(*) >= 10; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### In which buildings are there at least ten professors?
SELECT building FROM Faculty WHERE rank = "Professor" GROUP BY building HAVING count(*) >= 10; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### For each faculty rank, show the number of faculty members who have it.
SELECT rank,count(*) FROM Faculty GROUP BY rank; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many faculty members do we have for each faculty rank?
SELECT rank,count(*) FROM Faculty GROUP BY rank; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show all the ranks and the number of male and female faculty for each rank.
SELECT rank,sex,count(*) FROM Faculty GROUP BY rank,sex; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many faculty members do we have for each rank and gender?
SELECT rank,sex,count(*) FROM Faculty GROUP BY rank,sex; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Which rank has the smallest number of faculty members?
SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Find the faculty rank that has the least members.
SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the number of male and female assistant professors.
SELECT sex,count(*) FROM Faculty WHERE rank = "AsstProf" GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many male and female assistant professors do we have?
SELECT sex,count(*) FROM Faculty WHERE rank = "AsstProf" GROUP BY sex; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show ids for the faculty members who don't advise any student.
SELECT FacID FROM Faculty EXCEPT SELECT advisor FROM Student; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the ids of the faculty members who do not advise any student.
SELECT FacID FROM Faculty EXCEPT SELECT advisor FROM Student; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What activities do we have?
SELECT activity_name FROM Activity; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### List all the activities we have.
SELECT activity_name FROM Activity; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many activities do we have?
SELECT count(*) FROM Activity; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Find the number of activities available.
SELECT count(*) FROM Activity; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### How many faculty members participate in an activity?
SELECT count(DISTINCT FacID) FROM Faculty_participates_in; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Give me the number of faculty members who participate in an activity
SELECT count(DISTINCT FacID) FROM Faculty_participates_in; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the ids of the faculty who don't participate in any activity.
SELECT FacID FROM Faculty EXCEPT SELECT FacID FROM Faculty_participates_in; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Which faculty do not participate in any activity? Find their faculty ids.
SELECT FacID FROM Faculty EXCEPT SELECT FacID FROM Faculty_participates_in; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the ids of all the faculty members who participate in an activity and advise a student.
SELECT FacID FROM Faculty_participates_in INTERSECT SELECT advisor FROM Student; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are ids of the faculty members who not only participate in an activity but also advise a student.
SELECT FacID FROM Faculty_participates_in INTERSECT SELECT advisor FROM Student; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the ids of the students who don't participate in any activity.
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Participates_in; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the ids of the students who are not involved in any activity
SELECT StuID FROM Student EXCEPT SELECT StuID FROM Participates_in; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### Show the ids for all the students who participate in an activity and are under 20.
SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age < 20; ###
###Postgre SQL tables, with their properties:
# activity: ["activity_id", "activity_name"]
# participates_in: ["student_id", "activity_id"]
# faculty_participates_in: ["faculty_id", "activity_id"]
# student: ["student_id", "last_name", "first_name", "age", "sex", "major", "advisor", "city_code"]
# faculty: ["faculty_id", "last_name", "first_name", "rank", "sex", "phone", "room", "building"]
### What are the ids of the students who are under 20 years old and are involved in at least one activity.
SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age < 20; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the name of the airport in the city of Goroka.
SELECT name FROM airports WHERE city = 'Goroka'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the names of the airports in the city of Goroka?
SELECT name FROM airports WHERE city = 'Goroka'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the name, city, country, and altitude (or elevation) of the airports in the city of New York.
SELECT name,city,country,elevation FROM airports WHERE city = 'New York'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the name, city, country, and elevation for every airport in the city of New York?
SELECT name,city,country,elevation FROM airports WHERE city = 'New York'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many airlines are there?
SELECT count(*) FROM airlines; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the total number of airlines?
SELECT count(*) FROM airlines; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many airlines does Russia has?
SELECT count(*) FROM airlines WHERE country = 'Russia'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the number of airlines based in Russia?
SELECT count(*) FROM airlines WHERE country = 'Russia'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the maximum elevation of all airports in the country of Iceland?
SELECT max(elevation) FROM airports WHERE country = 'Iceland'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the highest elevation of an airport in the country of Iceland?
SELECT max(elevation) FROM airports WHERE country = 'Iceland'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the name of the airports located in Cuba or Argentina.
SELECT name FROM airports WHERE country = 'Cuba' OR country = 'Argentina'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the names of all airports in Cuba or Argentina?
SELECT name FROM airports WHERE country = 'Cuba' OR country = 'Argentina'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the country of the airlines whose name starts with 'Orbit'.
SELECT country FROM airlines WHERE name LIKE 'Orbit%'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the countries of all airlines whose names start with Orbit?
SELECT country FROM airlines WHERE name LIKE 'Orbit%'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the name of airports whose altitude is between -50 and 50.
SELECT name FROM airports WHERE elevation BETWEEN -50 AND 50; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the names of all airports whose elevation is between -50 and 50?
SELECT name FROM airports WHERE elevation BETWEEN -50 AND 50; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Which country is the airport that has the highest altitude located in?
SELECT country FROM airports ORDER BY elevation DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the country of the airport with the highest elevation?
SELECT country FROM airports ORDER BY elevation DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the number of airports whose name contain the word 'International'.
SELECT count(*) FROM airports WHERE name LIKE '%International%'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many airports' names have the word Interanation in them?
SELECT count(*) FROM airports WHERE name LIKE '%International%'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many different cities do have some airport in the country of Greenland?
SELECT count(DISTINCT city) FROM airports WHERE country = 'Greenland'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### In how many cities are there airports in the country of Greenland?
SELECT count(DISTINCT city) FROM airports WHERE country = 'Greenland'; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the name, city, and country of the airport that has the lowest altitude.
SELECT name,city,country FROM airports ORDER BY elevation LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the name, city, and country of the airport with the lowest altitude?
SELECT name,city,country FROM airports ORDER BY elevation LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the name, city, and country of the airport that has the highest latitude.
SELECT name,city,country FROM airports ORDER BY elevation DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the name, city, and country of the airport with the highest elevation?
SELECT name,city,country FROM airports ORDER BY elevation DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Which countries has the most number of airlines?
SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the name of the country with the most number of home airlines?
SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Which countries has the most number of airlines whose active status is 'Y'?
SELECT country FROM airlines WHERE active = 'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the countries with the most airlines whose active status is Y?
SELECT country FROM airlines WHERE active = 'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### List all countries and their number of airlines in the descending order of number of airlines.
SELECT country,count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many airlines operate out of each country in descending order?
SELECT country,count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many airports are there per country? Order the countries by decreasing number of airports.
SELECT count(*),country FROM airports GROUP BY country ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the number of airports per country, ordered from most to least?
SELECT count(*),country FROM airports GROUP BY country ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many airports are there per city in the United States? Order the cities by decreasing number of airports.
SELECT count(*),city FROM airports WHERE country = 'United States' GROUP BY city ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many airports are there per city in the US ordered from most to least?
SELECT count(*),city FROM airports WHERE country = 'United States' GROUP BY city ORDER BY count(*) DESC; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Return the cities with more than 3 airports in the United States.
SELECT city FROM airports WHERE country = 'United States' GROUP BY city HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the number of cities in the United States with more than 3 airports?
SELECT city FROM airports WHERE country = 'United States' GROUP BY city HAVING count(*) > 3; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many cities are there that have more than 3 airports?
SELECT count(*) FROM (SELECT city FROM airports GROUP BY city HAVING count(*) > 3); ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the count of cities with more than 3 airports?
SELECT count(*) FROM (SELECT city FROM airports GROUP BY city HAVING count(*) > 3); ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### List the cities which have more than one airport and number of airports.
SELECT city,count(*) FROM airports GROUP BY city HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the names of all cities with more than one airport and how many airports do they have?
SELECT city,count(*) FROM airports GROUP BY city HAVING count(*) > 1; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### List the cities which have more than 2 airports sorted by the number of airports.
SELECT city FROM airports GROUP BY city HAVING count(*) > 2 ORDER BY count(*); ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the cities that have more than 2 airports sorted by number of airports?
SELECT city FROM airports GROUP BY city HAVING count(*) > 2 ORDER BY count(*); ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the average elevation of all airports for each country.
SELECT avg(elevation),country FROM airports GROUP BY country; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### For each country, what is the average elevation of that country's airports?
SELECT avg(elevation),country FROM airports GROUP BY country; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the cities which have exactly two airports.
SELECT city FROM airports GROUP BY city HAVING count(*) = 2; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What are the cities with exactly two airports?
SELECT city FROM airports GROUP BY city HAVING count(*) = 2; ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the number of routes from the United States to Canada.
SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country = 'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country = 'United States'); ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### How many routes go from the United States to Canada?
SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country = 'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country = 'United States'); ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### Find the id of routes whose source and destination airports are in the United States.
SELECT rid FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country = 'United States') AND src_apid IN (SELECT apid FROM airports WHERE country = 'United States'); ###
###Postgre SQL tables, with their properties:
# routes: ["route_id", "destination_airport_id", "destination_airport", "source_airport_id", "source_airport", "airline_id", "airline", "code_share"]
# airports: ["airport_id", "name", "city", "country", "x", "y", "elevation", "iata", "icao"]
# airlines: ["airline_id", "name", "iata", "icao", "call_sign", "country", "active"]
### What is the id of the routes whose source and destination airports are in the United States?
SELECT rid FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country = 'United States') AND src_apid IN (SELECT apid FROM airports WHERE country = 'United States'); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### What is the id of the most recent order?
SELECT order_id FROM orders ORDER BY date_order_placed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the id of the order made most recently.
SELECT order_id FROM orders ORDER BY date_order_placed DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### what are the order id and customer id of the oldest order?
SELECT order_id,customer_id FROM orders ORDER BY date_order_placed LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the order id and customer id associated with the oldest order.
SELECT order_id,customer_id FROM orders ORDER BY date_order_placed LIMIT 1; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the id of the order whose shipment tracking number is "3452".
SELECT order_id FROM shipments WHERE shipment_tracking_number = "3452"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Which order's shipment tracking number is "3452"? Give me the id of the order.
SELECT order_id FROM shipments WHERE shipment_tracking_number = "3452"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the ids of all the order items whose product id is 11.
SELECT order_item_id FROM order_items WHERE product_id = 11; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find all the order items whose product id is 11. What are the order item ids?
SELECT order_item_id FROM order_items WHERE product_id = 11; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the ids of orders which are shipped after 2000-01-01.
SELECT order_id FROM shipments WHERE shipment_date > "2000-01-01"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Which orders have shipment after 2000-01-01? Give me the order ids.
SELECT order_id FROM shipments WHERE shipment_date > "2000-01-01"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the id of the order which is shipped most recently.
SELECT order_id FROM shipments WHERE shipment_date = (SELECT max(shipment_date) FROM shipments); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Which order has the most recent shipment? Give me the order id.
SELECT order_id FROM shipments WHERE shipment_date = (SELECT max(shipment_date) FROM shipments); ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### List the names of all distinct products in alphabetical order.
SELECT DISTINCT product_name FROM products ORDER BY product_name; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Sort all the distinct products in alphabetical order.
SELECT DISTINCT product_name FROM products ORDER BY product_name; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### List the ids of all distinct orders ordered by placed date.
SELECT DISTINCT order_id FROM orders ORDER BY date_order_placed; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### What are ids of the all distinct orders, sorted by placement date?
SELECT DISTINCT order_id FROM orders ORDER BY date_order_placed; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the invoice numbers which are created before 1989-09-03 or after 2007-12-25.
SELECT invoice_number FROM invoices WHERE invoice_date < "1989-09-03" OR invoice_date > "2007-12-25"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### What are the invoice numbers created before 1989-09-03 or after 2007-12-25?
SELECT invoice_number FROM invoices WHERE invoice_date < "1989-09-03" OR invoice_date > "2007-12-25"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### Find the distinct details of invoices which are created before 1989-09-03 or after 2007-12-25.
SELECT DISTINCT invoice_details FROM invoices WHERE invoice_date < "1989-09-03" OR invoice_date > "2007-12-25"; ###
###Postgre SQL tables, with their properties:
# customers: ["customer_id", "customer_name", "customer_details"]
# invoices: ["invoice_number", "invoice_date", "invoice_details"]
# orders: ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"]
# products: ["product_id", "product_name", "product_details"]
# order_items: ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"]
# shipments: ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"]
# shipment_items: ["shipment_id", "order_item_id"]
### What are the distinct details of invoices created before 1989-09-03 or after 2007-12-25?
SELECT DISTINCT invoice_details FROM invoices WHERE invoice_date < "1989-09-03" OR invoice_date > "2007-12-25"; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### How many architects are female?
SELECT count(*) FROM architect WHERE gender = 'female'; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### List the name, nationality and id of all male architects ordered by their names lexicographically.
SELECT name,nationality,id FROM architect WHERE gender = 'male' ORDER BY name; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### What is the average length in feet of the bridges?
SELECT avg(length_feet) FROM bridge; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### What are the names and year of construction for the mills of 'Grondzeiler' type?
SELECT name,built_year FROM mill WHERE TYPE = 'Grondzeiler'; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### What are the names of the mills which are not located in 'Donceel'?
SELECT name FROM mill WHERE LOCATION != 'Donceel'; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### What is the location of the bridge named 'Kolob Arch' or 'Rainbow Bridge'?
SELECT LOCATION FROM bridge WHERE name = 'Kolob Arch' OR name = 'Rainbow Bridge'; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### Which of the mill names contains the french word 'Moulin'?
SELECT name FROM mill WHERE name LIKE '%Moulin%'; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### What is the most common mill type, and how many are there?
SELECT TYPE,count(*) FROM mill GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# architect: ["id", "name", "nationality", "gender"]
# bridge: ["architect_id", "id", "name", "location", "length_meters", "length_feet"]
# mill: ["architect_id", "id", "location", "name", "type", "built_year", "notes"]
### How many architects haven't built a mill before year 1850?
SELECT count(*) FROM architect WHERE id NOT IN ( SELECT architect_id FROM mill WHERE built_year < 1850 );; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### How many book clubs are there?
SELECT count(*) FROM book_club; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Count the number of book clubs.
SELECT count(*) FROM book_club; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### show the titles, and authors or editors for all books made after the year 1989.
SELECT book_title,author_or_editor FROM book_club WHERE YEAR > 1989; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What are the titles and authors or editors that correspond to books made after 1989?
SELECT book_title,author_or_editor FROM book_club WHERE YEAR > 1989; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show all distinct publishers for books.
SELECT DISTINCT publisher FROM book_club; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What are all the different book publishers?
SELECT DISTINCT publisher FROM book_club; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show the years, book titles, and publishers for all books, in descending order by year.
SELECT YEAR,book_title,publisher FROM book_club ORDER BY YEAR DESC; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What are the years, titles, and publishers for all books, ordered by year descending?
SELECT YEAR,book_title,publisher FROM book_club ORDER BY YEAR DESC; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show all publishers and the number of books for each publisher.
SELECT publisher,count(*) FROM book_club GROUP BY publisher; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### How many books are there for each publisher?
SELECT publisher,count(*) FROM book_club GROUP BY publisher; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What is the publisher with most number of books?
SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Return the publisher that has published the most books.
SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show all book categories and the number of books in each category.
SELECT category,count(*) FROM book_club GROUP BY category; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### How many books fall into each category?
SELECT category,count(*) FROM book_club GROUP BY category; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### List categories that have at least two books after year 1989.
SELECT category FROM book_club WHERE YEAR > 1989 GROUP BY category HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What categories have two or more corresponding books that were made after 1989?
SELECT category FROM book_club WHERE YEAR > 1989 GROUP BY category HAVING count(*) >= 2; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show publishers with a book published in 1989 and a book in 1990.
SELECT publisher FROM book_club WHERE YEAR = 1989 INTERSECT SELECT publisher FROM book_club WHERE YEAR = 1990; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What are the publishers who have published a book in both 1989 and 1990?
SELECT publisher FROM book_club WHERE YEAR = 1989 INTERSECT SELECT publisher FROM book_club WHERE YEAR = 1990; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show all publishers which do not have a book in 1989.
SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR = 1989; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Which publishers did not publish a book in 1989?
SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR = 1989; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show all movie titles, years, and directors, ordered by budget.
SELECT title,YEAR,director FROM movie ORDER BY budget_million; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What are the titles, years, and directors of all movies, ordered by budget in millions?
SELECT title,YEAR,director FROM movie ORDER BY budget_million; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### How many movie directors are there?
SELECT COUNT (DISTINCT director) FROM movie; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Count the number of different directors.
SELECT COUNT (DISTINCT director) FROM movie; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What is the title and director for the movie with highest worldwide gross in the year 2000 or before?
SELECT title,director FROM movie WHERE YEAR <= 2000 ORDER BY gross_worldwide DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Return the title and director of the movie released in the year 2000 or earlier that had the highest worldwide gross.
SELECT title,director FROM movie WHERE YEAR <= 2000 ORDER BY gross_worldwide DESC LIMIT 1; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show all director names who have a movie in both year 1999 and 2000.
SELECT director FROM movie WHERE YEAR = 2000 INTERSECT SELECT director FROM movie WHERE YEAR = 1999; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Which directors had a movie both in the year 1999 and 2000?
SELECT director FROM movie WHERE YEAR = 2000 INTERSECT SELECT director FROM movie WHERE YEAR = 1999; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Show all director names who have a movie in the year 1999 or 2000.
SELECT director FROM movie WHERE YEAR = 1999 OR YEAR = 2000; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Which directors had a movie in either 1999 or 2000?
SELECT director FROM movie WHERE YEAR = 1999 OR YEAR = 2000; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### What is the average, maximum, and minimum budget for all movies before 2000.
SELECT avg(budget_million),max(budget_million),min(budget_million) FROM movie WHERE YEAR < 2000; ###
###Postgre SQL tables, with their properties:
# book_club: ["book_club_id", "year", "author_or_editor", "book_title", "publisher", "category", "result"]
# movie: ["movie_id", "title", "year", "director", "budget_million", "gross_worldwide"]
# culture_company: ["company_name", "type", "incorporated_in", "group_equity_shareholding", "book_club_id", "movie_id"]
### Return the average, maximum, and minimum budgets in millions for movies made before the year 2000.
SELECT avg(budget_million),max(budget_million),min(budget_million) FROM movie WHERE YEAR < 2000; ###
